package Binary::Symbol::Parser;
use strict;

use BDE::Object;
use vars qw(@ISA);
@ISA=qw(BDE::Object);

use Binary::Symbol;

#==============================================================================

=head1 NAME

Binary::Symbol::Parser - Generate symbol objects from descriptive strings

=head1 SYNOPSIS

  my $scanner=new Binary::Symbol::Scanner();
  my @lines=$scanner->scan("myobject.o");

  my $parser=new Binary::Symbol::Parser();
  my @symbols=map { $parser->parse($_) } @lines;

=head1 DESCRIPTION

C<Binary::Symbol::Parser> generates C<Binary::Symbol> objects whose attributes
are populated according to the contents of a string describing the symbol.
Suitable strings are generated by the C<Binary::Symbol::Scanner> object class.
It provides an object class with one public method, C<parser>, that returns
a C<Binary::Symbol> object on success, or C<undef> if the supplied string
could not be parsed.

The regular expression used to parse the symbols is common to all platforms,
and so this class expects the supplied string to always conform to the format:

  (archive:)[object]: value type(*) name

It is the responsibility of the platform implementations supporting
L<Binary::Symbol::Scanner> to generate strings that are compatible with this
specification.

=cut

#==============================================================================

use constant SYMBOL_PARSE_REGEX => qr/^
    ([^:]*)\[([^\]]+)\]   # archive,object name
    :\s+
    (\S+)     # value
    \s+
    (\w)(\*?) # type, weakness
    \s+
    (\S+)     # name
$/x;

sub parse ($$) {
    #my ($self,$item)=@_;
    # (skip debugging symbols (name begins with '$'))

    return ($_[1] =~ SYMBOL_PARSE_REGEX && substr($6,0,1) ne '$')
      ? new Binary::Symbol({
            archive => $1, object => $2, value => $3,
            type    => $4, weak   => $5, name  => $6
	})
      : undef;
}

#------------------------------------------------------------------------------

sub test ($) {
    require Binary::Symbol::Scanner;

    my $scanner=new Binary::Symbol::Scanner();
    my $parser=new Binary::Symbol::Parser();
    print "Scanner: $scanner\n";
    print "Parser: $parser\n";

    print "=== Scanning $_[0]\n";
    my @scans=$scanner->scan($_[0]);
    print join "\n",@scans;
    print "\n=== Parsing $_[0]\n";
    print "\n=== Done\n";
    foreach my $scan (@scans) {
	my $symbol=$parser->parse($scan);
	if ($symbol) {
	    print "-- ",($symbol->isDefined?"*defined*":"UNDEFINED"),
              " [",$symbol->getObject(),"] '$symbol'",
	      " type=",  $symbol->getType(),
	      " value=", $symbol->getValue(),
              " weak=" , ($symbol->isWeak?1:0),
              "\n";
	} else {
	    print "!! parse of '$scan' failed\n";
	}
    }
}

#==============================================================================

=head1 AUTHOR

Peter Wainwright (pwainwright@bloomberg.net)

=head1 SEE ALSO

L<Binary::Symbol>, L<Binary::Symbol::Scanner>

=cut

1;
