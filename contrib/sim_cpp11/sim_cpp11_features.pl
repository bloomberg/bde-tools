#!/usr/bin/env perl
#                                                                    -*-perl-*-

=pod

=head1 Purpose

The B<sim_cpp11_features.pl> program converts a file with specially delimited
regions of C++11 code and generates a C++03 version of that code that
emulates the C++11 features. By default, the C++03 expansions are placed
in a separate file with an extra "C<_cpp03>" delimiter before the extension.
Currently, this program emulates two constructs:

=over

=item * Variadic templates are emulated by creating multiple copies of the
template code, starting with zero template arguments and adding an
argument with each repetition (up to 10 arguments by default).

=item * Forwarding references in function arguments are emulated by
surrounding the argument declaration in a C<BSLS_COMPILERFEATURES_FORWARD_REF>
macro invocation and replacing C<std::forward> calls with
C<BSLS_COMPILERFEATURES_FORWARD>.

=back

Both emulations are approximate, at best, but experience has found them to be
extremely useful.


=head1 Usage

B<Usage:> C<sim_cpp11_features.pl> [ I<option...> ] I<input-file-name...>

Each input file can contain zero or more regions delimited by the simulation
marker

  #if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES

and its matching C<#endif>.

A C++11 compiler will see the code within each simulation region verbatim. A
C++03 compiler will see an alternative version of the code generated by
this tool.

The program is located in the C<bde-tools> repo as
F<contrib/sim_cpp11/sim_cpp11_features.pl>.

=head2 Options

=head3 C<--output=>I<filename.ext>

Specifies the name of the output file. By default, the C++11 output overwrites
the input file and the C++03 output is written to a file whose name is the
same as the input filename except with a "C<_cpp03>" inserted before the
filename extension. For example, if the input file is "C<bxxy_useful.h>", then
the C++03 expansion is written to "C<bxxy_useful_cpp03.h>". If C<--output> is
specified, then the C++11 output is written to I<filename.ext> and the C++03
output is written to I<filename_cpp03.ext>.  If I<filename> is a single dash
(-), then output is written to standard out (C<--inplace> mode only).

=head3 C<--[no-]inplace>

The C<--inplace> option causes the C++11 and C++03 code to be intermixed
within the same output file, separated by conditional compilation
directives. This option, which was the only operating mode prior to June 2020,
tends to produce a verbose source file that is difficult to maintain. The
default is C<--no-inplace>.

=head3 C<--verify-no-change>

Verify that nothing has changed in the main file that would result in a
change in generated code (including any generated code within the main file
itself).  If any output (including the main file) would change, do not write
any output and abort with an error.

=head3 C<--clean>

When used with C<--inplace>, removes all C++03 emulation code, leaving a
C++11-only file that is more convenient to maintain during
development. Typically, this option is used once just before adding or
modifying code. After a successful build using C++11, this tool is typically
run again without C<--clean> to produce release code that can be tested
with C++03.

=head3 C<--var-args=>I<max-args>

The maximum number of variadic template expansions to generate (default
10). This value is written into the C++11 file as an embedded option (see
below) so that future runs do not need to specify this option again.

=head3 C<--test>

Runs the tool on a built-in test file, producing a C<diff> of the original and
modified file if changes were detected. Usually used with C<--inplace>

=head3 C<--debug=>I<level>

Turns on debugging at the specified level. The higher the level, the more
verbose the output.

=head3 C<--trace=>I<subroutine>:I<level>

Turns on tracing for the specified subroutine (for debugging).

=head3 I<input-file-name...>

One or more input file names.  If the input file is a single dash (-), then
read from standard input.

=head2 Embedded options

A few options can be embedded directly into the input file at the end of an
C<#if> directive that introduces a region to be emulated:

=head3 C<// $var-args=>I<n>

Globally sets the maximum number of variadic template expansions to I<n>. A
value specified using the command-line C<--var-args> option overrides the
value of I<n> specified using this embedded option and overwrites I<n> in the
generated output.

=head3 C<// $local-var-args=>I<n>

Sets the maximum number of variadic template expansions to I<n> only for the
current region. The number of expansions returns to the file default after the
closing C<#endif>.


=head1 Limitations

The C++11 emulation provided by this tool is incomplete at best. It does not
produce a semantic interpretation of the input code and is limited to basic
pattern matching. Known limitations are:

=over

=item * All parameter packs for a given instantiation of a variadic template
must be the same length.

=item * Perfect-forwarding emulation does not recognize prvalues as rvalues.

=item * There is limited support for partial specialization of variadic class
templates. In particular, specializing on the empty parameter pack is not
currently supported.

=back


=head1 Example

The following input file (let's call it "C<foo.h>"):


    #if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES // $var-args=3

    template <class... ARG>
    void j(ARG&&... arg) {
        g(std::forward<ARG>(arg)...);
    }

    #endif

gets rewritten into the same input file ("C<foo.h>") as:

    #include <bsls_compilerfeatures.h>

    #if BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
    // Include version that can be compiled with C++03
    // Generated on Mon Nov  2 13:17:20 2020
    // Command line: sim_cpp11_features.pl foo.h
    # define COMPILING_FOO_H
    # include <foo_cpp03.h>
    # undef COMPILING_FOO_H
    #else

    #if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES // $var-args=3

            template <class... ARG>
            void j(ARG&&... arg) {
                g(std::forward<ARG>(arg)...);
            }

    #endif

    #endif // End C++11 code

and a new "C<_cpp03>" header file is created with the C++03 equivalent
expansions ("C<foo_cpp03.h>"):

    // foo_cpp03.h                                                        -*-C++-*-

    // Automatically generated file.  **DO NOT EDIT**

    #ifndef INCLUDED_FOO_CPP03
    #define INCLUDED_FOO_CPP03

    //@PURPOSE: Provide C++03 implementation for foo.h
    //
    //@CLASSES: See foo.h for list of classes
    //
    //@SEE_ALSO: foo
    //
    //@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
    // generated by the 'sim_cpp11_features.pl' program.  If the original header
    // contains any specially delimited regions of C++11 code, then this generated
    // file contains the C++03 equivalent, i.e., with variadic templates expanded
    // and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
    // code in this file is designed to be '#include'd into the original header
    // when compiling with a C++03 compiler.  If there are no specially delimited
    // regions of C++11 code, then this header contains no code and is not
    // '#include'd in the original header.
    //
    // Generated on Mon Nov  2 13:17:20 2020
    // Command line: sim_cpp11_features.pl foo.h

    #ifdef COMPILING_FOO_H

    #if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
    // {{{ BEGIN GENERATED CODE
    // Command line: sim_cpp11_features.pl foo.h
    #ifndef FOO_VARIADIC_LIMIT
    #define FOO_VARIADIC_LIMIT 3
    #endif
    #ifndef FOO_VARIADIC_LIMIT_A
    #define FOO_VARIADIC_LIMIT_A FOO_VARIADIC_LIMIT
    #endif

    #if FOO_VARIADIC_LIMIT_A >= 0
            void j() {
                g();
            }
    #endif  // FOO_VARIADIC_LIMIT_A >= 0

    #if FOO_VARIADIC_LIMIT_A >= 1
            template <class ARG_1>
            void j(BSLS_COMPILERFEATURES_FORWARD_REF(ARG_1) arg_1) {
                g(BSLS_COMPILERFEATURES_FORWARD(ARG_1, arg_1));
            }
    #endif  // FOO_VARIADIC_LIMIT_A >= 1

    #if FOO_VARIADIC_LIMIT_A >= 2
            template <class ARG_1,
                      class ARG_2>
            void j(BSLS_COMPILERFEATURES_FORWARD_REF(ARG_1) arg_1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARG_2) arg_2) {
                g(BSLS_COMPILERFEATURES_FORWARD(ARG_1, arg_1),
                  BSLS_COMPILERFEATURES_FORWARD(ARG_2, arg_2));
            }
    #endif  // FOO_VARIADIC_LIMIT_A >= 2

    #if FOO_VARIADIC_LIMIT_A >= 3
            template <class ARG_1,
                      class ARG_2,
                      class ARG_3>
            void j(BSLS_COMPILERFEATURES_FORWARD_REF(ARG_1) arg_1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARG_2) arg_2,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARG_3) arg_3) {
                g(BSLS_COMPILERFEATURES_FORWARD(ARG_1, arg_1),
                  BSLS_COMPILERFEATURES_FORWARD(ARG_2, arg_2),
                  BSLS_COMPILERFEATURES_FORWARD(ARG_3, arg_3));
            }
    #endif  // FOO_VARIADIC_LIMIT_A >= 3

    #else
    // The generated code below is a workaround for the absence of perfect
    // forwarding in some compilers.

            template <class... ARG>
            void j(BSLS_COMPILERFEATURES_FORWARD_REF(ARG)... arg) {
                g(BSLS_COMPILERFEATURES_FORWARD(ARG, arg)...);
            }

    // }}} END GENERATED CODE
    #endif

    #else // if ! defined(DEFINED_FOO_H)
    # error Not valid except when included from foo.h
    #endif // ! defined(COMPILING_FOO_H)

    #endif // ! defined(INCLUDED_FOO_CPP03)

    // ----------------------------------------------------------------------------
    // Copyright 2020 Bloomberg Finance L.P.
    //
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    //
    //     http://www.apache.org/licenses/LICENSE-2.0
    //
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    // ----------------------------- END-OF-FILE ----------------------------------

=cut

use strict;
use 5.010;

use FindBin;
use lib "$FindBin::RealBin/../bdedox/lib/perl";

# These using decl's replace the use of 'common::sense' which is not installed
# by default.
use utf8;
use strict qw(vars subs);
use feature qw(unicode_eval evalbytes);
use warnings;

use Getopt::Long;
use File::Basename;
use Fcntl;  # For sysopen modes

use Util::Message qw(fatal debug debug2 message);

# Debug settings
$Util::Message::DEBUG_PREFIX =  "##";   # Prefix for each debug line
$Util::Message::DEBUG2_PREFIX = "###";  # Prefix for each detailed debug line
Util::Message::set_prog("");  # Don't prefix each debug line with prog name

my $debug = 0;
my $clean = 0;
my $inplace = 0;
my $verifyNoChange = 0;
my $selfTest = 0;
my $defaultMaxArgs = 10;
my $fileMaxArgs = $defaultMaxArgs;
my $maxArgs = $fileMaxArgs;
my $maxArgsOpt = 0;  # Command-line specified max args
my $maxColumn = 79;  # Maximum allowed output line length
my $commandLine;  # command line used to invoke the generator
my $timestampPrefix = "Generated on ";
my $timestampComment;  # Comment string containing time stamp
my $variadic_limit_base;
my $variadic_limit;

# Set of class templates that have been forward declared already.
my %classTemplateForwardDeclared;

# 80 spaces, for constructing indentations.
my $spaces = ("                                        ".
              "                                        ");

# Dummy character to fill in for string literal contents in stripped code
# buffers.  A normal period is easier to view in debug mode, whereas a Latin-1
# interpunct (centered dot) is less likely to show up in search.
our $dummyChar = $debug ? "." : "\267";

###############################################################################
#                            TRACING FUNCTIONS                                #
###############################################################################

my %traceCtrls;

# Return the larger of the level for the specified trace label or the
# currently-specified debug level.
sub getTraceLevel($)
{
    my $traceLabel = $_[0];

    my $traceLevel = $traceCtrls{$traceLabel} || 0;
    my $debugLevel = Util::Message::get_debug();

    if ($debugLevel > $traceLevel) {
        return $debugLevel;                                            # RETURN
    }
    else {
        return $traceLevel;                                            # RETURN
    }
}

sub doTrace($$$@) {
    my ($traceLabel, $debugLevel, $msgfunc, $message, @args) = @_;

    my $traceLevel = getTraceLevel($traceLabel);
    return unless ($traceLevel >= $debugLevel);                        # RETURN

    my $oldDebugLevel = Util::Message::get_debug();
    my $oldMsgPrefix = Util::Message::get_prefix();
    Util::Message::set_debug($traceLevel);
    Util::Message::set_prefix($traceLabel);
    &$msgfunc(sprintf($message, @args));
    Util::Message::set_prefix($oldMsgPrefix);
    Util::Message::set_debug($oldDebugLevel);
}

sub trace($@)
{
    my ($traceLabel, @message) = @_;
    doTrace($traceLabel, 1, \&debug, @message);
}

sub trace2($@)
{
    my ($traceLabel, @message) = @_;
    doTrace($traceLabel, 2, \&debug2, @message);
}

###############################################################################
#                        FACILITIES FOR C++ CODE SEARCHES                     #
###############################################################################

# Input file as a single string.  A position within this string is represented
# as an integer index of a character in the string.  The '$inputEnd' position
# is set to 'length($input)', which is the first position past the end of the
# string.  The $shroudedInput string is the same as $input except with
# character literals, string literals, and comments shrouded so that their
# contents will not interfere with regular expression matches.
my $input;
my $inputEnd;
my $shroudedInput;

my %matchingBrackets = ( '[' => ']',
                         '{' => '}',
                         '(' => ')',
                         '<' => '>' );

# Regular expression to find a comment or string string.  After being used in
# a successful regular expression match, exactly one of the following will be
# set:
#
#  $1   A C++-style comment, e.g. "// comment text\n" (excluding quotes)
#  $2   A C-style comment, e.g., "/* comment text */" (excluding quotes)
#  $3   A string literal, e.g., "string text" (including quotes)
#  $4   A character literal, e.g., 'x' (including quotes)
#
# Note that the string and character literals will terminate without complaint
# at an unescaped newline.  Better to get a clear error from the compiler than
# an obscure error from a Perl script.
my $commentAndStringRe =
    qr{(?:
        (//(?:[^\\\n]+|\\.|\\\n)*$)     | # C++-style comment
        (/\*(?:[^*]+|\*[^*/])*\*/)     | # C-style comment
        ("(?:[^"\\\n]+|\\.|\\\n)*["\n]) | # string literal
        ('(?:[^'\\\n]+|\\.|\\\n)*['\n])   # character literal
       )}mx;

# Return a string of whitespace to be used in place of the specified
# '$comment' string.  If $comment contains whitespace before or after the
# actual comment, it is considered as part of the comment for the purpose of
# this transformation.  The specified '$option' (default "single-ws") must be
# one of the following:
#
#  "single-ws"  Result contains a single whitespace character.
#  "keep-nl"    Result contains the same number of newlines as '$comment' does
#  "keep-len"   Result is the same length as '$comment' and has newlines in
#               the same positions.
sub commentToWhitespace($;$)
{
    my ($comment, $option) = @_;
    $option ||= "single-ws";

    my $first = substr($comment, 0, 1);
    my $last  = substr($comment, -1, 1);

    if ($option eq "single-ws") {
        # Choose single whitespace character: newline if comment ends with a
        # newline, space otherwise.
        $comment = $last eq "\n" ? "\n" : " ";
    }
    elsif ($option eq "keep-nl") {
        # Remove all characters except newlines
        $comment =~ s/[^\n]//g;
        $comment ||= ' ';  # Make sure there is at least one whitespace
    }
    elsif ($option eq "keep-len") {
        # Replace all non-newline characters with spaces, preserving the
        # character count and keeping newlines in the same positions.
        $comment =~ s/[^\n]/ /g;
    }
    else {
        fatal("Illegal option $option");
    }

    return $comment;
}

# Return the result of "shrouding" comments, string literals, and character
# literals in the specified '$input' string so that they contain no C++ tokens
# that might confuse a regular expression search.  Comments are replace by
# whitespace and the contents of quoted strings are replaced by dots.
sub shroudCommentsAndStrings($)
{
    my $input = shift;

    pos($input) = 0;

    while ($input =~ m{$commentAndStringRe}g)
    {
        my $start = $-[0];
        my $end   = $+[0];

        my $comment = $1 || $2;
        my $literal = $3 || $4;
        my $replacement;

        if ($comment) {
            $replacement = commentToWhitespace($comment, "keep-len");
        }
        elsif ($literal) {
            my $first = substr($input, $start, 1);
            my $last  = substr($input, $end - 1, 1);
            $replacement = $literal;
            $replacement =~ s/./$dummyChar/mg;
            substr($replacement, 0, 1) = $first;
            substr($replacement, -1)   = $last;
        }
        else {
            die "Shouldn't get here";
        }

        substr($input, $start, $end - $start) = $replacement;
        pos($input) = $start + length($replacement);
    }

    return $input;
}

# Strip comments from the specified '$input', replacing them with whitespace
# and return the result.  The optionally specified '$option' (default
# "single-ws") can be one of the following:
#
#  "single-ws"  Replace each comment with a single whitespace character.
#  "keep-nl"    Replace each comment with a string of whitespace containing
#               same number of newlines.
#  "keep-len"   Replace each comment with a string of whitespace of the same
#               length and with newlines in the same positions.
sub stripComments($;$)
{
    my ($input, $option) = @_;
    $option ||= "single-ws";

    pos($input) = 0;

    while ($input =~ m{\h*$commentAndStringRe\h*\n?}g)
    {
        my $start = $-[0];
        my $end   = $+[0];
        my $last  = substr($input, -1);

        if ($1 || $2) {
            my $comment = $&;
            if ($option eq "single-ws" && $last eq "\n" &&
                ($start == 0 || substr($input, $start - 1, 1) eq "\n")) {
                # Comment takes one or more whole lines.  Replace with nothing.
                $comment = "";
            }
            else {
                $comment = commentToWhitespace($comment, $option);
            }
            substr($input, $start, $end - $start) = $comment;
            pos($input) = $start + length($comment);
        }
    }

    return $input;
}

# Sets the '$input' string to the argument and resets and populates the
# '$shroudedInput' string.
sub setInput($)
{
    my $instr = shift;          # Work around a Perl bug?
    $input = $instr;
    $input =~ s:\r\n:\n:g;      # Normalize newlines
    $input .= "\n" if ("\n" ne substr($input, -1, 1));
    $inputEnd = length($input);
    pos($input) = 0;
    $shroudedInput = shroudCommentsAndStrings($input);
}

# Ability to push and pop input contexts
{
    my @inputStack = ();
    my @inputEndStack = ();
    my @shroudedInputStack = ();
    my @posStack = ();

    # Like 'setInput' but preserves the previous input string, shrouded input
    # string, and position.
    sub pushInput($)
    {
        push @inputStack, $input;
        push @inputEndStack, $inputEnd;
        push @shroudedInputStack, $shroudedInput;
        push @posStack, pos($input);

        setInput($_[0]);
    }

    # Restore the input context from the top of the context stack
    sub popInput()
    {
        die "Empty input stack" unless (@inputStack);
        my $ret = $input;
        $input = pop @inputStack;
        $inputEnd = pop @inputEndStack;
        $shroudedInput = pop @shroudedInputStack;
        pos($input) = pop @posStack;

        return $ret;
    }
}

# Search the '$input' string within the '[$pos, $endpos)' range for
# the specified '$re' regular expression. The '$pos' and '$endpos' arguments
# are optional and default to '[0, length($input)]'.  Skip matches within
# comments, string literals, and character literals.  If called within array
# context, return an array of captures on success or an empty array on
# failure, just as a normal regular expression match.  If called within scalar
# context, returns 1 on success and an empty string on failure.  Set the
# global variables '@cppMatch', '@cppMatchStart', and '@cppMatchEnd' using the
# following mapping to the normal regexp variables as follows:
#..
#  @cppMatch      is equivalent to (undef, $1, $2, $3, ...)
#  $cppMatchAll   is equivalent to $&
#  @cppMatchStart is equivalent to @-
#  @cppMatchEnd   is equivalent to @+
#..
# Match will fail for strings that appear only within comments or
# quotes: e.g., "//", '"', etc. and newlines will not be found within comments
# (including at the end of C++-style comments.
my @cppMatch;
my $cppMatchAll;
my @cppMatchStart;
my @cppMatchEnd;
sub cppSearch($;$$)
{
    my ($re, $pos, $endpos) = @_;
    $pos    = 0         unless (defined($pos));
    $endpos = $inputEnd unless (defined($endpos));

    pos($input) = $pos;
    pos($shroudedInput) = $pos;
    if ($shroudedInput =~ m/$re/g && $+[0] <= $endpos) {
        @cppMatchStart = @-;
        @cppMatchEnd   = @+;
        $cppMatchAll   = substr($input, $cppMatchStart[0],
                                $cppMatchEnd[0] - $cppMatchStart[0]);
        @cppMatch      = ( $cppMatchAll );

        for (my $i = 1; $i < @cppMatchStart; ++$i) {
            if (defined $cppMatchStart[$i]) {
                push @cppMatch, substr($input, $cppMatchStart[$i],
                                       $cppMatchEnd[$i] - $cppMatchStart[$i]);
            }
            else {
                push @cppMatch, undef;
            }
        }

        pos($input) = $cppMatchEnd[0];
        pos($shroudedInput) = $cppMatchEnd[0];
        if (! wantarray()) {
            return 1;                                                  # RETURN
        }
        else {
            return ($cppMatchAll);                                     # RETURN
        }
    }

    # Got here if no acceptable match was found
    @cppMatch      = ();
    $cppMatchAll   = undef;
    @cppMatchStart = ();
    @cppMatchEnd   = ();
    return wantarray() ? @cppMatch : "";
}

# Replace the substring in '$input' beginning at the specified '$start'
# position, removing the specified '$length' characters and replacing them
# with the specified '$subst' string.  Adjust all of the 'cppSearch' state
# accordingly.
sub cppSubstitute($$$)
{
    my ($start, $length, $subst) = @_;
    my $end = $start + $length;

    my $lengthChange = length($subst) - ($length);

    substr($input, $start, $length) = $subst;
    substr($shroudedInput, $start, $length) =
        shroudCommentsAndStrings($subst);

    for my $matchPos (@cppMatchStart) {
        $matchPos //= 0;
        if ($matchPos >= $end) {
            $matchPos += $lengthChange;
        }
    }

    for my $matchPos (@cppMatchEnd) {
        $matchPos //= 0;
        if ($matchPos >= $end) {
            $matchPos += $lengthChange;
        }
    }

    if (defined(pos($input)) && pos($input) >= $end) {
        pos($input) = pos($input) + $lengthChange;
    }

    $inputEnd += $lengthChange;
}

# Starting from the specified '$pos', find the position of the next directive
# at the same nesting level that is part of the same #if...#endif
# construct. The optional argument indicates which directives we are
# interested in; the legal values are "else", "elif", "endif", or a
# regular-expression OR of two or more (e.g., "else|elif"). The default
# argument is "else|elif|endif".
#
# Returns 1 if match and 0 if no match.
# On return, $cppMatch[1] will be one-word matching directive and $cppMatchAll
# will be the entire matching directive (including the # prefix).
sub cppFindMatchingPPDirective($;$)
{
    my ($pos, $what) = @_;
    $what = "else|elif|endif" unless ($what);

    trace("cppFindMatchingPPDirective", "pos = %d, what = %s", $pos, $what);

    # Look for a #else, #elif, or #endif directive, handling any nested #if's
    # along the way.
    my $depth = 1;
    while (cppSearch(qr{^\h*\#\h*(\w+).*\n}m, $pos)) {
        $pos = $cppMatchEnd[0];
        my $ppDirective = $cppMatch[1];
        if (1 == $depth) {
            if ($ppDirective =~ /^($what)$/ ) {
                trace("cppFindMatchingPPDirective",
                      "Found match '%s' at %d", $ppDirective, $pos);
                return 1;                                              # RETURN
            }
            elsif ($ppDirective eq "endif") {
                trace("cppFindMatchingPPDirective", "No match");
                return 0;  # Reached enclosing #endif without finding match
            }
        }
        $depth++ if ($ppDirective =~ /^if/); # match #if, #ifdef, #ifndef
        --$depth if ($ppDirective eq "endif");
    }

    fatal("Unmatched #if:\n".displayPos($pos-1)) unless ($depth == 1);
    trace("cppFindMatchingPPDirective", "No match");
    return 0;
}

# TBD: THIS FUNCTION IS NOT CURRENTLY PRODUCING ACCURATE RESULTS.
# Return the input line number and column number at the specified '$pos'.  If
# called in a scalar context, return only the line number.  Line and column
# numbers are 1-based.  If the character at '$position' is a newline
# character, it represents the end of a line, not the start of a new line.
# Example:
#..
#  If '$input' is "abc\ndef\n", then:
#
#        character
#  $pos  at $pos    lineAndColumn($pos)
#  ----  ---------  ----------------
#   0       'a'       (1 1)
#   2       'c'       (1 3)
#   3       '\n'      (1 4)
#   4       'd'       (2 1)
#   8       EOF       (3 1)
#..
sub lineAndColumn($)
{
    my $pos = shift;

    my $fragment = substr($input, 0, $pos);

    # Remove all characters except newlines
    $fragment =~ s/[^\n]+//g;

    # Count how many newlines are in the fragment
    my $lineNum = length($fragment) + 1;

    # Count number of characters between the last newline and the current
    # position.
    my $colNum = 1;
    pos($input) = $pos;
    if ($input =~ m{([^\n]*)\G}g ) {
        $colNum = length($1) + 1;
    }

    return wantarray() ? ($lineNum, $colNum) : $lineNum;
}

# TBD: THIS FUNCTION IS NOT CURRENTLY PRODUCING ACCURATE RESULTS.
# Error-handling routine to print the line within '$input' at the specified
# '$pos' with a caret at under the column.
sub displayPos($)
{
    my $pos = shift;

    if ($pos == $inputEnd) {
        return "\n^\n";                                                # RETURN
    }

    my ($lineNum, $col) = lineAndColumn($pos);
    pos($input) = $pos;
    $input =~ m{[^\n]*\n}g;     # Move to end of line
    $input =~ m{([^\n]*\n)\G}g; # Get entire line
    my $output = $1;
    do {
        $output .= substr($spaces, 0, $col - 1);
        $col -= length($spaces);
    } while ($col > 1);
    $output .= "^\n";

    return $output;
}

# Usage: $depth = bracketDepth($initDepth, $inputLine, $brackets);
#
#   Returns the bracket nesting depth at the end of $inputLine given a
#   starting depth of $initDepth.  The $bracket argument is a string of 1 to
#   4 open-bracket types to consider.  Only bracket types '[', '{', '(', and
#   '<' are supported.  Their corresponding close-bracket types, ']', '}',
#   ')', and '>' are automatically matched.  Thus if $bracket is "[{(<", then
#   all bracket types are matched whereas if $bracket is '{', then only curly
#   braces are matched.  The behavior is undefined if either an open or
#   closing bracket is found within a quoted string or a C-style comment.  The
#   behavior is also undefined if an open bracket is matched with a different
#   closing bracket.  If $initDepth is undef and no brackets are found, then
#   returns undef.  The last is so that a sequence of strings with no brackets
#   (return undef) can be distinguished from a sequence of strings with
#   fully-matched brackets (return 0).
sub bracketDepth($$$) {
    my ($depth, $inputLine, $brackets) = @_;

    my ($openBrackets, $closeBrackets) = ("", "");
    for my $bracket (split //,$brackets) {
        if ($bracket eq '[') {
            $openBrackets .= '\\';
            $closeBrackets .= '\\';
        }
        $openBrackets .= $bracket;
        $closeBrackets .= $matchingBrackets{$bracket};
    }
    my $closeBracketsRe = qr/[$closeBrackets]/;

    my @parens = ($inputLine =~ /([$openBrackets$closeBrackets])/g);

    return $depth unless (@parens);                                    # RETURN

    $depth = $depth || 0; # Don't allow $depth to remain undef
    for my $paren (@parens) {
        if ($paren =~ $closeBracketsRe ) {
            --$depth;
        }
        else {
            ++$depth;
        }
    }

    return $depth;
}

# Find the specified '$brace' in '$input' starting at the specified
# '$pos', then return the position immediately after the matching end brace.
# Return '$pos' if the starting brace is not found.  The behavior is undefined
# if '$brace' is found but no matching brace is found.
sub findMatchingBrace($$)
{
    my ($brace, $pos) = @_;
    my $startPos = $pos;

    my $openBraces = '\\[({';
    my $closeBraces = '})\\]';
    if ($brace eq '<') {
        $openBraces .= '<';
        $closeBraces .= '>';
    }
    my $allBraces = $openBraces . $closeBraces;
    my $allBracesRe = qr/[$allBraces]/;

    my @matchingBraceStack = ();

    my $done = 0;
    while (! $done) {

        last unless (cppSearch($allBracesRe, $pos));

        my $bracePos   = $cppMatchStart[0];
        $pos           = $cppMatchEnd[0];
        my $foundBrace = substr($input,  $bracePos, 1);

        my $matchingBrace = $matchingBrackets{$foundBrace};

        # debug("*** Brace-matching status\n".
        #       "    foundBrace  = $foundBrace\n",
        #       "    bracePos    = $bracePos");

        if (defined($matchingBrace)) {
            # Found an open brace

            # If this is the first open brace, make sure it matches the
            # brace that was passed in.
            if (0 == @matchingBraceStack && $foundBrace ne $brace) {
                # Fail: No match.
                return $startPos;                                      # RETURN
            }

            # push matching brace onto the brace stack
            push @matchingBraceStack, $matchingBrace;
            # debug("    push matchingBraceStack = [@matchingBraceStack]");
        }
        else {
            # Found closing brace.  Pop matching brace off the stack.  If
            # top of stack is does not match, abort.  Note that '<' and
            # '>' might be used as greater-than and less-than symbols
            # instead of braces.  Thus, it is not an error to find a
            # non-matching '<' on the stack or a non-matching '>' in the
            # input line.

            # Pop any unmatched '<' off the stack
            while (@matchingBraceStack &&
                   $matchingBraceStack[-1] ne $foundBrace &&
                   $matchingBraceStack[-1] eq '>') {
                pop @matchingBraceStack;
                # debug("    pop matchingBraceStack = [@matchingBraceStack]");
            }

            # Pop the matching brace off the stack
            if (@matchingBraceStack &&
                $matchingBraceStack[-1] eq $foundBrace) {
                pop @matchingBraceStack;
                # debug("    pop matchingBraceStack = [@matchingBraceStack]");
            }
            elsif ($foundBrace eq '>') {
                # Ignore unmatched '>'.
                next;
            }
            else {
                fatal("Mismatched brace '$foundBrace'; ".
                      "expecting '$matchingBraceStack[-1]' at line ".
                      scalar(lineAndColumn($bracePos)).
                      "\n".displayPos($bracePos));
            }

            $done = (0 == @matchingBraceStack);
        }

    } # end while ! done

    return $pos;
}

###############################################################################
#                    LOGIC FOR TRANSFORMING CODE                              #
###############################################################################

# Return a unique generated name using the supplied prefix argument.
my $nextGenParam = 0;
sub genName($)
{
    return $_[0].$nextGenParam++;
}

# The name "@packTypes" is a bit of a misnomer. It is really a list of all of
# the kinds of things that can appear in a template parameter list: basically
# "class", "typename", and fundamental types. Common aliases for fundamental
# types such as 'size_t' are also included. Some work might be needed to
# expand template parameter matching to include any valid non-type parameters
# and any aliases for them.
my @packTypes = ("class", "typename", "bool", "short", "unsigned short",
                 "int", "unsigned", "unsigned int", "long", "unsigned long",
                 "std::size_t", "bsl::size_t", "size_t",
                 "std::ptrdiff_t", "bsl::ptrdiff_t", "ptrdiff_t");
my $packTypesStr = join("|", @packTypes);

# Given an '$input' string where the substring at '$pos' starts with:
#..
#  template <class T, class... XYZ, int... QRS>
#..
# , return a list of type/name pairs
# like the following:
#..
#  (
#    [ "class",    "T"   ],
#    [ "class...", "XYZ" ],
#    [ "int...",   "QRS" ]
#  )
#..
# The parameter pack type (e.g., "class" or "int") must be a term in the
# @packTypes list (above).  Each pack name (e.g., "XYZ" or "QRS") is optional
# and will be replaced by a generated name if absent.
sub getTemplateParams($)
{
    my $pos = $_[0];
    my @packs = ();
    my $searchEnd = $pos;

    while (cppSearch(qr/([<,]\s*)($packTypesStr)\s*(\.\.\.)?(?:\s*([[:word:]]+))?(\s*=\s*[^>,]*)?(\s*[>,])/, $pos))
    {
        my $packType = $cppMatch[2];
        $packType .= $cppMatch[3] if defined $cppMatch[3];
        my $packName = $cppMatch[4] || genName("__Param__");
        my $packDflt = $cppMatch[5] || "";
        push @packs, [ $packType,  $packName, $packDflt ];
        $pos = $cppMatchStart[6];  # Include closing delimiter in next search
        $searchEnd = $cppMatchEnd[0];
        last if ($cppMatch[6] =~ />/);
    }

    pos($input) = $searchEnd;

    if (getTraceLevel("getTemplateParams") > 0) {
        my $packStr = "[\n";
        for my $pack (@packs) {
            $packStr .= "  [ ".$pack->[0].", ".$pack->[1].", ".$pack->[2].
                " ]\n";
        }
        $packStr .= "]";
        trace("getTemplateParams", "packs = %s", $packStr);
    }

    return @packs;
}

# Return the substring specified by the range
# '[$templateBegin, $templateEnd)', except with comments stripped.
sub noopTemplateTransform($$$;$)
{
    my ($templateBegin, $templateHeadEnd, $templateEnd, $isVariadic) = @_;

    return stripComments(substr($input, $templateBegin,
                                $templateEnd - $templateBegin));
}

# Usage:
#     $workingBuffer = replaceAndFitOnLine($workingBuffer, $packStart,
#                                          $packLen, $replacement);
#
# Replaces [$packStart, $packEnd) with $replacement, re-indenting as necessary
# so that longest line in $replacement fits within $maxCols.  Modifies
# $workingBuffer.
sub replaceAndFitOnLine($$$$) {
    my ($workingBuffer, $packStart, $packLen, $replacement) = @_;
    my $packEnd = $packStart + $packLen;

    trace("replaceAndFitOnLine", "START workingBuffer = [%s]", $workingBuffer);

    # $prePack is the text on same line preceding the current pack.
    pos($workingBuffer) = $packStart;
    $workingBuffer =~ m/^(.*)\G/mg;
    my $prePack = $1;
    my $column = length($prePack);

    # $postPack is the text on the same line following the current
    # pack.  Truncate $postPack at the start of the next pack, if any.
    pos($workingBuffer) = $packEnd;
    $workingBuffer =~ m/\G(.*)/mg;
    my $postPack  = $1;
    $postPack =~ s/__PACK_[VT][0-9]+[RF]__.*$//;

    my $postLen = length($postPack);

    # Compute length of longest line of $replacement
    my $lastReplacementWidth = 0;
    my $maxReplacementWidth = 0;
    for my $line (split qr/\n\h*/, $replacement) {
        $lastReplacementWidth = length($line);
        $maxReplacementWidth = $lastReplacementWidth
            if ($lastReplacementWidth > $maxReplacementWidth);
    }

    # If $postPack is between 0 and 3 characters long, then leave enough
    # "slack" to fit $postPack on the same line as the current pack.
    # Otherwise, if $postPack starts with a comma, leave enough slack for a
    # single comma.
    my $slack = 0;
    if (0 <= $postLen && $postLen <= 3) {
        # Leave enough slack to fit entire $postPack on same line
        $slack = $postLen;
    }
    elsif ($postPack =~ m/^\h*,/) {
        # Leave enough slack to fit a comma
        $slack = 1;
    }

    # Adjust $maxReplacementWidth to take slack into account
    $maxReplacementWidth = $lastReplacementWidth + $slack
        if ($lastReplacementWidth + $slack > $maxReplacementWidth);

    # Compute indentation.  If possible without exceeding the line
    # length, indent to the starting column of the $replacement.
    # Otherwise, find the smallest indent that accommodates each term
    # of the pack expansion (plus slack).
    my $targetCol = $column;
    $targetCol = $maxColumn - $maxReplacementWidth
        if ($column + $maxReplacementWidth > $maxColumn);
    $targetCol = 0 if $targetCol < 0;

    my $indentation = substr($spaces, 0, $targetCol);

    if ($replacement && $targetCol < $column) {
        my $overage = $column - $targetCol;
        $prePack =~ /(\h*)$/;  # Match trailing whitespace
        my $spacesAtEndofPrepack = length($1);
        if ($overage <= $spacesAtEndofPrepack) {
            # Remove unneeded spaces so that we can start at $targetCol
            $packStart -= $overage;
        }
        else {
            # Start replacement on next line
            $replacement = "\n".$replacement;

            # Remove trailing whitespace before replacement
            $packStart -= $spacesAtEndofPrepack;
        }
    }

    # Insert indentation after every newline in $replacement
    $replacement =~ s/\n\h*/\n$indentation/g;

    if ($targetCol + $lastReplacementWidth + $postLen > $maxColumn) {
        # $postPack will not fit on the same line as the last line of the
        # replacement.  Append a newline so that it will fit on the next line.

        # Remove any leading commas from $postPack.  The comma
        # (if any) will be appended to the replacement.
        $postPack =~ s/^(\h*(,?)\h*)//;
        my $removedLen = length($1);
        my $comma = $2;
        $packEnd += $removedLen;

        if ($targetCol + $postLen > $maxColumn) {
            # Even at the same indentation as the previous line, it
            # still doesn't fit.  Reduce indentation as needed.
            $indentation = substr($spaces, 0, $maxColumn - $postLen);
        }

        $replacement =~ s/\s*$//;      # remove trailing spaces and then
        $replacement .= $comma . "\n"; # append new line
        $replacement .= $indentation;
    }

    $packLen = $packEnd - $packStart;
    if ($shroudedInput && $workingBuffer eq $shroudedInput) {
        cppSubstitute($packStart, $packLen, $replacement);
        trace("replaceAndFitOnLine", "RETURN SHROUDED = [%s]", $shroudedInput);
        return $shroudedInput;                                         # RETURN
    }
    else {
        substr($workingBuffer,
               $packStart, $packLen, $replacement);
        trace("replaceAndFitOnLine", "RETURN WORKING = [%s]", $workingBuffer);
        return $workingBuffer;                                         # RETURN
    }
}

# Replace uses of perfect forwarding within the specified '$input' with
# special macros and return the result: A template argument of type 'T&&' is
# replaced with 'BSLS_COMPILERFEATURES_FORWARD_REF(T)'.  An expression of the
# form 'bsl::forward<T>(expr)' is replaced with
# 'BSLS_COMPILERFEATURES_FORWARD(T, #expr)', where 'T' is a template type
# parameter.
sub replaceForwarding($$$;$)
{
    my ($templateBegin, $templateHeadEnd, $templateEnd, $isVariadic) = @_;

    my $buffer = stripComments(substr($input, $templateBegin,
                                      $templateEnd - $templateBegin));

    pushInput($buffer);
    trace("replaceForwarding", "Stripped input = [%s]", $buffer);

    my @typenames;
    my $pos = 0;
    while (cppSearch(qr/[<,]\s*(?:typename|class)
                        (?:\s*\.\.\.)?\s*([[:word:]]+)\s*[>,]/x, $pos)) {
        $pos = $cppMatchEnd[1];
        push @typenames, $cppMatch[1];
    }

    for my $typename (@typenames) {
        $pos = 0;
        while (cppSearch(qr/\b($typename\s*&&)((?:\h*\.\.\.)?\h*[[:word:]]+)?/,
                         $pos)) {
            # Obtain the argument name from the match found by cppSearch.
            my $argname = $cppMatch[2] || "";
            $argname =~ s/\s+/ /g;  # squash all whitespace to a single space

            my $replStart = $cppMatchStart[1];
            my $replEnd = $cppMatch[2] ? $cppMatchEnd[2] : $cppMatchEnd[1];

            replaceAndFitOnLine($shroudedInput,
                                $replStart, $replEnd - $replStart,
                                "BSLS_COMPILERFEATURES_FORWARD_REF($typename)".
                                $argname);

            die "No forward progress; endless loop" unless $pos < $replEnd;
            $pos = $replEnd;
        }

        $pos = 0;
        while (cppSearch(qr/\b(bsl|std|native_std)\s*::\s*
                            forward\s*<\s*$typename\s*>\s*\(/x,
                         $pos)) {
            replaceAndFitOnLine($shroudedInput,
                                $cppMatchStart[0],
                                $cppMatchEnd[0] - $cppMatchStart[0],
                                "BSLS_COMPILERFEATURES_FORWARD($typename, ");
            $pos = $cppMatchEnd[0];
        }
    }

    trace("replaceForwarding", "Result = [%s]", $input);

    $buffer = popInput();
    return $buffer;
}

# PACK MARKINGS
# -------------
#
# As C++ code is processed by this program, parameter packs are replaced by
# special markers of the form "__PACK_T#R__".  The '#' in the marker is a
# small non-negative integer (in decimal format) that "names" the parameter
# pack.  The 'T' in the marker indicates that the parameter pack represents a
# list of type names.  A 'V' in that position would indicate that the
# parameter pack represents a list of non-typenames, e.g., variable names,
# declarations, or expressions.  The 'R' in the marker indicates that the
# parameter in the pack is repeated in the pack expansion.  An 'F' in that
# position would also indicate that the parameter is repeated, but that the
# list of repetitions is filled out with default types or values.  Thus,
# "__PACK_V2F__" is the third parameter pack (counting from zero),
# represents non-typenames, and should be filled with default values.  A
# separate dictionary maps each parameter pack (by number) to a code snippet.
# In addition, there is an implicit mapping from "__PACKSIZE_#__" marker to
# the size of the parameter pack.

# Replace every parameter pack and pack expansion in '$buffer' with the string
# "__PACK_T#R__" or '__PACK_V#R__' (see "PACK MARKINGS," above), where '#' is
# a unique sequence number within the buffer.  Also replace every use of the
# pattern "sizeof... (X)" with "__PACKSIZE_#__" where '#' is an index into a
# hypothetical array of parameter packs.  Return a list of pack expansions
# where each expansion has the ellipsis removed and a "_@" appended to each
# identifier that should be repeated within the expansion.
#
# For example, given the input '$buffer':
#..
#  template <typename ...B, class... A>
#  void foo(C<B...> *c, const A&... a)
#  {
#      D<A...> d(forward<A>(a)...);
#      bar(sizeof... (A), c, &d);
#  }
#..
# This function transforms '$buffer' into:
#..
#  template <__PACK_T0R__, __PACK_T1R__>
#  void foo(C<__PACK_T2R__> *c, __PACK_V3R__)
#  {
#      D<__PACK_T4R__> d(__PACK_V5R__);
#      bar(__PACKSIZE_1__, c, &d);
#  }
#..
# And returns a pack expansion list:
#..
#  (
#    "typename B_@",
#    "class A_@",
#    "B_@",
#    "const A_@& a_@",
#    "A_@",
#    "forward<A_@>(a_@)"
#  )
#..
sub markPackExpansions()
{
    trace("markPackExpansions", "ORIGINAL = [%s]", $input);

    my %typeNames = ();
    my @packIdents;
    my @packExpansions;
    my $packNum = 0;

    # Mark packs in template headers: Find a pattern coming after a '<' or ','
    # delimiter, starting with integer type, the word "class", or the word
    # "typename" and ending with an ellipsis ('...') and an optional
    # identifier, and followed by a ',' or '>' delimiter.  If an identifier
    # follows the ellipsis, its name is saved in the @packIdents list.  Replace
    # the found pattern with a numbered __PACK_V#R_ string.
    while (cppSearch(qr/([<,]\s*)($packTypesStr)\s*\.\.\.(?:\s*([[:word:]]+))?(\s*[>,])/, 0)) {
        my $PACKR = "__PACK_V".$packNum."R__";

        my $packType = $cppMatch[2];
        my $separator = $cppMatch[4];
        my $paramPackName = $cppMatch[3] || genName("_Tp__");

        if ($packType =~ m/(class|typename)/) {
            $PACKR =~ s/__PACK_V/__PACK_T/;
            $typeNames{$paramPackName} = 1;
        }

        my $replacement = $cppMatch[1] . $PACKR . $separator;

        push @packIdents, $paramPackName;
        push @packExpansions, "$packType $paramPackName";

        substr($input, $cppMatchStart[0], $cppMatchEnd[0] - $cppMatchStart[0],
               $replacement);
        my $PACKSIZE = "__PACKSIZE_".$packNum."__";
        $input =~ s/\bsizeof\s*\.\.\.\s*\(\s*$paramPackName\s*\)/$PACKSIZE/g;
        setInput($input);  # TBD: find a more efficient way to do this

        $packNum = @packExpansions;
    }

    fatal("Expected only variadic templates") if (0 == $packNum);

    # Mark packs in template bodies: Find a pattern coming after a '(', '{',
    # '<', ',', ';', or ':' delimiter (but not '::'), ending with an ellipsis
    # ('...') and an optional identifier, and followed by a ';', ',', '>', '{,
    # '}', or ')' delimiter.  If an identifier follows the ellipsis, its name
    # is saved in the @packIdents list.  Replace the found pattern with a
    # numbered __PACK_V#R_ string.
    my $B = "({<,;:";  # Beginning delimiters
    my $E = ";,>{})";  # End delimiters
    while (cppSearch(qr/([$B]\s*)([^$B]+)\.\.\.(?:\s*([[:word:]]+))?(\s*[$E])/,
                     0))
    {
        trace2("markPackExpansions", "found pack = %s", $cppMatchAll);
        my $PACKR = "__PACK_V".$packNum."R__";

        my $FB = "\\".$cppMatch[1];  # Found beginning delimiter
        my $pattern = $cppMatch[2];
        $PACKR =~ s/__PACK_V/__PACK_T/ if (exists($typeNames{$pattern}));
        my $replacement = $cppMatch[1] . $PACKR . $cppMatch[4];
        my $packIdent="";
        if ($cppMatch[3]) {
            # Save identifier after the ellipsis and append it to the
            # pattern.
            $packIdent = $cppMatch[3];
            $pattern .= " ".$packIdent;
            push @packIdents, $packIdent;
        }
        # my $FE = $cppMatch[5];  # Found end delimiter

        substr($input, $cppMatchStart[0], $cppMatchEnd[0] - $cppMatchStart[0],
               $replacement);

        # Scan backwards until pattern is fully-balanced w.r.t. brackets.
        # Join sections that are connected by '::'.
        while (1) {
            if ($input =~ s/(::\s*)$PACKR/$PACKR/ ) {
                # Add leading '::' to pattern and loop.
                $pattern = $1.$pattern;

                # Now search for start of pattern again and loop
                $input =~ s/([$B]\s*)([^$B]+\s*)$PACKR/$1$PACKR/;
                $FB = "\\".$1;
                $pattern = $2.$pattern;
            }
            elsif (0 != bracketDepth(0, $pattern, "[{(<")) {
                # Brackets were not matched.
                # Add characters from punctuation to front of pattern and loop.
                $input =~ s/([$B]\s*)([^$B]+$FB\s*)$PACKR/$1$PACKR/;
                $FB = "\\".$1;
                $pattern = $2.$pattern;
            }
            else {
                last;
            }
        }

        my $PACKSIZE = "__PACKSIZE_".$packNum."__";
        $input =~ s/\bsizeof\s*\.\.\.\s*\(\s*$packIdent\s*\)/$PACKSIZE/g;
        setInput($input);  # TBD: find a more efficient way to do this

        push @packExpansions, $pattern;
        $packNum = @packExpansions;
    }

    for my $pattern (@packExpansions) {
        for my $ident (@packIdents) {
            $pattern =~ s/\b$ident\b/${ident}_\@/g;
        }
    }

    trace("markPackExpansion", "AFTER XFORM = [\n%s\n]", $input);
    trace("markPackExpansion", "EXPANSIONS =\n    \"%s",
          join("\"\n    \"", @packExpansions));

    return @packExpansions;
}

# Create multiple copies of '$buffer', replacing each '__PACK_V#R__' or
# '__PACK_T#R__' pattern with an expansion of the parameter packs in
# '@packExpansions' such that each copy has a longer expansion then the
# previous copy. The first copy has an expansion length of 0 and the last copy
# has an expansion length of '$maxArgs'.  The generated copies are returned as
# a list of strings. Thus, if $buffer is: ..  template <__PACK_T0R__> void
# f(__PACK_T1R__); ..  and '$maxArgs' is 2 and '@packExpansions is ("class
# T_@", "const T_@& v_@"), then this function will return the following list
# of three strings: ..  ( "void f();", "template <class T_1> void
# f(const T_1& v_1);", "template <class T_1, class T_2> void f(const T_1& v_1,
# const T_2& v_2;" ) ..
sub repeatPacks($$@)
{
    my ($buffer, $maxArgs, @packExpansions) = @_;

    # '@appliedPackExpansions' will hold an entry for each parameter pack.  As
    # the parameter packs are applied repeatedly, with a repetition count of
    # 0 through '$maxArgs', '@appliedPackExpansions' will accumulate the entire
    # applied expansion up to that point, growing longer with each
    # application.  Thus, if '$parameterPacks[$x]' is 'XYZ_@& abc_@', then
    # when '$repCount' is 2, '$appliedPackExpansions[$x]' will be 'XYZ_1&
    # abc_1, XYZ_2& abc_2'
    my @appliedPackExpansions;
    my $output;

    # If $maxArgs is 2 digits, then pad all argument counts to 2 digits or 2
    # characters (with leading space).
    my $digitPad = ($maxArgs > 9) ? "0" : "";
    my $spacePad = ($maxArgs > 9) ? " " : "";

    for (my $repCount = 0; $repCount <= $maxArgs; ++$repCount)
    {
        my $workingBuffer = $buffer;

        $workingBuffer = "#if $variadic_limit >= $repCount\n" . $workingBuffer;

        # Express $repCount as a decimal string of 2 characters if $maxArg > 9
        # and 1 character otherwise.  $repString is used for putting an
        # integer literal into the generated code; $repIdString is used for
        # putting the rep count as part of an identifier.
        my $repString   = (($repCount > 9) ? "" : $spacePad).$repCount;
        my $repIdString = (($repCount > 9) ? "" : $digitPad).$repCount;

        # For now, all packs must be the same length.  Replace __PACKSIZE_#__
        # with the expansion length, regardless of the pack to which it refers.
        $workingBuffer =~ s/__PACKSIZE_[0-9]+__/${repString}u/g;

        for (my $expandNum = 0; $expandNum < @packExpansions; ++$expandNum)
        {
            $workingBuffer =~ m/(.*)__PACK_([VT])$expandNum([RF])__(.*)/g or
                fatal("Can't find pack $expandNum in working buffer");
            my $packStart = $+[1];    # Start of pack
            my $packType  = $2;       # 'T' for type, 'V' for value.
            my $isFill    = ($3 eq 'F');
            my $packEnd   = $-[4];    # One past end of pack
            my $packLen   = $packEnd - $packStart;

            # For class specializations with fill-parameters, express the
            # number of fill parameters as a 2-character decimal string.
            my $fillCountStr = ((($maxArgs - $repCount) > 9) ? "" : $spacePad).
                ($maxArgs - $repCount);
            my $FILL = "BSLS_COMPILERFEATURES_FILL".$packType.
                "(".$fillCountStr.")";

            my $expansionTerm = $packExpansions[$expandNum];
            my $replacement = "";

            if ($repCount == 0) {
                # push @appliedPackExpansions, "";

                my $preDelim = "";  # optional comma or colon before pack
                pos($workingBuffer) = $packStart;
                $preDelim = $1 if ($workingBuffer =~ m/(\h*[,:]\s*)\G/g);

                my $postDelim = ""; # optional comma after pack
                pos($workingBuffer) = $packEnd;
                $postDelim = $1 if ($workingBuffer =~ m/\G(\s*,\s*)/g);

                unless ($isFill) {
                    if ($postDelim) {
                        # There is a comma after the pack and pack expansion
                        # is empty.  Remove comma after pack.
                        $packLen += length($postDelim);
                    }
                    elsif ($preDelim) {
                        # There is a comma or colon before the pack and no
                        # comma after the pack and the pack expansion is
                        # empty.  Remove comma or colon before the pack.
                        $packLen += length($preDelim);
                        $packStart = $packEnd - $packLen;
                    }
                }

                push @appliedPackExpansions, "";
            }
            else {
                # Replace '@' with expansion number to get new expansion term
                $expansionTerm =~ s/\@/$repIdString/g;
            }

            my $appliedPackExpansion = $appliedPackExpansions[$expandNum];
            if ($repCount > 0) {
                $appliedPackExpansion .= ",\n" if ($repCount > 1);
                $appliedPackExpansion .= $expansionTerm;
                $replacement = $appliedPackExpansion;
            }

            if ($isFill) {
                $replacement .= ",\n" if ($replacement);
                $replacement .= $FILL;
            }

            # substr($workingBuffer, $packStart, $packLen, $replacement);
            $workingBuffer = replaceAndFitOnLine($workingBuffer,
                                                 $packStart, $packLen,
                                                 $replacement);

            $appliedPackExpansions[$expandNum] = $appliedPackExpansion;
        } # end for $expandNum

        $workingBuffer .= "#endif  // $variadic_limit >= $repCount\n";

        $output .= $workingBuffer."\n";

    } # end for $repCount

    return $output;
}

sub transformVariadicFunction($$$;$)
{
    my ($templateBegin, $templateHeadEnd, $templateEnd, $isVariadic) = @_;

    my $buffer = stripComments(substr($input, $templateBegin,
                                      $templateEnd - $templateBegin));

    return $buffer unless ($isVariadic);                               # RETURN

    pushInput($buffer);
    my @packExpansions = markPackExpansions();

    # Find functions or variables that fit one of the following patterns:
    #..
    #  template <class... T>
    #  rettype classname<T...>::f( args )
    #..
    # or
    #..
    #  template <class... T>
    #    template <params>
    #  rettype classname<T...>::f( args )
    #..
    # or
    #..
    #  template <class...T>
    #  vartype classname<T...>::variable = initialization;
    #..
    # In other words, look for out-of-line definitions of member functions or
    # static member variables of variadic classes.  For such members, replace
    # the '__PACK_[TV]#R__' marker just before the '>::' with '__PACK_[TV]#F__'
    # indicating that the parameter expansion should include the nil
    # arguments that fill out the template argument list.

    my $pos = 0;
    while (cppSearch(qr/template\s*<[^{;]+__PACK_[TV][0-9]+(R)__\s*>\s*::/,
                     $pos))
    {
        substr($input, $cppMatchStart[1], 1) = 'F';
        $pos = $cppMatchEnd[0];
    }

    $buffer = $input;
    popInput();

    # Expand parameter packs
    $buffer = repeatPacks($buffer, $maxArgs, @packExpansions);

    # Remove empty "template <>" prefixes.  These are non-template functions.
    $buffer =~ s/\btemplate\s*<\s*>\s*//g;

    return $buffer;
}

sub transformVariadicClass($$$)
{
    my ($templateBegin, $templateHeadEnd, $templateEnd, $isVariadic) = @_;

    return noopTemplateTransform($templateBegin,
                                 $templateHeadEnd,
                                 $templateEnd) unless ($isVariadic);   # RETURN

    trace("transformVariadicClass", "TEMPLATE = [%s]",
          substr($input, $templateBegin, $templateEnd - $templateBegin));

    my @templateParams = getTemplateParams($templateBegin);

    cppSearch(qr/\G\s*(class|struct|union)\s*([[:word:]]+)\b(.)?/,
              $templateHeadEnd);
    my $classOrStruct    = $cppMatch[1];
    my $className        = $cppMatch[2];
    my $isSpecialization = (defined $cppMatch[3]) && $cppMatch[3] eq '<';
    my $isForwardDecl    = (defined $cppMatch[3]) && $cppMatch[3] eq ';';
    my $classHdrEnd      = $cppMatchEnd[2];

    my $buffer;
    if ($isSpecialization) {
        # Declaration is already a class template partial specialization.
        # Don't modify the declaration.
        $classHdrEnd = findMatchingBrace('<', $cppMatchStart[3])+1;

        $buffer = substr($input, $templateBegin,
                         $classHdrEnd - $templateBegin);
    }
    else {
        # Modify class declaration to look like a template specialization.
        #
        # Example:
        #   template <class X = int, class... Y> class C { ... };
        # becomes:
        #   template <class X, class... Y> class<X, Y...> C { ... };

        # First, generate template head, but exclude parameter defaults.
        $buffer    = "template <";
        my $indent = "          ";  # Indent enough for "template <"
        my $col = length($buffer);
        my $sep = "";
        my $sepSpace = "";
        for my $param (@templateParams) {
            my $paramStr = $param->[0].' '.$param->[1];
            if ($col + length($sep) + length($paramStr) > $maxColumn) {
                $sep =~ s/\s*$//;
                $buffer .= $sep."\n".$indent.$paramStr;
                $col = length($indent) + length($paramStr);
            }
            else {
                $buffer .= $sep.$paramStr;
                $col += length($sep) + length($paramStr);
            }
            $sep = ", ";
        }
        $buffer .= ">";

        # Then, add the rest of the class head.
        $buffer .= substr($input, $templateHeadEnd,
                          $classHdrEnd - $templateHeadEnd);

        # Now put it all of the parameters as if they were specialized.
        $sep = "<";
        for my $param (@templateParams) {
            $buffer .= $sep;
            $buffer .= $param->[1];
            $buffer .= "..." if ($param->[0] =~ m/\.\.\./);
            $sep = ", ";
        }
        $buffer .= ">";
    }

    trace2("transformVariadicClass", "specialization buffer=[%s]", $buffer);

    $buffer .= transformForwarding(substr($input, $classHdrEnd,
                                          $templateEnd - $classHdrEnd));

    pushInput($buffer);
    my @packExpansions = markPackExpansions();
    $buffer = $input;
    popInput();

    my $output = "";

    # Generate forward-reference for the primary template, with all of the
    # variadic parameters present but defaulted.  Suppress this primary
    # template if the class we are expanding is a partial specialization or
    # has already been forward-declared.
    unless ($isSpecialization || $classTemplateForwardDeclared{$className}) {
        $classTemplateForwardDeclared{$className} = 1;
        $output .= "template <";
        my $indent      = "          ";
        my $indentComma = "        , ";
        my $sep = "";
        for my $param (@templateParams) {
            my ($paramType, $paramName, $paramDflt) = @$param;
            if ($paramType =~ s/\.\.\.//) {
                my $paramNil = ($paramType =~ m/(class|struct|union)/ ?
                                "BSLS_COMPILERFEATURES_NILT" :
                                "BSLS_COMPILERFEATURES_NILV");
                for (my $i = 0; $i < $maxArgs; ++$i) {
                    $output .= "\n#if $variadic_limit >= $i\n";
                    $sep =~ s{^,\n *$}{$indentComma};
                    $output .= $sep;
                    $sep = $indentComma;
                    $output .= sprintf("%s %s_%d = %s", $paramType,
                                       $paramName, $i, $paramNil);
                    $output .= "\n#endif  // $variadic_limit >= $i\n";
                }
                $output .= $sep . "$paramType = $paramNil";
            }
            else {
                $output .= $sep;
                $sep = ",\n".$indent;
                $output .= $paramType." ".$paramName.$paramDflt;
            }
        }
        $output .= ">\n".$classOrStruct." ".$className.";\n\n";
    }

    if (! $isForwardDecl) {
        $output .= repeatPacks($buffer, $maxArgs, @packExpansions);
    }
    trace("transformVariadicClass", "OUTPUT = [%s]", $output);
    return $output;
}

# Transforms the specified '$buffer', calling the specified
# '$transformFunction', '$transformClass', '$transformVariadicFunction' or
# '$transformVariadicClass' on each template found.  Return the transformed
# results.
sub transformTemplates($$$)
{
    my ($buffer, $transformFunction, $transformClass) = @_;

    trace("transformTemplates", "buffer = [%s]", $buffer);

    # Line and column at start of this segment
    my ($lineNum, $col) = lineAndColumn(pos($input));
    my $isClass = 0;

    pushInput($_[0]);
    my $output = "";

    my $pos = 0;
    while ($pos < $inputEnd)
    {
        # Find start of a template.
        last unless cppSearch(qr/\h*\btemplate\s*</, $pos);
        my $templateBegin = $cppMatchStart[0];

        # Copy everything before the template to output.
        $output .= stripComments(substr($input, $pos, $templateBegin - $pos));

        # Find end of template parameter list
        $pos = findMatchingBrace('<', $templateBegin);

        while (cppSearch(qr/\G\s*template\s*</, $pos)) {
            # Template member of a template class, defined outside of the
            # class.
            $pos = findMatchingBrace('<', $pos);
        }

        my $templateHeadEnd = $pos;

        # For debugging only
        my $templateHeadLine = lineAndColumn($pos);
        $templateHeadLine += $lineNum;
        trace2("transformTemplates",
               "Template header ends at line %d", $templateHeadLine);

        # If the next word is "class", "struct", or "union", then this is a
        # class template.
        $isClass = cppSearch(qr/\G\s*(?:class|struct|union)\s*[[:word:]]+\b/,
                             $pos);

        # Saw start of template, now look for end of template: either a
        # semicolon or a matched set of curly braces, whichever comes first.
        cppSearch(qr/[{;]/, $pos) or fatal("Cannot find end of template");
        my $templateEnd = $cppMatchEnd[0];
        if ($cppMatchAll eq '{') {
            $templateEnd = findMatchingBrace('{', $templateEnd - 1);
            if ($isClass) {
                # Class template must be terminated by a semicolon after the
                # close curly brace.
                cppSearch(qr/;/, $templateEnd) or fatal("Missing semicolon");
                $templateEnd = $cppMatchEnd[0];
            }
        }

        # Include trailing end-of-line in template definition
        if (cppSearch(qr/\G\h*\n/, $templateEnd)) {
            $templateEnd = $cppMatchEnd[0];
        }

        # Check within the template header for a variadic parameter.
        my $isVariadic = cppSearch(qr/\b($packTypesStr)\s*\.\.\./,
                                   $templateBegin, $templateHeadEnd);

        if ($isClass) {
            $output .= &$transformClass($templateBegin,
                                        $templateHeadEnd,
                                        $templateEnd,
                                        $isVariadic);
        }
        else {
            $output .= &$transformFunction($templateBegin,
                                           $templateHeadEnd,
                                           $templateEnd,
                                           $isVariadic);
        }

        $pos = $templateEnd;
    }

    $output .= stripComments(substr($input, $pos));

    popInput();
    trace("transformTemplates", "output = [%s]", $output);
    return $output;
}

# Transform all uses of perfect forwarding within top-level function templates
# in the specified input buffer into C++03-compatible code.
sub transformForwarding($)
{
    return transformTemplates($_[0], \&replaceForwarding,
                              \&noopTemplateTransform);
}

# Transform all top-level variadic templates in the specified input buffer
# into C++03-compatible code by converting them into repeated copies with
# different numbers of parameters.
sub transformVariadics($)
{
    return transformTemplates($_[0], \&transformVariadicFunction,
                              \&transformVariadicClass);
}

###############################################################################
# Simulation region management
###############################################################################

# Extract script arguments from a preprocessor directive.  Looks for comments
# with the pattern: '$var-args=n' and/or '$local-var-args=m' and returns
# (n, m).  The values of 'n' and/or 'm' will be 'undef' if the '$var-args' or
# '$local-var-args' argument, respectively, is absent.
#
# Return two-element list ($localMaxArgs, $argsComment), where $localMaxArgs
# is the arguement to $local-var-args, or undef, and $argsComment is the
# entire comment rewritten in canonical form.
#
# Usage:
#   getArgsFromPPLine($ppLine)
#
sub getArgsFromPPLine($)
{
    my ($ppLine) = @_;
    my ($newMaxArgs, $localMaxArgs) = (0, 0);

    # Look for // $var-args=n
    if ($ppLine =~ m{/[/*].*\$var-args=([[:digit:]]+)}) {
        $newMaxArgs = $1;
    }

    # Look for // $local-var-args=n
    if ($ppLine =~ m{/[/*].*\$local-var-args=([[:digit:]]+)}) {
        $localMaxArgs = $1;
    }

    my $argsComment = "";
    if ($localMaxArgs) {
        $argsComment .= " \$local-var-args=$localMaxArgs";
    }

    # $maxArgsOpt overrides $newMaxArgs if both are specified.
    $maxArgs = $maxArgsOpt || $newMaxArgs || $maxArgs;
    if ($newMaxArgs || $maxArgs != $fileMaxArgs) {
        # Add $var-args comment if explicitly specified or if $maxArgs
        # differs from default.
        $argsComment .= " \$var-args=$maxArgs";
        $fileMaxArgs = $maxArgs;
    }
    $argsComment = " //".$argsComment if ($argsComment);

    return ($localMaxArgs, $argsComment);
}

my $simCpp11Macro = "BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES";

# Find a C++11 simulation #if directive matching one of these patterns:
#   #if BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
#   #ifdef BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
#   #if defined(BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES)
#   #if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
#   #ifndef BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
#   #if !defined(BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES)
#
# Also parses any comment at the end of the directive containing the option
# strings '$var-args=n' and/or '$local-var-args=m', setting global variables
# as appropriate.
#
# Returns:
#  - "ifdef" if the directive matches one of the first three patterns,
#  - "ifndef" if the directive matches one of the last three patterns,
#  - an empty string if the directive is not found
#
# On return $cppMatch[0], $cppMatchStart[0], and $cppMatchEnd[0] will contain
# the contents and bounds of the matched directive.
sub findSimCpp11Directive($)
{
    my ($pos) = @_;

    my $searchStr = qr{^\h*\#\h*(if\h*(!)?|ifdef|ifndef)
                       \h*(defined)?\(?
                       \h*\(?$simCpp11Macro\b.*\n}mx;

    if (cppSearch($searchStr, $pos)) {
        return ($cppMatch[1] eq "ifndef" or (defined $cppMatch[2]
                                             and $cppMatch[2] eq '!')) ?
            "ifndef" : "ifdef";                                        # RETURN
    }
    else {
        return "";                                                     # RETURN
    }
}

# Search the current input to find the following construct:
#
#   #if BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
#   # include <filename_cpp03.ext>
#   #else
#      // C++11 code with SIMULATE_CPP11_FEATURES regions in it
#   #endif
#
# Return a list of five integers:
#  0. The START of the #if directive
#  1. The START of the #include directive
#  2. The END of the #else directive
#  3. The START of the #endif directive matching the #else
#  4. The END of the #endif directive matching the #else
#
# Return an empty list if the pattern is not found
# Fatal error if the #include is found but one of the other parts is missing.
# Fatal error if the #include is not inside the first #if matching the pattern.
sub findCpp03RegionMarkers()
{
    # See if #include even exists
    return () unless
        cppSearch(qr{^\h*\#\h*include\h*[<"].*_cpp03(\.[^">]*)?[">]}m);
                                                                       # RETURN

    my $includeStart     = $cppMatchStart[0];
    my $includeEnd       = $cppMatchEnd[0];
    my $includeDirective = $cppMatch[0];

    trace("findCpp03RegionMarkers", "Found #include at %d\n", $includeStart);

    my $error = "Not within '#if $simCpp11Macro':\n".$includeDirective;

    # Check that the #include is within the first SIMULATE_CPP11 #ifdef.
    # There should be a sequence of #ifdef, #include, #else directives.
    findSimCpp11Directive(0) eq "ifdef" or fatal($error);
    my $ifStart = $cppMatchStart[0];

    (cppFindMatchingPPDirective($cppMatchEnd[0], "include") and
     $cppMatchStart[0] == $includeStart) or fatal($error);

    (cppFindMatchingPPDirective($cppMatchEnd[0], "else") and
     $cppMatchStart[0] > $includeStart) or fatal($error);
    my $elseEnd = $cppMatchEnd[0];

    # Now find the final matching endif
    cppFindMatchingPPDirective($cppMatchEnd[0], "endif") or
        fatal("Cannot find #endif after\n  %s", $includeDirective);
    my $endifStart = $cppMatchStart[0];
    my $endifEnd = $cppMatchEnd[0];

    return ($ifStart, $includeStart, $elseEnd, $endifStart, $endifEnd);
}

# Transform the '$initialData' from annotated C++11 into C++03.  If the global
# '$inplace' flag is false, then 'transformFile' is invoked twice, once to
# update the file that will be compiled (the "main" file) and again to
# generate the C++03 expansion (the "expansion" file), where the main file
# #includes the expansion file.  The '$genMaster' flag is set when generating
# the latter file; it should always be true if '$inplace' is true.  Returns
# output of transformation.
sub transformFile($$)
{
    my ($initialData, $genMaster) = @_;
    my $genExpansion = $inplace || !$genMaster;
    setInput($initialData);

    trace("transformFile", "Inputlen = %d, masterGen = %d, expansionGen = %d",
          $inputEnd, $genMaster, $genExpansion);

    my $generatedCodeBegin = "// {{{ BEGIN GENERATED CODE";
    $generatedCodeBegin .=
        "\n// The following section is automatically generated.".
            "  **DO NOT EDIT**"
        if ($genMaster);

    my $generatedCodeEnd = "// }}} END GENERATED CODE";

    my $output = "";
    my $pos = 0;

    my $simVariadicsMacro ="BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES";

    my $startVerbatim = $pos;

    # Iterate over regions delimited by simulation markers.
    # Each region gets a unique name by advancing through the alphabet.
    my $regionCount = 0;
    while (my $ifType = findSimCpp11Directive($pos))
    {
        $pos = $cppMatchEnd[0];

        next if ($ifType ne "ifndef");

        $variadic_limit = $variadic_limit_base . "_" .
            chr(ord('A') + $regionCount++);

        # Output code before the #if
        my $endVerbetim = $cppMatchStart[0];
        $output .= substr($input, $startVerbatim,
                          $endVerbetim - $startVerbatim);

        my $startCpp11Segment = $pos;  # start C++11 code segment

        my ($localMaxArgs, $argsComment) = getArgsFromPPLine($cppMatch[0]);

        # Now look for the matching #else, #elif, or #endif, handling any
        # nested #if's along the way.
        cppFindMatchingPPDirective($pos) or
            fatal("Unmatched #if:\n".displayPos($endVerbetim));
        my $ppDirective = $cppMatch[1];
        my $endCpp11Segment = $cppMatchStart[0];
        $pos = $cppMatchEnd[0];

        if ($ppDirective ne "endif") {
            # Consume and discard input until matching '#endif'.  $depth == 1
            # here.
            cppFindMatchingPPDirective($pos, "endif");
            $pos = $cppMatchEnd[0];
        }

        pos($input) = $pos;
        $startVerbatim = $pos;

        my $cpp11Segment = substr($input, $startCpp11Segment,
                                  $endCpp11Segment - $startCpp11Segment);

        my $withinIf = 0;  # True if output is within an #if construct
        if ($genMaster) {
            # Output canonical form of #if
            $output .= "#if !".$simCpp11Macro.$argsComment."\n";
            $withinIf = 1;
            $output .= $cpp11Segment;
        }

        if ($clean) {
            # Clean the generated code: produce an error in C++03 mode.
            $output .= "#else\n";
            $output .= $generatedCodeBegin."\n";
            $output .= "#   error sim_cpp11_features.pl has not been run\n";
            $output .= $generatedCodeEnd."\n";
            $output .= "#endif\n";
            $withinIf = 0;
        }
        elsif ($genExpansion) {
            # Temporarily change $maxArgs
            $maxArgs = $localMaxArgs || $maxArgs;

            # Apply the forwarding workaround to the extracted segment.
            my $forwardingWorkaround = transformForwarding($cpp11Segment);
            chomp $forwardingWorkaround;

            # Apply the variadic template simulation on top of the forwarding
            # workaround.
            my $variadicSimulation = transformVariadics($forwardingWorkaround);
            chomp $variadicSimulation;

            # restore $maxArgs
            $maxArgs = $fileMaxArgs;

            # If the variadic template simulation is identical to the
            # forwarding workaround alone, then there were no variadics in the
            # segment.  Output the variadics simulation only if these strings
            # are different.
            my $genVariadics = ($variadicSimulation ne $forwardingWorkaround);
            if ($genVariadics) {
                $output .= ($withinIf ? "#elif" : "#if");
                $output .= " $simVariadicsMacro\n";
                $withinIf = 1;

                $output .= <<EOT;
$generatedCodeBegin
// Command line: $commandLine
#ifndef $variadic_limit_base
#define $variadic_limit_base $maxArgs
#endif
#ifndef $variadic_limit
#define $variadic_limit $variadic_limit_base
#endif
$variadicSimulation
EOT
            }

            $output .= "#else\n" if ($withinIf);
            $output .= $generatedCodeBegin."\n" unless ($genVariadics);
            $output .= <<EOT;
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
$forwardingWorkaround
$generatedCodeEnd
EOT
        }
        $output .= "#endif\n" if ($withinIf);
    } # End while each region

    # If there were no expansion regions found, then return an empty string.
    return "" if (0 == $regionCount);                                  # RETURN

    # Output remaining part of output file
    $output .= substr($input, $startVerbatim, $inputEnd - $startVerbatim);
    return $output;
}

###############################################################################
#                         GENERATED CODE SNIPPETS                             #
###############################################################################

my $year = (localtime)[5] + 1900;

my $copyright = <<EOT;
// ----------------------------------------------------------------------------
// Copyright $year Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
EOT
chomp $copyright;  # No trailing newlines on substitution elements

my $cpp03HeaderPrefix = <<EOT;
// <out>                                                              -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_<COMPONENT>_CPP03
#define INCLUDED_<COMPONENT>_CPP03

//\@PURPOSE: Provide C++03 implementation for <in>
//
//\@CLASSES: See <in> for list of classes
//
//\@SEE_ALSO: <component>
//
//\@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// <timestampComment>
// Command line: <commandLine>

#ifdef COMPILING_<CPP11_SOURCEFILE>

EOT

my $cpp03HeaderSuffix = <<EOT;

#else // if ! defined(DEFINED_<COMPONENT>_H)
# error Not valid except when included from <component>.h
#endif // ! defined(COMPILING_<CPP11_SOURCEFILE>)

#endif // ! defined(INCLUDED_<COMPONENT>_CPP03)

<copyright>
EOT

my $cpp03CppCodePrefix = <<EOT;
// <out>                                                              -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

// <timestampComment>
// Command line: <commandLine>

#define INCLUDED_<COMPONENT>_CPP03  // Disable inclusion
#include <<component>_cpp03.h>      // Pro-forma #include

// Empty file except when compiling <component>.cpp
#ifdef COMPILING_<CPP11_SOURCEFILE>

EOT

my $cpp03CppCodeSuffix = <<EOT;

#endif // defined(COMPILING_<CPP11_SOURCEFILE>)

<copyright>
EOT

my $cpp03TestDriverPrefix = <<EOT;
// <out>                                                              -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

//=============================================================================
//                             TEST PLAN
//-----------------------------------------------------------------------------
// This component is the C++03 translation of a C++11 component, generated by
// the 'sim_cpp11_features.pl' program.  If the original test driver contains
// any specially delimited regions of C++11 code, then this generated file
// contains the C++03 equivalent, i.e., with variadic templates expanded and
// rvalue-references replaced by 'bslmf::MovableRef' objects.  The test driver
// code in this file is designed to be '#include'd into the original test
// driver when compiling with a C++03 compiler.  If there are no specially
// delimited regions of C++11 code, then this test driver is a minimal 'main'
// program that tests nothing and is not '#include'd in the original.
//
// <timestampComment>
// Command line: <commandLine>

// Expanded test driver only when compiling <component>.cpp
#ifdef COMPILING_<CPP11_SOURCEFILE>

EOT

my $cpp03TestDriverSuffix = <<EOT;

#else // if ! defined(COMPILING_<CPP11_SOURCEFILE>)

// Trivial program when not compiling <component>.t.cpp
int main() {
    return -1;
}

#endif // defined(COMPILING_<CPP11_SOURCEFILE>)

<copyright>
EOT

my $masterPrefix = <<EOT;
#if $simCpp11Macro
// Include version that can be compiled with C++03
// <timestampComment>
// Command line: <commandLine>
# define COMPILING_<CPP11_SOURCEFILE>
# include <<cpp03>>
# undef COMPILING_<CPP11_SOURCEFILE>
#else

EOT

my $masterSuffix = <<EOT;

#endif // End C++11 code
EOT

# Mapping of extensions to prefix and suffix text, in descending order of the
# length of the extensions.
my @extToBoilerplateMap = (
    [ qr{_cpp03\.[0-9]+\.t\.cpp$}
                            , $cpp03TestDriverPrefix, $cpp03TestDriverSuffix ],
    [ qr{_cpp03\.t\.cpp$}   , $cpp03TestDriverPrefix, $cpp03TestDriverSuffix ],
    [ qr{_cpp03\.cpp$}      , $cpp03CppCodePrefix   , $cpp03CppCodeSuffix    ],
    [ qr{_cpp03\.h$}        , $cpp03HeaderPrefix    , $cpp03HeaderSuffix     ],
    [ qr{_cpp03$}           , $cpp03HeaderPrefix    , $cpp03HeaderSuffix     ],
    [ qr{}                  , $masterPrefix,        , $masterSuffix          ]
    );

###############################################################################
#                            MAIN LOGIC                                       #
###############################################################################

# Split the $fileData string into three segments:
#   Prologue: Segment of code before the beginning of simulation directive
#   Unexpanded Code: Segment of code containing C++11 code to be expanded
#   Epilogue: Segment of code after any simulation directive
#
# Additionally, returns a fourth value, that is Boolean true if the Prologue
# contains '#include <bsls_compilerfeatures.h>', which is needed to correctly
# interpret the simulation macros.
#
# Concatenating the three segments does NOT necessarily produce the original
# input string; conditional directives to #include an external expansion file
# are omitted.  If no such directive are found, the three segments are
# computed such that such the conditional #include would occur between the
# prologue and the unexpanded code and the corresponding #endif would occur
# between the unexpanded code and the epilogue.
#
# Returns a list containing the three segments listed above.
sub segmentFiledata($) {
    my ($fileData) = @_;

    my $includesBslCompilerFeatures = 0;

    pushInput($fileData);
    my ($ifStart, $includeStart, $elseEnd, $endifStart, $endifEnd) =
        findCpp03RegionMarkers();

    if ($ifStart) {
        # Found Cpp03 region markers.  Assume
        # '#include <bsls_compilerfeatures.h>' exists in the prologue.
        $includesBslCompilerFeatures = 1;
    }
    else {
        # Find the end of the last #include directive
        my $lastInclude = 0;
        while (cppSearch(qr{^\h*\#\h*include\h*[<"](.*)[">].*$}m,
                         $lastInclude)) {
            $includesBslCompilerFeatures = 1
                if ($cppMatch[1] eq "bsls_compilerfeatures.h");

            # Set $lastInclude to position (after the newline) following the
            # latest #include directive.
            $lastInclude = $cppMatchEnd[0] + 1;

            # Special case: This is an atomic pattern:
            #   #include <bsls_ident.h>
            #   BSLS_IDENT("$Id$ $CSID$")
            if ($cppMatch[1] eq "bsls_ident.h" and
                cppSearch(qr{^\h*BSLS_IDENT(.*).*$}m, $lastInclude)) {
                $lastInclude = $cppMatchEnd[0] + 1;
            }
        }

        $ifStart = $elseEnd = $lastInclude;
        $endifStart = $endifEnd = $inputEnd;

        # Find first non-whitespace, non-comment character after #include.
        my $firstRealCode = $inputEnd;
        if (cppSearch(qr/\S/, $lastInclude)) {
            $firstRealCode = $cppMatchStart[0];
        }

        # Find the #endif (if any) enclosing the last #include
        if (cppFindMatchingPPDirective($lastInclude, "endif")) {
            if ($cppMatchStart[0] > $firstRealCode) {
                $endifStart = $endifEnd = $cppMatchStart[0];
            }
            else {
                # No real code between #include and #endif, assume that the
                # #endif is part of this construct:
                #
                #   #ifndef INCLUDED_FILE
                #   #include <file>    // Optional comment
                #   #endif

                # Move insertion point to after #endif
                $ifStart = $elseEnd = $cppMatchEnd[0];

                # Search again for the #endif we actually care about, if any.
                if (cppFindMatchingPPDirective($elseEnd, "endif")) {
                    $endifStart = $endifEnd = $cppMatchStart[0];
                }
            }
        }

        if ($endifStart == $inputEnd) {
            # Move insertion position of '#endif' to be before any closing
            # comments and whitespace. Find a string of "whitespace"
            # characters starting with a newline at the end of the file.  Note
            # that "whitespace" in 'cppSearch' includes anything in a comment.
            # To avoid excessive processing, we assume no more than 1000
            # characters of trailing comment.
            my $startSearch = $inputEnd > 1000 ? $inputEnd - 1000 : 0;
            if (cppSearch(qr/\n\s*$/, $startSearch)) {
                $endifStart = $endifEnd = $cppMatchStart[0] + 1;
            }
        }
    }

    popInput();

    trace("segmentFiledata", "ifStart = %d, elseEnd = %d, endifStart = %d",
          $ifStart, $elseEnd, $endifStart);

    my $prologue = substr($fileData, 0, $ifStart);
    my $unexpandedCode = substr($fileData, $elseEnd, $endifStart - $elseEnd);
    my $epilogue = substr($fileData, $endifEnd);

    if ($unexpandedCode) {
        # Adjust newlines around the segments
        $prologue       =~ s{\n*$}{\n\n}; # Exactly two newlines at end
        $unexpandedCode =~ s{^\n*}{};     # No newlines at beginning
        $unexpandedCode =~ s{\n*$}{\n};   # Exactly one newline at end
        $epilogue       =~ s{^\n*}{\n};   # Exactly one newline at beginning
    }

    # Remove newlines from otherwise-empty prologue or epilogue
    $prologue = "" if ($prologue eq "\n\n");
    $epilogue = "" if ($epilogue eq "\n");

    trace("segmentFiledata",
          "prologue size = %d, code size = %d, epilog size = %d",
          length($prologue), length($unexpandedCode), length($epilogue));

    return ($prologue, $unexpandedCode, $epilogue,$includesBslCompilerFeatures);
}

# Given a filename, return the file extension, prefix boilerplate, and suffix
# boilerplate text for generating that file.
sub filenameToBoilerplate($) {
    my ($outputFilename) = @_;
    $outputFilename = basename($outputFilename);

    trace("filenameToBoilerplate", "outputFilename = %s", $outputFilename);

    my $component = $outputFilename;
    $component =~ s/(_cpp03)?(\..*)?$//;   # Remove _cpp03 and extension
    my $ext = $2 || "";
    $component =~ s/[^A-Za-z0-9_]/_/g;     # Replace non-identifier chars

    # Capitalized filename suitable for use as a macro name
    my $OUT = uc($outputFilename);
    $OUT =~ s/[^A-Za-z0-9_]/_/g;     # Replace non-identifier chars

    my $CPP11_SOURCEFILE = uc($component).uc($ext);
    $CPP11_SOURCEFILE =~ s/[^A-Za-z0-9_]/_/g;    # Replace non-identifier chars

    # Number of spaces to eat in header line
    my $s = length($outputFilename) - length("<out>");
    $s = 0 if ($s < 0);

    # Substitutions within prefix and suffix strings
    my %substitutions = (
        qr/<in>/                          => $component.$ext,
        qr/<out> {$s}(?= *\Q-*-C++-*-\E)/ => $outputFilename,  # header
        qr/<OUT>/                         => $OUT,
        qr/<ext>/                         => $ext,
        qr/<cpp03>/                       => $component."_cpp03".$ext,
        qr/<CPP11_SOURCEFILE>/            => $CPP11_SOURCEFILE,
        qr/<component>/                   => $component,
        qr/<COMPONENT>/                   => uc($component),
        qr/<commandLine>/                 => $commandLine,
        qr/<timestampComment>/            => $timestampComment,
        qr/<copyright>/                   => $copyright
        );

    # Find entry in boilerplate map that matches the tail of the filename.
    foreach my $entry (@extToBoilerplateMap) {
        my ($tail, $boilerplateBegin, $boilerplateEnd) = @$entry;
        trace("filenameToBoilerplate", "ext = %s, filename = %s",
              $tail, $outputFilename);
        next unless ($tail eq "" or $outputFilename=~m{$tail});

        # Match found. Apply each substitution to the beginning and end of the
        # boilerplate text.
        while (my ($match, $replacement) = each %substitutions) {
            $boilerplateBegin =~ s/$match/$replacement/g;
            $boilerplateEnd =~ s/$match/$replacement/g;
        }

        return ($boilerplateBegin, $boilerplateEnd);                   # RETURN
    }

    die "Shouldn't get here";
}

# Create a backup of the $outputFilename and write $output to it.  Optionally
# specify permissions (octal Unix-style) for the new file.
sub writeOutput($$;$)
{
    my ($output, $outputFilename, $permissions) = @_;
    $permissions = 0666 unless ($permissions);

    trace("writeOutput", "Writing %d to %s", length($output), $outputFilename);

    fatal("--verify-no-change error: Would modify $outputFilename")
        if ($verifyNoChange);

    if ($outputFilename eq "-") {
        print $output;
    }
    else {
        # Save a backup of the output file
        rename $outputFilename, $outputFilename . ".bak";

        # Open file, print, and close file
        sysopen OUTPUT, $outputFilename, O_WRONLY | O_CREAT, $permissions or
            fatal("Cannot open $outputFilename for writing\n");
        print OUTPUT $output;
        close OUTPUT;
    }
}

sub writeMaster($$$$) {
    my ($inputFilename, $outputFilename, $originalFileData, $output) = @_;

    trace("writeMaster", "outputName = %s, outputLen = %d",
          $outputFilename, length($output));

    if ($output ne $originalFileData ||
        (! $selfTest && $outputFilename ne $inputFilename) ||
        $outputFilename eq "-")
    {
        writeOutput($output, $outputFilename);

        if ($selfTest) {
            # Dump a copy of the test data to a file.
            open INPUTDATA, "> TEST";
            print INPUTDATA $originalFileData;
            close INPUTDATA;

            # Dump test diff if new main doesn't match old main
            system("diff -c TEST $outputFilename");
        }
    }
    else {
        trace("writeMaster", "Master is unchanged. No file written.");
    }
}

sub writeExpansion($$)
{
    my ($outputFilename, $output) = @_;

    trace("writeExpansion", "outputName = %s, outputLen = %d",
          $outputFilename, length($output));

    if (open OLD_FILE, "<$outputFilename") {
        # Read previous contents of output file
        local $/ = undef; # Slurp mode
        my $originalFileData = <OLD_FILE>;
        close OLD_FILE;

        # Replace old timestamp with new timestamp.  If the original
        # string and the new output string differ only in their
        # timestamps, they will compare equal after this replacement.
        $originalFileData =~ s/$timestampPrefix.*$/$timestampComment/mg;

        # 2021-01-03: replace old copyright with new.  This can also cause
        # a spurious difference.
        if ($output=~m{(^// Copyright \d+)}m) {
            my $new_copyright = $1;
            $originalFileData =~ s{^// Copyright \d+}{$new_copyright}m;
        }

        # Don't modify output file if it's identical to previous version
        if ($output eq $originalFileData) {
            trace("writeExpansion",
                  "Generated file is unchanged. No file written.");
            return;                                                    # RETURN
        }
        else {
            trace("writeExpansion",
                  "Generated file is changed. File written.");
        }
    }

    # Create read-only file with generated output.
    writeOutput($output, $outputFilename, 0444);
}

# Process the specified input filename to the specified output filename.
sub processFile($$)
{
    my ($inputFilename, $outputFilename) = @_;

    trace("processFile", "Inputfile = %s, Outputfile = %s",
          $inputFilename, $outputFilename);

    # Reset important globals
    $fileMaxArgs = $defaultMaxArgs;
    $maxArgs = $maxArgsOpt || $fileMaxArgs;

    $variadic_limit_base = $inputFilename;
    $variadic_limit_base =~ s{.*/}{};
    $variadic_limit_base =~ s{[.].*}{};
    $variadic_limit_base = uc($variadic_limit_base) . "_VARIADIC_LIMIT";

    if ($selfTest) {
        open INPUT, "<& DATA" or
            fatal("Cannot re-open DATA for reading\n");
    }
    else {
        open INPUT, "<$inputFilename" or
            fatal("Cannot open $inputFilename for reading\n");
    }

    # Read contents of INPUT file
    my $fileData;
    {
        local $/ = undef; # Slurp mode
        $fileData = <INPUT>;
        $fileData =~ s/\r//g;  # Normalize newlines
    }
    close INPUT;

    # Replace old timestamp with new timestamp.  If the original
    # string and the post-processed string differ only in their
    # timestamps, they will compare equal after this replacement.
    $fileData =~ s/$timestampPrefix.*$/$timestampComment/mg;

    # Find the cut points of the file.  We will transform the unexpanded part
    # in the middle, then join it back with the prologue and epilogue at the
    # end. Some boilerplate may be inserted after the prologue and before the
    # epilogue, but only if the transformation is not a no-op.
    my ($prologue, $unexpandedCode, $epilogue, $includesBslCompilerfeatures) =
        segmentFiledata($fileData);

    # Generate the main file.  If there are no sections to expand, returns
    # an empty string.
    my $output = transformFile($unexpandedCode, 1);

    if (! $output) {
        # There were no expansions in the code.  Write unexpanded code with no
        # boilerplate surrounding it.
        writeMaster($inputFilename, $outputFilename, $fileData,
                    $prologue.$unexpandedCode.$epilogue);
    }
    elsif ($inplace) {
        # Write the expanded code with with no boilerplate surrounding it.
        writeMaster($inputFilename, $outputFilename, $fileData,
                    $prologue.$output.$epilogue);
    }
    else {
        # Write main file with boilerplate surrounding the expanded code.
        my ($boilerBeg, $boilerEnd) = filenameToBoilerplate($outputFilename);

        $prologue .= "#include <bsls_compilerfeatures.h>\n\n"
            unless ($includesBslCompilerfeatures);

        writeMaster($inputFilename, $outputFilename, $fileData,
                    $prologue.$boilerBeg.$output.$boilerEnd.$epilogue);
    }

    if (! $inplace) {
        # Generate expansion output file by inserting "_cpp03" before the
        # file extension.
        $outputFilename =~ s{([^.])(\.[^/\\]*)?$}{$1_cpp03$2};

        # Take the recently-generated main file and use as input
        # to a second call to 'transformFile' to generate the expansion.
        if ($output) {
            $output = transformFile($output, 0);
        }
        else {
            $output = "// No C++03 Expansion\n";
        }

        # Generate the boilerplate to surround the expanded code.
        my ($boilerBeg, $boilerEnd) = filenameToBoilerplate($outputFilename);

        # Save expansion to file
        writeExpansion($outputFilename, $boilerBeg.$output.$boilerEnd);
    }

    return 0;
}

###############################################################################
#                            MAIN PROGRAM                                     #
###############################################################################

sub usage($) {
    my $message = $_[0] || "";
    print <<EOT;
$message
Usage: sim_cpp11_features.pl [ --output=<filename> ]
                             [ --var-args=<max-args> ]
                             [ --debug=<level> ]
                             [ --trace=<subroutine>:<level> ]
                             [ --[no-]inplace ]
                             [ --verify-no-change ]
                             [ --clean ]
                             [ --test ]
                             { <input-file>... | - }
EOT
    exit 1;
}

# Return the minimal string of command-line options and current file
# name, needed to reliably regenerate this script's output.  Options that
# don't affect the output (e.g., debugging options and default options) are
# excluded from returned string.
sub getCommandLine {
    my $filename = $_[0];
    my $ret = basename($0);

    $ret .= " --inplace" if $inplace;
    $ret .= " --clean"   if $clean;
    $ret .= " --test"    if $selfTest;

    $ret .= " ".basename($filename) if $filename;

    return $ret;
}

sub main() {
    my $outputOption;
    my @traceLabels;

    GetOptions("output=s"         => \$outputOption,
               "debug=i"          => \$debug,
               "trace=s"          => \@traceLabels,
               "inplace!"         => \$inplace,
               "verify-no-change" => \$verifyNoChange,
               "clean"            => \$clean,
               "test"             => \$selfTest,
               "var-args=i"       => \$maxArgsOpt) or usage("Invalid option");

    Util::Message::set_debug($debug);

    # Multiple trace labels can be specified using either a comma-separated
    # list or multiple --trace options or both.  Combine them all into one
    # array of labels.
    @traceLabels = split(/,/, join(',', @traceLabels));
    for my $traceLabel (@traceLabels) {
        my ($label, $level) = split(/:/, $traceLabel);
        $level = $level || 1;  # "xyz" is equivalent to "xyz:1"
        $level = $level + 0;   # Make numeric
        $traceCtrls{$label} = $level;
    }

    my $timestamp = localtime();
    $timestampComment = $timestampPrefix . $timestamp;

    # Check for conflicting arguments
    usage("Option --clean requires --inplace") if ($clean and !$inplace);
    usage("Cannot specify filename with --test") if ($selfTest && @ARGV);
    usage("Must specifiy an input file name or -") unless ($selfTest || @ARGV);
    usage("Only one input file name may be specified when using --output")
        if (1 < @ARGV && $outputOption);

    if ($selfTest) {
        unshift @ARGV, "TEST";
        $outputOption = "TEST_out" unless ($outputOption);
    }

    my $ret = 0;
    for my $inputFilename (@ARGV) {
        $commandLine = getCommandLine($inputFilename);
        my $outputFilename = $outputOption || $inputFilename;
        usage("Writing to  standard output ('-') requires option --inplace")
            if ("-" eq $outputFilename && ! $inplace);

        my $ret = processFile($inputFilename, $outputFilename);

        last if $ret;
    }

    return $ret;
}

# Run main program and exit with returned status
exit main();

###############################################################################
#                            TESTS                                            #
###############################################################################

# Unit tests
sub testCppSearch()
{
    my $teststr = ("abc // def\n".
                   "def /* *ghi' */ ghi\n".
                   '"jk\\"l"jkl'."\n".
                   "'m' m '\\n' n * end\n");
    print "\n*** testCppSearch: teststr =\n$teststr";
    setInput($teststr);

    for my $re (qr/a/, qr/e/, qr/[ef]+/, qr/g/, qr/\*/, qr/j[^a]/, qr/l/,
                qr/m/, qr/n/, qr/z/, qr/f\s*g/) {

        my $pos = 0;
        while (defined($pos)) {
            print "$re\t$pos\t";

            # Call in array context
            my @found = cppSearch($re, $pos);
            my ($start, $end) = ($cppMatchStart[0], $cppMatchEnd[0]);
            # Call again in scalar context
            my $found = cppSearch($re, $pos);
            $pos = $cppMatchEnd[0];
            if ($found) {
                fatal("\$found but not \@found") unless (@found);
                fatal("mismatch end") unless ($end == $pos);
            }
            else {
                fatal("\@found but not \$found") unless (! @found);
            }
            if (@found) {
                print "[@found]\t$start\t$end\n";
            }
            else {
                print "undef\n";
            }
        }
    }
}

# testCppSearch();

sub testLineAndColumn()
{
    setInput("abc\ndefg\n\nx");
    print "input = \n$input";
    for (my $pos = 0; $pos <= $inputEnd; ++$pos) {
        my ($line, $col) = lineAndColumn($pos);
        my $scalarLine = lineAndColumn($pos);
        fatal("$line mismatch") unless ($line == $scalarLine);
        print "$pos\t($line $col)\n";
    }

    print displayPos(6);
    print displayPos(8);
}

# testLineAndColumn();

sub testFindMatchingBrace()
{
    setInput("struct x { int hello(foo) { std::cout \"hello}\"; } };\n".
             "template <class A, class B>\n".
             "class Foo<A, B, (sizoef(A) < 16)> {\n".
             "    A mismatched[SZ; // missing ]\n".
             "};\n");
    print "input =\n$input";

    my @tests = (0  => '{',
                 10 => '(',
                 54 => '<',
                 81 => '<',
                 81 => '(',
                 92 => '<',
                 121 => '[');

    for (my $i = 0; $i < @tests; $i += 2) {
        my $pos = $tests[$i];
        my $brace = $tests[$i + 1];

        print "***** Find $brace at $pos\n";
        print displayPos($pos);
        eval {
            my $found = findMatchingBrace($brace, $pos);
            print "Found matching brace at ".($found?$found-1:"undef")."\n";
            print displayPos($found - 1) if ($found);
        }
    }
}

# testFindMatchingBrace();

sub testStripComments()
{
    my $input =
        "text // C++ comment\n".
        "text /* C comment */ more text\n".
        "text /* multi-line\n".
        "      * comment.\n".
        "      */\n".
        "text \"string\" more text\n".
        "    // multi-line\n".
        "    // comment block\n".
        "text 'x' more text //comment\n";

    my $single_ws =
        "text\n".
        "text more text\n".
        "text\n".
        "text \"string\" more text\n".
        "text 'x' more text\n";

    my $keep_nl =
        "text\n".
        "text more text\n".
        "text\n".
        "\n".
        "\n".
        "text \"string\" more text\n".
        "\n".
        "\n".
        "text 'x' more text\n";

    my $keep_len =
        "text               \n".
        "text                 more text\n".
        "text              \n".
        "                \n".
        "        \n".
        "text \"string\" more text\n".
        "                 \n".
        "                    \n".
        "text 'x' more text          \n";

    my $result;

    $result = stripComments($input);
    print "\nstripComments(input) returned \n$result"
        unless ($result eq $single_ws);

    $result = stripComments($input, "single-ws");
    print "\nstripComments(input, single-ws) returned \n$result"
        unless ($result eq $single_ws);

    $result = stripComments($input, "keep-nl");
    print "\nstripComments(input, keep-nl) returned \n$result"
        unless ($result eq $keep_nl);

    $result = stripComments($input, "keep-len");
    print "\nshroudCommentsAndStrings(input, keep-len) returned \n$result"
        unless ($result eq $keep_len);
}

# testStripComments();

sub testShroudCommentsAndStrings()
{
    local $dummyChar = '.';  # More convenient to type than "\267"

    my $input =
        "text // C++ comment\n".
        "text /* C comment */ more text\n".
        "text /* multi-line\n".
        "      * comment.\n".
        "      */\n".
        "text \"string\" more text\n".
        "text 'x' more text //comment\n";

    my $shrouded =
        "text               \n".
        "text                 more text\n".
        "text              \n".
        "                \n".
        "        \n".
        "text \"......\" more text\n".
        "text '.' more text          \n";

    my $result;

    $result = shroudCommentsAndStrings($input);
    print "\nshroudCommentsAndStrings(input) returned \n$result"
        unless ($result eq $shrouded);
}

# testShroudCommentsAndStrings();

sub testReplaceAndFitOnLine {
    my $doTest = sub {
        my ($working, $repl) = @_;

        $working =~ s/^(~?)/$1                /mg;
        $working =~ m/([:,]\s*)?(XXX*)(\s*,\h*)?/;
        my $packStart = $-[2];
        my $packEnd   = $+[2];

        if (! $repl) {
            if ($3) {
                $packEnd = $+[3];
            }
            elsif ($1) {
                $packStart = $-[1];
            }
        }

        my $packLen = $packEnd - $packStart;
        if ($working =~ /^~/) {
            pushInput($working);
            replaceAndFitOnLine($shroudedInput, $packStart, $packLen, $repl);
            $working = $input;
            popInput();
        }
        else {
            $working =
                replaceAndFitOnLine($working, $packStart, $packLen, $repl);
        }

        return $working;
    };

    my @in = ("theResult = functionCall(XXX);",
              "theResult = functionCall(a, b, XXX);",
              "theResult = functionCall(XXX, d, e, f);",
              "theResult = functionCall(a, b, XXX, d, e, f);",
              "theResult = functionCall(a, b,\n".
              "                         XXX);",
              "theResult = functionCall(XXX\n".
              "                       , d, e, f);",
              "theResult = functionCall(a, b\n".
              "                       , XXX\n".
              "                       , d, e, f);",
              "pre();\n   theResult = functionCall(a, XXX);\npost()",
              "theResult = aMuchLongerFunctionCallThatNears79Cols(a, XXX, b);",
              "~theResult = /* text */ functionCall(t, u, XXX, x, y, z);"
        );

    my @repl = ("",
                "arg1",
                "arg1,\narg2",
                "BSL_M_FORWARD(arg1),\n    BSL_M_FORWARD(arg2)",
        );

    for my $in (@in) {
        for my $repl (@repl) {
            print &$doTest($in, $repl), "\n";
        }
    }
}

#testReplaceAndFitOnLine();

0;

# Copyright 2020 Bloomberg Finance L.P.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License.  You may obtain a copy
# of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
# License for the specific language governing permissions and limitations under
# the License.


__DATA__
// TEST                                                               -*-C++-*-

#include <foo.h>

#ifndef INCLUDED_BSLS_COMPILERFEATURES
#   include <bsls_compilerfeatures.h>
#endif

// Sample input
void f(); // Not a template

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES // $var-args=3
#  ifdef NESTED
template <int ...B, class... A>
void foo(C<B...> *c, A&&... a)
    // This function does the foolish thing.  It is a variadic function and is
    // fully documented.  The specified 'c' parameter is a single argument
    // that uses a parameter pack in a deduced context.  The specified 'a' is
    // a variadic argument.
{
    D<A...> d(bsl::forward<A>(a)...);
    bar(sizeof... (A), c, &d);

    # Identical expansion twice in one line:
    f(bsl::forward<A>(a)...); g(bsl::forward<A>(a)...);
}
#  endif // NESTED

template <class T>
int bar(int a, T&& v)
    // Non-variadic function template that uses perfect forwarding.
{
    xyz(a, bsl::forward<T>(v));
}

#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Command line: sim_cpp11_features.pl --inplace --test
#ifndef TEST_VARIADIC_LIMIT
#define TEST_VARIADIC_LIMIT 3
#endif
#ifndef TEST_VARIADIC_LIMIT_A
#define TEST_VARIADIC_LIMIT_A TEST_VARIADIC_LIMIT
#endif
#  ifdef NESTED
#if TEST_VARIADIC_LIMIT_A >= 0
void foo(C<> *c)
{
    D<> d();
    bar(0u, c, &d);

    # Identical expansion twice in one line:
    f(); g(
                                              );
}
#endif  // TEST_VARIADIC_LIMIT_A >= 0

#if TEST_VARIADIC_LIMIT_A >= 1
template <int B_1, class A_1>
void foo(C<B_1> *c, BSLS_COMPILERFEATURES_FORWARD_REF(A_1) a_1)
{
    D<A_1> d(BSLS_COMPILERFEATURES_FORWARD(A_1, a_1));
    bar(1u, c, &d);

    # Identical expansion twice in one line:
    f(BSLS_COMPILERFEATURES_FORWARD(A_1, a_1)); g(
                                             BSLS_COMPILERFEATURES_FORWARD(A_1,
                                             a_1));
}
#endif  // TEST_VARIADIC_LIMIT_A >= 1

#if TEST_VARIADIC_LIMIT_A >= 2
template <int B_1,
          int B_2, class A_1,
                   class A_2>
void foo(C<B_1,
           B_2> *c, BSLS_COMPILERFEATURES_FORWARD_REF(A_1) a_1,
                    BSLS_COMPILERFEATURES_FORWARD_REF(A_2) a_2)
{
    D<A_1,
      A_2> d(BSLS_COMPILERFEATURES_FORWARD(A_1, a_1),
             BSLS_COMPILERFEATURES_FORWARD(A_2, a_2));
    bar(2u, c, &d);

    # Identical expansion twice in one line:
    f(BSLS_COMPILERFEATURES_FORWARD(A_1, a_1),
      BSLS_COMPILERFEATURES_FORWARD(A_2, a_2)); g(
                                             BSLS_COMPILERFEATURES_FORWARD(A_1,
                                             a_1),
                                             BSLS_COMPILERFEATURES_FORWARD(A_2,
                                             a_2));
}
#endif  // TEST_VARIADIC_LIMIT_A >= 2

#if TEST_VARIADIC_LIMIT_A >= 3
template <int B_1,
          int B_2,
          int B_3, class A_1,
                   class A_2,
                   class A_3>
void foo(C<B_1,
           B_2,
           B_3> *c, BSLS_COMPILERFEATURES_FORWARD_REF(A_1) a_1,
                    BSLS_COMPILERFEATURES_FORWARD_REF(A_2) a_2,
                    BSLS_COMPILERFEATURES_FORWARD_REF(A_3) a_3)
{
    D<A_1,
      A_2,
      A_3> d(BSLS_COMPILERFEATURES_FORWARD(A_1, a_1),
             BSLS_COMPILERFEATURES_FORWARD(A_2, a_2),
             BSLS_COMPILERFEATURES_FORWARD(A_3, a_3));
    bar(3u, c, &d);

    # Identical expansion twice in one line:
    f(BSLS_COMPILERFEATURES_FORWARD(A_1, a_1),
      BSLS_COMPILERFEATURES_FORWARD(A_2, a_2),
      BSLS_COMPILERFEATURES_FORWARD(A_3, a_3)); g(
                                             BSLS_COMPILERFEATURES_FORWARD(A_1,
                                             a_1),
                                             BSLS_COMPILERFEATURES_FORWARD(A_2,
                                             a_2),
                                             BSLS_COMPILERFEATURES_FORWARD(A_3,
                                             a_3));
}
#endif  // TEST_VARIADIC_LIMIT_A >= 3

#  endif

template <class T>
int bar(int a, BSLS_COMPILERFEATURES_FORWARD_REF(T) v)
{
    xyz(a, BSLS_COMPILERFEATURES_FORWARD(T, v));
}
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
#  ifdef NESTED
template <int ...B, class... A>
void foo(C<B...> *c, BSLS_COMPILERFEATURES_FORWARD_REF(A)... a)
{
    D<A...> d(BSLS_COMPILERFEATURES_FORWARD(A, a)...);
    bar(sizeof... (A), c, &d);

    # Identical expansion twice in one line:
    f(BSLS_COMPILERFEATURES_FORWARD(A, a)...); g(
                                              BSLS_COMPILERFEATURES_FORWARD(A,
                                              a)...);
}
#  endif

template <class T>
int bar(int a, BSLS_COMPILERFEATURES_FORWARD_REF(T) v)
{
    xyz(a, BSLS_COMPILERFEATURES_FORWARD(T, v));
}

// }}} END GENERATED CODE
#endif

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
// The following is a variadic template function
template <typename... A>  // Comments are removed
    void g(const vector<A>&... a)
    {
        if (q()) {
            xyz(forward<A, int>(a)...
                );
        }
    }

template <int X, class ...T>
class C
{
public:
    typename mf<X>::type member(const T&... z);

    template <class U> void member2(U&& v);
};

template <int X, class ...T>
typename mf<X>::type C<X, T...>::member(const T&... z)
{
}

template <int X, class ...T>
    template <class U>
void C<X, T...>::member2(U&& v)
{
    q(std::forward< U >( v ));
}

template <int X, unsigned ...V>
struct D
{
    typename mf<X>::type member();
};

template <int X, unsigned ...V>
typename mf<X>::type D<V...>::member()
{
}

template <class ...T>
    X::X(const T&... args) : v(args)... { }

template <typename T>
    void z(const vector<T>& v);  // No variadics

#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Command line: sim_cpp11_features.pl --inplace --test
#ifndef TEST_VARIADIC_LIMIT
#define TEST_VARIADIC_LIMIT 3
#endif
#ifndef TEST_VARIADIC_LIMIT_B
#define TEST_VARIADIC_LIMIT_B TEST_VARIADIC_LIMIT
#endif
#if TEST_VARIADIC_LIMIT_B >= 0
void g()
    {
        if (q()) {
            xyz(
                );
        }
    }
#endif  // TEST_VARIADIC_LIMIT_B >= 0

#if TEST_VARIADIC_LIMIT_B >= 1
template <typename A_1>
    void g(const vector<A_1>& a_1)
    {
        if (q()) {
            xyz(forward<A_1, int>(a_1)
                );
        }
    }
#endif  // TEST_VARIADIC_LIMIT_B >= 1

#if TEST_VARIADIC_LIMIT_B >= 2
template <typename A_1,
          typename A_2>
    void g(const vector<A_1>& a_1,
           const vector<A_2>& a_2)
    {
        if (q()) {
            xyz(forward<A_1, int>(a_1),
                forward<A_2, int>(a_2)
                );
        }
    }
#endif  // TEST_VARIADIC_LIMIT_B >= 2

#if TEST_VARIADIC_LIMIT_B >= 3
template <typename A_1,
          typename A_2,
          typename A_3>
    void g(const vector<A_1>& a_1,
           const vector<A_2>& a_2,
           const vector<A_3>& a_3)
    {
        if (q()) {
            xyz(forward<A_1, int>(a_1),
                forward<A_2, int>(a_2),
                forward<A_3, int>(a_3)
                );
        }
    }
#endif  // TEST_VARIADIC_LIMIT_B >= 3


template <int X
#if TEST_VARIADIC_LIMIT_B >= 0
        , class T_0 = BSLS_COMPILERFEATURES_NILT
#endif  // TEST_VARIADIC_LIMIT_B >= 0

#if TEST_VARIADIC_LIMIT_B >= 1
        , class T_1 = BSLS_COMPILERFEATURES_NILT
#endif  // TEST_VARIADIC_LIMIT_B >= 1

#if TEST_VARIADIC_LIMIT_B >= 2
        , class T_2 = BSLS_COMPILERFEATURES_NILT
#endif  // TEST_VARIADIC_LIMIT_B >= 2
        , class = BSLS_COMPILERFEATURES_NILT>
class C;

#if TEST_VARIADIC_LIMIT_B >= 0
template <int X>
class C<X>
{
public:
    typename mf<X>::type member();

    template <class U> void member2(BSLS_COMPILERFEATURES_FORWARD_REF(U) v);
};
#endif  // TEST_VARIADIC_LIMIT_B >= 0

#if TEST_VARIADIC_LIMIT_B >= 1
template <int X, class T_1>
class C<X, T_1>
{
public:
    typename mf<X>::type member(const T_1& z_1);

    template <class U> void member2(BSLS_COMPILERFEATURES_FORWARD_REF(U) v);
};
#endif  // TEST_VARIADIC_LIMIT_B >= 1

#if TEST_VARIADIC_LIMIT_B >= 2
template <int X, class T_1,
                 class T_2>
class C<X, T_1,
           T_2>
{
public:
    typename mf<X>::type member(const T_1& z_1,
                                const T_2& z_2);

    template <class U> void member2(BSLS_COMPILERFEATURES_FORWARD_REF(U) v);
};
#endif  // TEST_VARIADIC_LIMIT_B >= 2

#if TEST_VARIADIC_LIMIT_B >= 3
template <int X, class T_1,
                 class T_2,
                 class T_3>
class C<X, T_1,
           T_2,
           T_3>
{
public:
    typename mf<X>::type member(const T_1& z_1,
                                const T_2& z_2,
                                const T_3& z_3);

    template <class U> void member2(BSLS_COMPILERFEATURES_FORWARD_REF(U) v);
};
#endif  // TEST_VARIADIC_LIMIT_B >= 3


#if TEST_VARIADIC_LIMIT_B >= 0
template <int X>
typename mf<X>::type C<X, BSLS_COMPILERFEATURES_FILLT(3)>::member()
{
}
#endif  // TEST_VARIADIC_LIMIT_B >= 0

#if TEST_VARIADIC_LIMIT_B >= 1
template <int X, class T_1>
typename mf<X>::type C<X, T_1,
                          BSLS_COMPILERFEATURES_FILLT(2)>::member(
                                                                const T_1& z_1)
{
}
#endif  // TEST_VARIADIC_LIMIT_B >= 1

#if TEST_VARIADIC_LIMIT_B >= 2
template <int X, class T_1,
                 class T_2>
typename mf<X>::type C<X, T_1,
                          T_2,
                          BSLS_COMPILERFEATURES_FILLT(1)>::member(
                                                                const T_1& z_1,
                                                                const T_2& z_2)
{
}
#endif  // TEST_VARIADIC_LIMIT_B >= 2

#if TEST_VARIADIC_LIMIT_B >= 3
template <int X, class T_1,
                 class T_2,
                 class T_3>
typename mf<X>::type C<X, T_1,
                          T_2,
                          T_3,
                          BSLS_COMPILERFEATURES_FILLT(0)>::member(
                                                                const T_1& z_1,
                                                                const T_2& z_2,
                                                                const T_3& z_3)
{
}
#endif  // TEST_VARIADIC_LIMIT_B >= 3


#if TEST_VARIADIC_LIMIT_B >= 0
template <int X>
    template <class U>
void C<X, BSLS_COMPILERFEATURES_FILLT(3)
          >::member2(BSLS_COMPILERFEATURES_FORWARD_REF(U) v)
{
    q(BSLS_COMPILERFEATURES_FORWARD(U,  v ));
}
#endif  // TEST_VARIADIC_LIMIT_B >= 0

#if TEST_VARIADIC_LIMIT_B >= 1
template <int X, class T_1>
    template <class U>
void C<X, T_1,
          BSLS_COMPILERFEATURES_FILLT(2)
          >::member2(BSLS_COMPILERFEATURES_FORWARD_REF(U) v)
{
    q(BSLS_COMPILERFEATURES_FORWARD(U,  v ));
}
#endif  // TEST_VARIADIC_LIMIT_B >= 1

#if TEST_VARIADIC_LIMIT_B >= 2
template <int X, class T_1,
                 class T_2>
    template <class U>
void C<X, T_1,
          T_2,
          BSLS_COMPILERFEATURES_FILLT(1)
          >::member2(BSLS_COMPILERFEATURES_FORWARD_REF(U) v)
{
    q(BSLS_COMPILERFEATURES_FORWARD(U,  v ));
}
#endif  // TEST_VARIADIC_LIMIT_B >= 2

#if TEST_VARIADIC_LIMIT_B >= 3
template <int X, class T_1,
                 class T_2,
                 class T_3>
    template <class U>
void C<X, T_1,
          T_2,
          T_3,
          BSLS_COMPILERFEATURES_FILLT(0)
          >::member2(BSLS_COMPILERFEATURES_FORWARD_REF(U) v)
{
    q(BSLS_COMPILERFEATURES_FORWARD(U,  v ));
}
#endif  // TEST_VARIADIC_LIMIT_B >= 3


template <int X
#if TEST_VARIADIC_LIMIT_B >= 0
        , unsigned V_0 = BSLS_COMPILERFEATURES_NILV
#endif  // TEST_VARIADIC_LIMIT_B >= 0

#if TEST_VARIADIC_LIMIT_B >= 1
        , unsigned V_1 = BSLS_COMPILERFEATURES_NILV
#endif  // TEST_VARIADIC_LIMIT_B >= 1

#if TEST_VARIADIC_LIMIT_B >= 2
        , unsigned V_2 = BSLS_COMPILERFEATURES_NILV
#endif  // TEST_VARIADIC_LIMIT_B >= 2
        , unsigned = BSLS_COMPILERFEATURES_NILV>
struct D;

#if TEST_VARIADIC_LIMIT_B >= 0
template <int X>
struct D<X>
{
    typename mf<X>::type member();
};
#endif  // TEST_VARIADIC_LIMIT_B >= 0

#if TEST_VARIADIC_LIMIT_B >= 1
template <int X, unsigned V_1>
struct D<X, V_1>
{
    typename mf<X>::type member();
};
#endif  // TEST_VARIADIC_LIMIT_B >= 1

#if TEST_VARIADIC_LIMIT_B >= 2
template <int X, unsigned V_1,
                 unsigned V_2>
struct D<X, V_1,
            V_2>
{
    typename mf<X>::type member();
};
#endif  // TEST_VARIADIC_LIMIT_B >= 2

#if TEST_VARIADIC_LIMIT_B >= 3
template <int X, unsigned V_1,
                 unsigned V_2,
                 unsigned V_3>
struct D<X, V_1,
            V_2,
            V_3>
{
    typename mf<X>::type member();
};
#endif  // TEST_VARIADIC_LIMIT_B >= 3


#if TEST_VARIADIC_LIMIT_B >= 0
template <int X>
typename mf<X>::type D<BSLS_COMPILERFEATURES_FILLV(3)>::member()
{
}
#endif  // TEST_VARIADIC_LIMIT_B >= 0

#if TEST_VARIADIC_LIMIT_B >= 1
template <int X, unsigned V_1>
typename mf<X>::type D<V_1,
                       BSLS_COMPILERFEATURES_FILLV(2)>::member()
{
}
#endif  // TEST_VARIADIC_LIMIT_B >= 1

#if TEST_VARIADIC_LIMIT_B >= 2
template <int X, unsigned V_1,
                 unsigned V_2>
typename mf<X>::type D<V_1,
                       V_2,
                       BSLS_COMPILERFEATURES_FILLV(1)>::member()
{
}
#endif  // TEST_VARIADIC_LIMIT_B >= 2

#if TEST_VARIADIC_LIMIT_B >= 3
template <int X, unsigned V_1,
                 unsigned V_2,
                 unsigned V_3>
typename mf<X>::type D<V_1,
                       V_2,
                       V_3,
                       BSLS_COMPILERFEATURES_FILLV(0)>::member()
{
}
#endif  // TEST_VARIADIC_LIMIT_B >= 3


#if TEST_VARIADIC_LIMIT_B >= 0
X::X() { }
#endif  // TEST_VARIADIC_LIMIT_B >= 0

#if TEST_VARIADIC_LIMIT_B >= 1
template <class T_1>
    X::X(const T_1& args_1) : v(args_1) { }
#endif  // TEST_VARIADIC_LIMIT_B >= 1

#if TEST_VARIADIC_LIMIT_B >= 2
template <class T_1,
          class T_2>
    X::X(const T_1& args_1,
         const T_2& args_2) : v(args_1),
                              v(args_2) { }
#endif  // TEST_VARIADIC_LIMIT_B >= 2

#if TEST_VARIADIC_LIMIT_B >= 3
template <class T_1,
          class T_2,
          class T_3>
    X::X(const T_1& args_1,
         const T_2& args_2,
         const T_3& args_3) : v(args_1),
                              v(args_2),
                              v(args_3) { }
#endif  // TEST_VARIADIC_LIMIT_B >= 3


template <typename T>
    void z(const vector<T>& v);
#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <typename... A>
    void g(const vector<A>&... a)
    {
        if (q()) {
            xyz(forward<A, int>(a)...
                );
        }
    }

template <int X, class ...T>
class C
{
public:
    typename mf<X>::type member(const T&... z);

    template <class U> void member2(U&& v);
};

template <int X, class ...T>
typename mf<X>::type C<X, T...>::member(const T&... z)
{
}

template <int X, class ...T>
    template <class U>
void C<X, T...>::member2(BSLS_COMPILERFEATURES_FORWARD_REF(U) v)
{
    q(BSLS_COMPILERFEATURES_FORWARD(U,  v ));
}

template <int X, unsigned ...V>
struct D
{
    typename mf<X>::type member();
};

template <int X, unsigned ...V>
typename mf<X>::type D<V...>::member()
{
}

template <class ...T>
    X::X(const T&... args) : v(args)... { }

template <typename T>
    void z(const vector<T>& v);

// }}} END GENERATED CODE
#endif

template <class T>
class NonVaridadicClassWithVariadicMember
{
#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES // $local-var-args=4
    template <class... U>
        NonVaridadicClassWithVariadicMember(const U&... u);

#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Command line: sim_cpp11_features.pl --inplace --test
#ifndef TEST_VARIADIC_LIMIT
#define TEST_VARIADIC_LIMIT 3
#endif
#ifndef TEST_VARIADIC_LIMIT_C
#define TEST_VARIADIC_LIMIT_C TEST_VARIADIC_LIMIT
#endif
#if TEST_VARIADIC_LIMIT_C >= 0
    NonVaridadicClassWithVariadicMember();
#endif  // TEST_VARIADIC_LIMIT_C >= 0

#if TEST_VARIADIC_LIMIT_C >= 1
    template <class U_1>
        NonVaridadicClassWithVariadicMember(const U_1& u_1);
#endif  // TEST_VARIADIC_LIMIT_C >= 1

#if TEST_VARIADIC_LIMIT_C >= 2
    template <class U_1,
              class U_2>
        NonVaridadicClassWithVariadicMember(const U_1& u_1,
                                            const U_2& u_2);
#endif  // TEST_VARIADIC_LIMIT_C >= 2

#if TEST_VARIADIC_LIMIT_C >= 3
    template <class U_1,
              class U_2,
              class U_3>
        NonVaridadicClassWithVariadicMember(const U_1& u_1,
                                            const U_2& u_2,
                                            const U_3& u_3);
#endif  // TEST_VARIADIC_LIMIT_C >= 3

#if TEST_VARIADIC_LIMIT_C >= 4
    template <class U_1,
              class U_2,
              class U_3,
              class U_4>
        NonVaridadicClassWithVariadicMember(const U_1& u_1,
                                            const U_2& u_2,
                                            const U_3& u_3,
                                            const U_4& u_4);
#endif  // TEST_VARIADIC_LIMIT_C >= 4

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template <class... U>
        NonVaridadicClassWithVariadicMember(const U&... u);

// }}} END GENERATED CODE
#endif
};

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
template <class T>
    template <class... U>
NonVaridadicClassWithVariadicMember<T>::
    NonVaridadicClassWithVariadicMember(const U&... u);

template <class... TYPE>
void Cls<TYPE...>::functionWithLongExpansion79Columns(TYPE&&... a, double b);

#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Command line: sim_cpp11_features.pl --inplace --test
#ifndef TEST_VARIADIC_LIMIT
#define TEST_VARIADIC_LIMIT 3
#endif
#ifndef TEST_VARIADIC_LIMIT_D
#define TEST_VARIADIC_LIMIT_D TEST_VARIADIC_LIMIT
#endif
#if TEST_VARIADIC_LIMIT_D >= 0
template <class T>
    NonVaridadicClassWithVariadicMember<T>::
    NonVaridadicClassWithVariadicMember();
#endif  // TEST_VARIADIC_LIMIT_D >= 0

#if TEST_VARIADIC_LIMIT_D >= 1
template <class T>
    template <class U_1>
NonVaridadicClassWithVariadicMember<T>::
    NonVaridadicClassWithVariadicMember(const U_1& u_1);
#endif  // TEST_VARIADIC_LIMIT_D >= 1

#if TEST_VARIADIC_LIMIT_D >= 2
template <class T>
    template <class U_1,
              class U_2>
NonVaridadicClassWithVariadicMember<T>::
    NonVaridadicClassWithVariadicMember(const U_1& u_1,
                                        const U_2& u_2);
#endif  // TEST_VARIADIC_LIMIT_D >= 2

#if TEST_VARIADIC_LIMIT_D >= 3
template <class T>
    template <class U_1,
              class U_2,
              class U_3>
NonVaridadicClassWithVariadicMember<T>::
    NonVaridadicClassWithVariadicMember(const U_1& u_1,
                                        const U_2& u_2,
                                        const U_3& u_3);
#endif  // TEST_VARIADIC_LIMIT_D >= 3


#if TEST_VARIADIC_LIMIT_D >= 0
void Cls<BSLS_COMPILERFEATURES_FILLT(3)>::functionWithLongExpansion79Columns(
                                  double b);
#endif  // TEST_VARIADIC_LIMIT_D >= 0

#if TEST_VARIADIC_LIMIT_D >= 1
template <class TYPE_1>
void Cls<TYPE_1,
         BSLS_COMPILERFEATURES_FILLT(2)>::functionWithLongExpansion79Columns(
                                 BSLS_COMPILERFEATURES_FORWARD_REF(TYPE_1) a_1,
                                  double b);
#endif  // TEST_VARIADIC_LIMIT_D >= 1

#if TEST_VARIADIC_LIMIT_D >= 2
template <class TYPE_1,
          class TYPE_2>
void Cls<TYPE_1,
         TYPE_2,
         BSLS_COMPILERFEATURES_FILLT(1)>::functionWithLongExpansion79Columns(
                                 BSLS_COMPILERFEATURES_FORWARD_REF(TYPE_1) a_1,
                                 BSLS_COMPILERFEATURES_FORWARD_REF(TYPE_2) a_2,
                                  double b);
#endif  // TEST_VARIADIC_LIMIT_D >= 2

#if TEST_VARIADIC_LIMIT_D >= 3
template <class TYPE_1,
          class TYPE_2,
          class TYPE_3>
void Cls<TYPE_1,
         TYPE_2,
         TYPE_3,
         BSLS_COMPILERFEATURES_FILLT(0)>::functionWithLongExpansion79Columns(
                                 BSLS_COMPILERFEATURES_FORWARD_REF(TYPE_1) a_1,
                                 BSLS_COMPILERFEATURES_FORWARD_REF(TYPE_2) a_2,
                                 BSLS_COMPILERFEATURES_FORWARD_REF(TYPE_3) a_3,
                                  double b);
#endif  // TEST_VARIADIC_LIMIT_D >= 3

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class T>
    template <class... U>
NonVaridadicClassWithVariadicMember<T>::
    NonVaridadicClassWithVariadicMember(const U&... u);

template <class... TYPE>
void Cls<TYPE...>::functionWithLongExpansion79Columns(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(TYPE)... a,
                                  double b);

// }}} END GENERATED CODE
#endif

void h();

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class CTOR_ARG, class... CTOR_ARGS>
inline void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  allocator,
                                            ELEMENT_TYPE    *elementAddr,
                                            CTOR_ARG&&       ctorArg,
                                            CTOR_ARGS&&...   ctorArgs)
{
    BloombergLP::bslalg_ScalarPrimitives::construct(
        elementAddr,
        std::forward<CTOR_ARG>(ctorArg),
        std::forward<CTOR_ARGS>(ctorArgs)...,
        mechanism(allocator, IsBslma()));
}
#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Command line: sim_cpp11_features.pl --inplace --test
#ifndef TEST_VARIADIC_LIMIT
#define TEST_VARIADIC_LIMIT 3
#endif
#ifndef TEST_VARIADIC_LIMIT_E
#define TEST_VARIADIC_LIMIT_E TEST_VARIADIC_LIMIT
#endif
#if TEST_VARIADIC_LIMIT_E >= 0
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class CTOR_ARG>
inline void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  allocator,
                                            ELEMENT_TYPE    *elementAddr,
                           BSLS_COMPILERFEATURES_FORWARD_REF(CTOR_ARG) ctorArg)
{
    BloombergLP::bslalg_ScalarPrimitives::construct(
        elementAddr,
        BSLS_COMPILERFEATURES_FORWARD(CTOR_ARG, ctorArg),
        mechanism(allocator, IsBslma()));
}
#endif  // TEST_VARIADIC_LIMIT_E >= 0

#if TEST_VARIADIC_LIMIT_E >= 1
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class CTOR_ARG, class CTOR_ARGS_1>
inline void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  allocator,
                                            ELEMENT_TYPE    *elementAddr,
                           BSLS_COMPILERFEATURES_FORWARD_REF(CTOR_ARG) ctorArg,
                     BSLS_COMPILERFEATURES_FORWARD_REF(CTOR_ARGS_1) ctorArgs_1)
{
    BloombergLP::bslalg_ScalarPrimitives::construct(
        elementAddr,
        BSLS_COMPILERFEATURES_FORWARD(CTOR_ARG, ctorArg),
        BSLS_COMPILERFEATURES_FORWARD(CTOR_ARGS_1, ctorArgs_1),
        mechanism(allocator, IsBslma()));
}
#endif  // TEST_VARIADIC_LIMIT_E >= 1

#if TEST_VARIADIC_LIMIT_E >= 2
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class CTOR_ARG, class CTOR_ARGS_1,
                                              class CTOR_ARGS_2>
inline void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  allocator,
                                            ELEMENT_TYPE    *elementAddr,
                           BSLS_COMPILERFEATURES_FORWARD_REF(CTOR_ARG) ctorArg,
                     BSLS_COMPILERFEATURES_FORWARD_REF(CTOR_ARGS_1) ctorArgs_1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(CTOR_ARGS_2) ctorArgs_2)
{
    BloombergLP::bslalg_ScalarPrimitives::construct(
        elementAddr,
        BSLS_COMPILERFEATURES_FORWARD(CTOR_ARG, ctorArg),
        BSLS_COMPILERFEATURES_FORWARD(CTOR_ARGS_1, ctorArgs_1),
        BSLS_COMPILERFEATURES_FORWARD(CTOR_ARGS_2, ctorArgs_2),
        mechanism(allocator, IsBslma()));
}
#endif  // TEST_VARIADIC_LIMIT_E >= 2

#if TEST_VARIADIC_LIMIT_E >= 3
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class CTOR_ARG, class CTOR_ARGS_1,
                                              class CTOR_ARGS_2,
                                              class CTOR_ARGS_3>
inline void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  allocator,
                                            ELEMENT_TYPE    *elementAddr,
                           BSLS_COMPILERFEATURES_FORWARD_REF(CTOR_ARG) ctorArg,
                     BSLS_COMPILERFEATURES_FORWARD_REF(CTOR_ARGS_1) ctorArgs_1,
                     BSLS_COMPILERFEATURES_FORWARD_REF(CTOR_ARGS_2) ctorArgs_2,
                     BSLS_COMPILERFEATURES_FORWARD_REF(CTOR_ARGS_3) ctorArgs_3)
{
    BloombergLP::bslalg_ScalarPrimitives::construct(
        elementAddr,
        BSLS_COMPILERFEATURES_FORWARD(CTOR_ARG, ctorArg),
        BSLS_COMPILERFEATURES_FORWARD(CTOR_ARGS_1, ctorArgs_1),
        BSLS_COMPILERFEATURES_FORWARD(CTOR_ARGS_2, ctorArgs_2),
        BSLS_COMPILERFEATURES_FORWARD(CTOR_ARGS_3, ctorArgs_3),
        mechanism(allocator, IsBslma()));
}
#endif  // TEST_VARIADIC_LIMIT_E >= 3

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class ALLOCATOR_TYPE>
template <class ELEMENT_TYPE, class CTOR_ARG, class... CTOR_ARGS>
inline void
allocator_traits<ALLOCATOR_TYPE>::construct(ALLOCATOR_TYPE&  allocator,
                                            ELEMENT_TYPE    *elementAddr,
                           BSLS_COMPILERFEATURES_FORWARD_REF(CTOR_ARG) ctorArg,
                      BSLS_COMPILERFEATURES_FORWARD_REF(CTOR_ARGS)... ctorArgs)
{
    BloombergLP::bslalg_ScalarPrimitives::construct(
        elementAddr,
        BSLS_COMPILERFEATURES_FORWARD(CTOR_ARG, ctorArg),
        BSLS_COMPILERFEATURES_FORWARD(CTOR_ARGS, ctorArgs)...,
        mechanism(allocator, IsBslma()));
}
// }}} END GENERATED CODE
#endif

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
// Function with perfect forwarding but no variadics
template <typename A>
void forwardingFunction(A&& x);
#else
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <typename A>
void forwardingFunction(BSLS_COMPILERFEATURES_FORWARD_REF(A) x);
// }}} END GENERATED CODE
#endif

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
// Non-template function
void nonTemplateFunction(int x);

// Template function with neither forwarding nor variadics.
template <typename X>
void normalTemplate(const X& v);
#else
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
void nonTemplateFunction(int x);

template <typename X>
void normalTemplate(const X& v);
// }}} END GENERATED CODE
#endif

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
template <class T,
          class U,
          class... X>
class P
{
};

template <class A_very_long_template_parameter_name_that_will_force_wrapping,
          class T,
          class... X>
class Q
{
};
#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Command line: sim_cpp11_features.pl --inplace --test
#ifndef TEST_VARIADIC_LIMIT
#define TEST_VARIADIC_LIMIT 3
#endif
#ifndef TEST_VARIADIC_LIMIT_H
#define TEST_VARIADIC_LIMIT_H TEST_VARIADIC_LIMIT
#endif
template <class T,
          class U
#if TEST_VARIADIC_LIMIT_H >= 0
        , class X_0 = BSLS_COMPILERFEATURES_NILT
#endif  // TEST_VARIADIC_LIMIT_H >= 0

#if TEST_VARIADIC_LIMIT_H >= 1
        , class X_1 = BSLS_COMPILERFEATURES_NILT
#endif  // TEST_VARIADIC_LIMIT_H >= 1

#if TEST_VARIADIC_LIMIT_H >= 2
        , class X_2 = BSLS_COMPILERFEATURES_NILT
#endif  // TEST_VARIADIC_LIMIT_H >= 2
        , class = BSLS_COMPILERFEATURES_NILT>
class P;

#if TEST_VARIADIC_LIMIT_H >= 0
template <class T, class U>
class P<T, U>
{
};
#endif  // TEST_VARIADIC_LIMIT_H >= 0

#if TEST_VARIADIC_LIMIT_H >= 1
template <class T, class U, class X_1>
class P<T, U, X_1>
{
};
#endif  // TEST_VARIADIC_LIMIT_H >= 1

#if TEST_VARIADIC_LIMIT_H >= 2
template <class T, class U, class X_1,
                            class X_2>
class P<T, U, X_1,
              X_2>
{
};
#endif  // TEST_VARIADIC_LIMIT_H >= 2

#if TEST_VARIADIC_LIMIT_H >= 3
template <class T, class U, class X_1,
                            class X_2,
                            class X_3>
class P<T, U, X_1,
              X_2,
              X_3>
{
};
#endif  // TEST_VARIADIC_LIMIT_H >= 3


template <class A_very_long_template_parameter_name_that_will_force_wrapping,
          class T
#if TEST_VARIADIC_LIMIT_H >= 0
        , class X_0 = BSLS_COMPILERFEATURES_NILT
#endif  // TEST_VARIADIC_LIMIT_H >= 0

#if TEST_VARIADIC_LIMIT_H >= 1
        , class X_1 = BSLS_COMPILERFEATURES_NILT
#endif  // TEST_VARIADIC_LIMIT_H >= 1

#if TEST_VARIADIC_LIMIT_H >= 2
        , class X_2 = BSLS_COMPILERFEATURES_NILT
#endif  // TEST_VARIADIC_LIMIT_H >= 2
        , class = BSLS_COMPILERFEATURES_NILT>
class Q;

#if TEST_VARIADIC_LIMIT_H >= 0
template <class A_very_long_template_parameter_name_that_will_force_wrapping,
          class T>
class Q<A_very_long_template_parameter_name_that_will_force_wrapping, T>
{
};
#endif  // TEST_VARIADIC_LIMIT_H >= 0

#if TEST_VARIADIC_LIMIT_H >= 1
template <class A_very_long_template_parameter_name_that_will_force_wrapping,
          class T, class X_1>
class Q<A_very_long_template_parameter_name_that_will_force_wrapping, T, X_1>
{
};
#endif  // TEST_VARIADIC_LIMIT_H >= 1

#if TEST_VARIADIC_LIMIT_H >= 2
template <class A_very_long_template_parameter_name_that_will_force_wrapping,
          class T, class X_1,
                   class X_2>
class Q<A_very_long_template_parameter_name_that_will_force_wrapping, T, X_1,
                                                                         X_2>
{
};
#endif  // TEST_VARIADIC_LIMIT_H >= 2

#if TEST_VARIADIC_LIMIT_H >= 3
template <class A_very_long_template_parameter_name_that_will_force_wrapping,
          class T, class X_1,
                   class X_2,
                   class X_3>
class Q<A_very_long_template_parameter_name_that_will_force_wrapping, T, X_1,
                                                                         X_2,
                                                                         X_3>
{
};
#endif  // TEST_VARIADIC_LIMIT_H >= 3

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class T,
          class U,
          class... X>
class P
{
};

template <class A_very_long_template_parameter_name_that_will_force_wrapping,
          class T,
          class... X>
class Q
{
};
// }}} END GENERATED CODE
#endif
