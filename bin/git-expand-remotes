#!/bin/bash

# git-expand-remotes - Replace git insteadOf shortcuts with actual URLs for all remotes
#
# This script can be run in a git repository or in a parent directory containing git repositories.
# It uses git commands to discover and expand insteadOf URL shortcuts to their actual URLs.

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
print_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Function to check if we're in a git repository
is_git_repo() {
    git rev-parse --git-dir >/dev/null 2>&1
}

# Function to expand a single URL using git's insteadOf configuration
expand_url() {
    local url="$1"
    local expanded_url

    # Use git ls-remote to let git handle the URL expansion
    # This will apply any insteadOf transformations
    expanded_url=$(git ls-remote --get-url "$url" 2>/dev/null || echo "$url")

    echo "$expanded_url"
}

# Function to get all insteadOf configurations
get_insteadof_configs() {
    git config --get-regexp '^url\..*\.insteadof$' 2>/dev/null || true
}

# Function to manually expand URL based on insteadOf rules
manual_expand_url() {
    local url="$1"
    local expanded="$url"

    # Get all insteadOf configurations
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            # Parse the config line: url.SHORTCUT.insteadof ACTUAL_URL
            local config_key="${line%% *}"
            local actual_url="${line#* }"

            # Extract the shortcut from the config key
            # url.bbgithub:.insteadof -> bbgithub:
            local shortcut="${config_key#url.}"
            shortcut="${shortcut%.insteadof}"

            # If the URL starts with the shortcut, replace it with the actual URL
            if [[ "$expanded" == "$shortcut"* ]]; then
                expanded="${actual_url}${expanded#$shortcut}"
                break
            fi
        fi
    done < <(get_insteadof_configs)

    echo "$expanded"
}

# Function to process a single git repository
process_git_repo() {
    local repo_path="$1"
    local repo_name=$(basename "$repo_path")

    print_info "Processing repository: $repo_name"

    cd "$repo_path"

    # Check if it's actually a git repository
    if ! is_git_repo; then
        print_warning "Not a git repository: $repo_path"
        return 1
    fi

    # Get list of all remotes
    local remotes
    remotes=$(git remote 2>/dev/null || true)

    if [[ -z "$remotes" ]]; then
        print_warning "No remotes found in repository: $repo_name"
        return 0
    fi

    local changes_made=false

        # Process each remote
        while IFS= read -r remote; do
            if [[ -n "$remote" ]]; then
                # Get the actual stored URL (not the insteadOf-transformed version)
                local current_url
                current_url=$(git config --get "remote.$remote.url" 2>/dev/null || continue)

                # Expand the URL
                local expanded_url
                expanded_url=$(manual_expand_url "$current_url")

                # Check if expansion changed the URL
                if [[ "$current_url" != "$expanded_url" ]]; then
                    print_info "Remote '$remote': $current_url -> $expanded_url"

                    # Update the remote URL
                    if git remote set-url "$remote" "$expanded_url"; then
                        print_success "Updated remote '$remote' URL"
                        changes_made=true
                    else
                        print_error "Failed to update remote '$remote' URL"
                    fi
                else
                    print_info "Remote '$remote': $current_url (no change needed)"
                fi
            fi
        done <<< "$remotes"

    if [[ "$changes_made" == true ]]; then
        print_success "Repository $repo_name: Remote URLs updated"
    else
        print_info "Repository $repo_name: No changes needed"
    fi

    return 0
}

# Function to find git repositories recursively
find_git_repos() {
    local search_path="$1"
    local max_depth="${2:-3}"  # Default max depth of 3

    find "$search_path" -maxdepth "$max_depth" -type d -name ".git" -exec dirname {} \; 2>/dev/null | sort
}

# Main function
main() {
    local target_path="${1:-.}"  # Default to current directory
    local dry_run=false
    local recursive=false
    local max_depth=3

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                cat << EOF
git-expand-remotes - Replace git insteadOf shortcuts with actual URLs

Usage: $0 [OPTIONS] [PATH]

OPTIONS:
    -h, --help      Show this help message
    -n, --dry-run   Show what would be changed without making changes
    -r, --recursive Search for git repositories recursively
    -d, --depth N   Maximum depth for recursive search (default: 3)

ARGUMENTS:
    PATH           Path to git repository or parent directory (default: current directory)

EXAMPLES:
    $0                         # Process current directory if it's a git repo
    $0 /path/to/repo           # Process specific repository
    $0 -r /path/to/workspace   # Process all git repos in workspace recursively
    $0 -n -r .                 # Dry run on all repos in current directory tree

This script expands git insteadOf URL shortcuts to their actual URLs for all remotes.
It can work on a single repository or recursively find and process multiple repositories.
EOF
                exit 0
                ;;
            -n|--dry-run)
                dry_run=true
                shift
                ;;
            -r|--recursive)
                recursive=true
                shift
                ;;
            -d|--depth)
                max_depth="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                exit 1
                ;;
            *)
                target_path="$1"
                shift
                ;;
        esac
    done

    # Validate target path
    if [[ ! -d "$target_path" ]]; then
        print_error "Directory does not exist: $target_path"
        exit 1
    fi

    # Convert to absolute path
    target_path=$(cd "$target_path" && pwd)

    print_info "Target path: $target_path"

    if [[ "$dry_run" == true ]]; then
        print_warning "DRY RUN MODE - No changes will be made"
        # For dry run, we would need to modify the process_git_repo function
        # This is left as an exercise, but the structure is here
    fi

    # Determine if we should process recursively or just the target
    if [[ "$recursive" == true ]]; then
        print_info "Searching for git repositories recursively (max depth: $max_depth)"

        local git_repos
        git_repos=$(find_git_repos "$target_path" "$max_depth")

        if [[ -z "$git_repos" ]]; then
            print_warning "No git repositories found in $target_path"
            exit 0
        fi

        local repo_count
        repo_count=$(echo "$git_repos" | wc -l)
        print_info "Found $repo_count git repositories"

        # Process each repository
        local original_pwd="$PWD"
        while IFS= read -r repo_path; do
            if [[ -n "$repo_path" ]]; then
                process_git_repo "$repo_path"
                echo  # Add blank line between repositories
            fi
        done <<< "$git_repos"

        cd "$original_pwd"
    else
        # Process single repository
        if is_git_repo || (cd "$target_path" && is_git_repo); then
            process_git_repo "$target_path"
        else
            print_error "Not a git repository: $target_path"
            print_info "Use --recursive option to search for git repositories in subdirectories"
            exit 1
        fi
    fi

    print_success "Script completed successfully"
}

# Run main function with all arguments
main "$@"
