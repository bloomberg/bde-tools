#!/bbs/opt/bin/perl -w
use strict;

use Cwd;
use Getopt::Long;
use FindBin;

use lib "$FindBin::Bin";
use lib "$FindBin::Bin/../lib/perl";
use lib "$FindBin::Bin/../lib/perl/site-perl";

use BDE::FileSystem::Make;
use BDE::Util::DependencyCache qw(
    getCachedGroup getCachedPackage
    getCachedGroupOrIsolatedPackage
    getAllPackageDependencies
    getAllGroupDependencies
);
use BDE::Util::Nomenclature qw(
    isNonCompliant isPackage isGroup
    isIsolatedPackage getPackageGroup
    getAllTypes getTypeName getTypeDir getType
);

use Build::Option::Factory;
use Build::Option::Finder;

use BDE::Build::Ufid;
use BDE::Build::Uplid;

use Util::File::Attribute qw(is_newer);
use Util::Message qw(debug verbose alert message warning fatal);
use Symbols qw[
    $PACKAGE_META_SUBDIR $GROUP_META_SUBDIR
    $DEPFILE_EXTENSION $MEMFILE_EXTENSION
    $DEFAULT_FILESYSTEM_ROOT
];
use Task::Action;
use Task::Manager;

#------------------------------------------------------------------------------

=head1 SYNOPSIS

    $ producemake

    $ producemake --force --echo --debug --strip --root=/my/source/dir \
                  --out=/my/outputdir --incdir=/my/includedir

=head1 DESCRIPTION

This script builds makefiles for the BDE libraries for use as the basis of the
production build. Without arguments, it will build makefiles for the default
list of groups. Use the -h option for a list of possible arguments.

=head1 AUTHOR

    Peter Wainwright (pwainwright@bloomberg.net)

=cut

#------------------------------------------------------------------------------

my $DEFAULT_OUTDIR = ".";
my $DEFAULT_LIBDIR = $DEFAULT_OUTDIR."/lib";
my $DEFAULT_INCDIR = $DEFAULT_OUTDIR."/include";

my %BDE_BUILD_TARGET_SPECS = (
      dbg    => "dbg|opt"
    , opt    => "opt|dbg"
    , mt     => "mt|-"
    , exc    => "exc|-"
    , ndebug => "ndebug|-"
    , pure   => "pure|-"
    , ins    => "ins|-"
    , shr    => "shr|-"
);

# NOTE: the default compiler and compiler versions listed here are used
# to generate the "-def" targets in %BDE_BUILD_PLATFORM_SPECS and are also
# used to generate COMPILERVERSION in the makefile itself so that the makefile
# knows how to derive the last two elements. This is because the makefile
# cannot make use of bde_uplid.pl to figure this out from the options file, and
# this info cannot be derived from uname
my %DEFAULT_COMPILER_VERSIONS = (
    AIX              => "10.1"
  , SunOS            => "5.9"
  , Windows          => "13.10"
  , Cygwin           => "3.4.1"
  , Linux            => "3.4.6"
  , HP_UX            => "6.2"
    );

# "-def" compiler versions come from the %DEFAULT_COMPILER_VERSIONS hash above.
my %BDE_BUILD_PLATFORM_SPECS = (
    "AIX-xlc-10.0"        => "unix-AIX-powerpc-6.1-xlc-10.0"
  , "AIX-def"        => "unix-AIX-powerpc-6.1-xlc-$DEFAULT_COMPILER_VERSIONS{AIX}"
  , "SunOS-cc-5.5"   => "unix-SunOS-sparc-5.10-cc-5.5"
  , "SunOS-def"      => "unix-SunOS-sparc-5.10-cc-$DEFAULT_COMPILER_VERSIONS{SunOS}"
  , "SunOS-gcc"      => "unix-SunOS-sparc-5.10-gcc-3.4.2"
  , "Windows-def"    => "windows-Windows_NT-x86-5.0-cl-$DEFAULT_COMPILER_VERSIONS{Windows}"
  , "Cygwin-def"     => "unix-Cygwin-x86-5.0-gcc-$DEFAULT_COMPILER_VERSIONS{Cygwin}"
  , "Linux-def"      => "unix-Linux-x86_64-2.6.9-gcc-$DEFAULT_COMPILER_VERSIONS{Linux}"
  , "HP_UX-def"      => "unix-HP_UX-ia64-B.11.31-acc-$DEFAULT_COMPILER_VERSIONS{HP_UX}"
);

my @DFL_BUILD_PLATFORM_SPECS = sort keys %BDE_BUILD_PLATFORM_SPECS;

my @DFL_BUILD_TARGET_SPECS = qw[dbg exc mt shr];
my @ALL_BUILD_TARGET_SPECS = sort keys %BDE_BUILD_TARGET_SPECS;

#------------------------------------------------------------------------------

my $LIB_SUBDIR               = "lib";
my $INCLUDE_SUBDIR           = "include";

my $LIBMACROSUFFIX           = "_LIBRARY";
my $INSTLIBMACROSUFFIX       = "_INSTLIB";
my $LINKLIBMACROSUFFIX       = "_LINKLIB";
my $OBJMACROSUFFIX           = "_OBJS";
my $ABSOBJMACROSUFFIX        = "_ABS_OBJS";
my $MHDRMACROSUFFIX          = "_MHDRS";
my $ALLMHDRMACROSUFFIX       = "_ALLMHDRS";
my $TSTOBJMACROSUFFIX        = "_TST_OBJS";
my $TSTBINMACROSUFFIX        = "_TST_BINS";
my $HDRMACROSUFFIX           = "_HDRS";
my $ABSHDRMACROSUFFIX        = "_ABS_HDRS";
my $INSTHDRMACROSUFFIX       = "_INSTHDRS";
my $INCMACROSUFFIX           = "_INCL";
my $LOCMACROSUFFIX           = "_LOCN";
my $BLOCMACROSUFFIX          = "_BLOC";
my $BLIBMACROSUFFIX          = "_BLIB";
my $BINCMACROSUFFIX          = "_BINC";
my $LIBDIRMACROSUFFIX        = "_LIBDIR";
my $INCDIRMACROSUFFIX        = "_INCDIR";
my $INSTLIBDIRMACROSUFFIX    = "_INSTLIBDIR";
my $INSTINCDIRMACROSUFFIX    = "_INSTINCDIR";
my $SUBDMACROSUFFIX          = "_SUBDIR";
my $WLDMACROSUFFIX           = "_WLD";
my $EXTRAMACROPREFIX         = "EXTRA_";

my $RULEINDENT               = "";

# in time these will be replaced with values from the .vars files
my $INCDIRFLAG               = "-I";
my $LIBDIRFLAG               = "-L";
my $LIBFLAG                  = "-l";

my $SEPARATOR                = "#".("=" x 78)."\n\n";

# default groups (and isolated packages) to build
my @DEFAULT_GROUPS           = qw(
   bsl bde bce bte bae
);
   #e_ipc e_nls
   #a_bdema a_bteso a_ossl

# capabilities replace this!
# # things that CAN be built non-mt for release
# my %BDE_BUILD_TARGET_NONMT_OK = map {$_=>1} qw(
#    bde bse a_bdema e_nls a_ossl
# );

#------------------------------------------------------------------------------

my $root;                       #filesystem root
my $finder;                     #filesystem root for option finding
my $factory;                    #option factory
my $options;                    #the currently constructed options
                                #(this will be redundant when factory caches)

#------------------------------------------------------------------------------

my %opts=(
    debug     => 0,
    native    => 1, #--nonative to switch off
    nmake     => 1, #--nonmake to switch off
    echo      => 1, #--noecho to switch off
    force     => 1, #--noforce to switch off
    verbose   => 0,
);

Getopt::Long::Configure("bundling");
unless (GetOptions(\%opts,qw[
            help|h
            debug|d+
            echo|e!
            force|f!
            groups|g=s
            native|n!
            nmake|N!
            root|r=s
            targets|t=s
            tests|T
            who|w=s
            outdir|o=s
            platforms|p=s
            incdir|i=s
            levels|L=s
            libdir|l=s
            strip|s!
            verbose|v
            xmk|extension|xm|x=s
            xnmk|xn|X=s
            xsum|xs|S=s
            xvars|xv|V=s
            xuniversal|makefile|xu|U=s
            ])) {
    usage(), exit 1;
}

$opts{help} and usage(),exit 0;

#------------------------------------------------------------------------------

Util::Message::set_debug($opts{debug}) if $opts{debug};
Util::Message::set_verbose($opts{verbose}) if $opts{verbose};

my $ROOT;
if ($opts{who} and not $opts{root}) {
   $ROOT            = "/view/$opts{who}/$DEFAULT_FILESYSTEM_ROOT";
} else {
   $ROOT            = $opts{root} || $DEFAULT_FILESYSTEM_ROOT;
}

unless ($ROOT eq ".") {
    chdir $ROOT or fatal "Unable to chdir to $ROOT: $!";
}
alert "started at root $ROOT";
$root=new BDE::FileSystem::Make(".");
$root->setRootLocation("."); #enforce relative
$finder=new Build::Option::Finder($root);
$factory=new Build::Option::Factory($finder);
alert "relative root is '$root'";

my $FORCE           = $opts{force}  || 0;
my $ECHO            = $opts{echo}   ? "" : "@";
my $OUTDIR          = $opts{outdir} || $DEFAULT_OUTDIR;
my $LIBDIR          = $opts{libdir} || $DEFAULT_LIBDIR;
my $INCDIR          = $opts{incdir} || $DEFAULT_INCDIR;

# remove tailing slash(es) if present
$OUTDIR=~s|/+$||;
# derive INC and LIB from OUT if it was specified and they were not
if ($opts{outdir}) {
    $LIBDIR=$OUTDIR."/lib" unless $opts{libdir};
    $INCDIR=$OUTDIR."/include" unless $opts{incdir};
}

if ($LIBDIR!~m|^/|) {
    $LIBDIR = "\$(ROOT${LOCMACROSUFFIX})/$LIBDIR";
    $LIBDIR =~ s|/[^/]+/\.\./|/|sg;
    $LIBDIR =~ s|/\./|/|sg;
}
if ($INCDIR!~m|^/|) {
    $INCDIR = "\$(ROOT${LOCMACROSUFFIX})/$INCDIR";
    $INCDIR =~ s|/[^/]+/\.\./|/|sg;
    $INCDIR =~ s|/\./|/|sg;
}

my $STRIP                    = $opts{strip};

# levels
$opts{levels}="upgv" unless $opts{levels};
if ($opts{levels}=~/([a-bd-fh-oq-tw-z\d])/i) {
    die "Illegal level '$1' specified: legal values are u, g, p, c and v.\n";
}
my $MAKE_UNIVERSAL = $opts{levels} =~ /u/i;
my $MAKE_GROUPS    = $opts{levels} =~ /g/i;
my $MAKE_PACKAGES  = $opts{levels} =~ /p/i;
my $MAKE_VARS      = $opts{levels} =~ /v/i;
my $MAKE_CHECKSUMS = $opts{levels} =~ /c/i;

# groups
my @groups;
@groups = split /\W/,$opts{groups} if $opts{groups};
push @groups,@ARGV if @ARGV;
@groups = @DEFAULT_GROUPS unless @groups;

# targets
my @platform_specs;
@platform_specs = split /[^\w_\.-]/,$opts{platforms} if $opts{platforms};
@platform_specs = @DFL_BUILD_PLATFORM_SPECS unless @platform_specs;
foreach (@platform_specs) {
    # map shorthand (e.g. 'AIX' or 'AIX-def') to platform
    # anything else is passed through as a raw UPLID (for now)
    if (exists $BDE_BUILD_PLATFORM_SPECS{$_}) {
        $_ = $BDE_BUILD_PLATFORM_SPECS{$_};
    } elsif (exists $BDE_BUILD_PLATFORM_SPECS{"${_}-def"}) {
        $_ = $BDE_BUILD_PLATFORM_SPECS{"${_}-def"};
    }
}

my %BDE_BUILD_TARGET_FLAGS = (
    opt    => "-DBDE_BUILD_TARGET_OPT",
    dbg    => "-DBDE_BUILD_TARGET_DBG",
    shr    => "-DBDE_BUILD_TARGET_SHR",
    exc    => "-DBDE_BUILD_TARGET_EXC",
    mt     => "-DBDE_BUILD_TARGET_MT",
    ndebug => "-DBDE_BUILD_TARGET_NDEBUG",
    64     => "-DBDE_BUILD_TARGET_64",
);

# specs
my (@target_specs,@required_specs);
@target_specs = split /[^\w+]/,$opts{targets} if $opts{targets};
@target_specs = @DFL_BUILD_TARGET_SPECS unless @target_specs;
@target_specs = map { s/^\+// and push @required_specs,$_; $_ } @target_specs;

# file extensions
if ($opts{xmk}) {
  $BDE::FileSystem::Make::MAKEFILE_EXTENSION=$opts{xmk};
}
if ($opts{xnmk}) {
  $BDE::FileSystem::Make::NMAKEFILE_EXTENSION=$opts{xnmk};
} elsif ($opts{xmk}) {
  $BDE::FileSystem::Make::NMAKEFILE_EXTENSION=$opts{xnmk}='n'.$opts{xmk};
}
if ($opts{xvars}) {
  $BDE::FileSystem::Make::MAKEVARS_EXTENSION=$opts{xvars};
}
if ($opts{xuniversal}) {
  $BDE::FileSystem::Make::UNIVERSAL_MAKEFILE=$opts{xuniversal};
}
my ($MK,$NMK,$VARS,$SUM)=(
  $BDE::FileSystem::Make::MAKEFILE_EXTENSION,
  $BDE::FileSystem::Make::NMAKEFILE_EXTENSION,
  $BDE::FileSystem::Make::MAKEVARS_EXTENSION,
  $opts{xsum} || 'sum', #not handled by BDE::FileSystem::Make
);

#-- Nmake/Gmake --

use constant MAKE_GMAKE => $BDE::FileSystem::MakeType::GMAKE;
use constant MAKE_NMAKE => $BDE::FileSystem::MakeType::NMAKE;

#PP   = preprocessor prefix: ! for Nmake, none for Gmake
#SM   = substitution marker: % for Gmake, Nmake supports dumber substitutions
#EQ   = static assignment: := for Gmake, Nmake doesn't have this
#DM   = dependencies macro for current target: $^ for Gmake, $** for Nmake
#FS   = file separator: / for Gmake, \ for Nmake
#OB   = object suffix: .o for Gmake, __obj for Nmake
#       (can't use macro expansion in subst, multiple .s confuse Nmake)
#FSRE = file separator, escaped for regexing. See also BDE::Build::Invocation.
my ($PP,$SM,$EQ,$DM,$FS,$OB,$OO,$FSRE);

sub dedupeLines
{
    my $line_r = shift;
    my %seen;

    # only suppress duped lines if the line
    #     1) contains a variable definition
    # and 2) doesn't end in a backslash
    $$line_r =~ s|^(\w+=.*[^\\])$|(($seen{$1}++)&&(-1 == index $1,"endif"))?"":$1|egm;
}

sub set_make_syntax ($) {
    my $root=shift;

    if ($root->isMakeType(MAKE_NMAKE)) {
        $PP="!"; $SM="";  $EQ="=";  $DM="\$**";
        $FS="\\"; $OB="__obj"; $OO="/opt:";
        $FSRE="\\\\";
    } elsif (is_make_type(MAKE_GMAKE)) {
        $PP="";  $SM="%"; $EQ=":="; $DM="\$^";
        $FS="/"; $OB=".o"; $OO="-o ";
        $FSRE="/";
    } else {
        fatal "Unknown make type";
    }
}

sub set_make_type ($$) {
    my ($root,$type)=@_;
    $root->setMakeType($type);
    set_make_syntax($root);
}

sub is_make_type ($) {
    return ($root->isMakeType(shift))?1:0;
}

#------------------------------------------------------------------------------

sub usage {
local $"=',';
my $prog=$0; $prog=~m|/([^/]+)$| and $prog=$1;

print <<EOF
Usage: $prog [-h] [-d] [-v] [-f] [-e] [-r=<root dir>] [-w=<who>] [o=<out dir>]

  --help       | -h           print usage information (this help)
  --debug      | -d           enable debug messages
  --verbose    | -v           enable verbose messages

Input locations:

  --root       | -r <dir>     build root ($DEFAULT_FILESYSTEM_ROOT)
  --who        | -w           build in view (only if --root not specified)

Makefile targets:

  --groups     | -g <groups>  group makefiles to generate (@DEFAULT_GROUPS)
  --levels     | -L <ugpcv>   generate only specified makefile levels:
                                u=universal g=groups p=packages, additionally
                                c=checksums (.sum) files  (g)
                                v=variables (.vars) files (g & p)
                              (default: ugv (universal and group with .vars))
  --targets    | -t <targets> build targets to generate
                              (default: @DFL_BUILD_TARGET_SPECS)
                              (possible: @ALL_BUILD_TARGET_SPECS)
                              if the targets include underscores, the
                              list is assumed to be explicit, otherwise
                              the reasonable combinations of targets are
                              generated (i.e. dbg,exc => dbg, exc, dbg_exc)

Makefile generation options:

  --[no]echo   | -e           [do not] create rules with echoing commands
  --[no]force  | -f           [do not] force regeneration of all makefiles
  --[no]native | -n           [do not] incorporate production makefile elements
  --[no]nmake  | -N           [do not] generate additional nmake makefile
  --[no]strip  | -s           [do not] strip out detailed descriptive comments
  --[no]tests  | -T           [do not] generate rules to build test drivers

Output names and locations:

  --outdir     | -o <dir>     output root directory ($DEFAULT_OUTDIR)
  --libdir     | -l <dir>     output library directory (<outdir>/lib)
  --incdir     | -i <dir>     output include directory (<outdir>/include)
  --xmk        | -x <ext>     change makefile extension (.mk)
  --xnmk       | -X <ext>     change nmakefile extension (.nmk)
  --xvars      | -V <ext>     change varsfile extension (.vars)
  --xuniversal | -U <ext>     change Universal makefile name (Makefile)

EOF
}

#------------------------------------------------------------------------------
# Inputs

sub getBuildVariables ($$;$) {
    my ($where,$target,$uplid)=@_;

    my $options = $factory->construct({
        uplid => $uplid,
        ufid  => BDE::Build::Ufid->new($target),
        what  => $where,
    });

    my $prefix=ucmacro($where)."_".ucmacro($target)."_";
    my $optstr = $options->render($prefix);

    # redirection for compiler paths
    my $compiler = $uplid->{compiler};
    $optstr =~ s/(${target}_cc=.*?)(\S*${compiler}[^\s)]*)\s/$1 \$\(CC_CMD\) /img;
                                    # change the C compiler to CC_CMD
    $optstr .= "PLATFORM_CC=$2\n";  # append the original value

    $optstr =~ s/(${target}_cxx=.*?)(\S*${compiler}[^\s)]*)\s/$1 \$\(CXX_CMD\) /img;
                                    # change the C++ compiler to CXX_CMD
    $optstr .= "PLATFORM_CXX=$2\n"; # append the original value

    #remove prefixes for 'SET_' macros, unless it's SET_TEMPLATE_CACHE_DIR
    $optstr =~ s|\$\([\w+]+_SET_(?!TEMPLATE_CACHE_DIR)|\$\(SET_|mg; #uses
    $optstr =~ s|^[\w+]+_SET_(?!TEMPLATE_CACHE_DIR)|SET_|mg; #definitions

    # bsl+stlport/stlport hack 1/5
    $optstr =~ s[STL_INCLUDE\s*=\s*.*/([^/]+)$]
                [STL_INCLUDE = -I\$(BSL_LOCN)/bsl+stlport/$1]mg;

    #sort-of general rule, disabled, see above.
    #$optstr =~ s|/include/(\w+(\+\w+)?)/\$\(UPLID\)/\$\(UFID\)/|/|mg;

    # we don't supply the retry wrapper, so remove it
    $optstr =~ s|\$\([\w+]+RETRY\w*\)||mg; #uses
    $optstr =~ s|^[\w+]+RETRY\w*\s*=.*$||mg;   #definitions

    # or the test drivers
    #$optstr =~ s|^[\w+]+ALLTEST\w*\s*=.*$||mg; #definitions

    # or serialize, which isn't needed in this makefile in any case
    $optstr =~ s|\$\([\w+]+SERIALIZE\w*\)||mg; #uses
    $optstr =~ s|^[\w+]+SERIALIZE\w*\s*=.*$||mg;   #definitions

    #UPLID is called PLATFORM here. This should be converged to UPLID
    $optstr =~ s|\$\(UPLID\)|\$\(PLATFORM\)|;
    #make explicit references to UFID hardwired
    $optstr =~ s|\$\(UFID\)|$target|;

    # remove prefixes for RSYNC - we want one unified variable to override
    $optstr =~ s|\w+RSYNC|RSYNC|g;

    # remove prefixes for XLC_LOCATION - it will reduce the dupes of PLATFORM_CC/CXX
    $optstr =~ s|\w+_XLC_LOCATION|XLC_LOCATION|g;

    # deal with ::GROUP::
    my $GROUP = uc (getPackageGroup($where) or $where);
    $optstr =~ s|::GROUP::|$GROUP|g;

    # zap multiple blank lines
    $optstr =~ s|\n{2,}|\n|sg;

    return $optstr;
}

sub getExtraPackageDir($) {
    my ($package)=@_;

    return undef unless isNonCompliant($package);
    my $macro=ucmacro($package);

    my $subdir=undef;

    # retrive from raw set, dimensions should not apply
    if ($subdir=$factory->getValueSet()->getValue($macro."_DIR")) {
        debug("Retrieved extra dir $subdir for $package");
    }

    return $subdir;
}

{
    my %cache=();   # full nufids
    my %libcache=(); # library nufids

    sub getNormalisedTarget ($;$) {
        my $ufid=shift;
        my $is_lib=shift;

        if ($is_lib) {
            return $libcache{$ufid} if exists $libcache{$ufid};
        } else {
            return $cache{$ufid} if exists $cache{$ufid};
        }

        my $uo=new BDE::Build::Ufid($ufid);
        fatal "Not a valid ufid: $ufid" unless defined $uo;

        my $result=$uo->toString($is_lib?0:1);
        if ($is_lib) {
            $libcache{$ufid}=$result;
        } else {
            $cache{$ufid}=$result;
        }

        return $result;
    }
}

#------------------------------------------------------------------------------
# Makefile generation

sub ucmacro ($) {
    my $str=shift;

    fatal "No argument" unless defined $str;

    $str=~tr/+=/_/;
    return uc($str);
}

sub generateGenericTarget ($@) {
    my ($target,@subtargets)=@_;

    return "${RULEINDENT}$target: ".join(' ',map {
        "$_.$target"
    } @subtargets)."\n";
}

sub generateGenericTargets {
    my @subtargets=@_;

    my @targets=qw[
        all build
        install installlib installhdr
        uninstall uninstalllib uninstallhdr
        checksum verify
        clean distclean realclean
        ];
    push @targets,"mhdr","cleanmhdr" if is_make_type(MAKE_NMAKE);
    push @targets,"buildtests" if $opts{tests};

    my $maketext.="# Generic targets\n";
    $maketext.="${PP}ifndef BDEMAKE_GENERIC_TARGETS\n";
    $maketext.="  BDEMAKE_GENERIC_TARGETS = 1\n";
    $maketext.="\n";
    unless (is_make_type(MAKE_NMAKE)) {
        $maketext.=".PHONY: @targets\n";
        $maketext.="\n";
    }

    foreach (@targets) {
        $maketext.=generateGenericTarget($_,@subtargets);
        $maketext.="\n";
    }

    $maketext.="${PP}endif\n";

    return $maketext;
}

sub generateBuildTypes () {
    my $maketext="";

    my $default_type=$opts{native}?"STANDALONE":"PRODUCTION";

    my $buildtype_test=(is_make_type(MAKE_NMAKE))
      ? qq[if "\$(BUILD)" == "PRODUCTION"]
      : qq[ifeq (\$(BUILD),PRODUCTION)];

    $maketext=<<_GENERATE_BUILD_TYPES;
# Build type (PRODUCTION or STANDALONE)
${PP}ifndef BUILD
  BUILD = $default_type
${PP}endif
${PP}${buildtype_test}
${PP}  ifndef BDEMAKE_INCLUDED_BB
${PP}    MKINCL?=/bbsrc/mkincludes/
${PP}    include \$(MKINCL)bbmkvars.mk
  SUN_SPECIFIC_CPP_FLAGS=
  BDEMAKE_INCLUDED_BB = 1
${PP}  endif

  COMMAND_PRE =
  COMMAND_POST =
  AS_COMMAND_POST =
  CC_COMMAND_POST = \$<
  NC_COMMAND_POST = \$<
${PP}else
  COMMAND_PRE =
  CC_COMMAND_POST = \$< -c
  NC_COMMAND_POST = \$<
${PP}endif

# Set compilers
${PP}ifndef CC_CMD
  CC_CMD = \$(PLATFORM_CC)
${PP}endif
${PP}ifndef CXX_CMD
  CXX_CMD = \$(PLATFORM_CXX)
${PP}endif

# Assign dependencies to \$(OBJS) for archive stages
${PP}ifndef OBJS
  OBJS = $DM
${PP}endif
_GENERATE_BUILD_TYPES
}

sub generatePlatformID {
    my $plid="";

    if (is_make_type(MAKE_NMAKE)) {
$plid=<<_GENERATE_NMAKE_PLATFORM_ID;
# Platform
${PP}ifndef FAMILY
  FAMILY ${EQ} windows
${PP}endif
${PP}ifndef OS
  OS ${EQ} Windows_NT
${PP}endif
${PP}ifndef ARCHITECTURE
  ARCHITECTURE ${EQ} x86
${PP}endif
${PP}ifndef OSVERSION
  OSVERSION ${EQ} 5.0
${PP}endif
${PP}ifndef COMPILER
  COMPILER ${EQ} cl
${PP}endif
${PP}ifndef COMPILERVERSION
  COMPILERVERSION ${EQ} $DEFAULT_COMPILER_VERSIONS{Windows}
${PP}endif
_GENERATE_NMAKE_PLATFORM_ID
    } else {
$plid=<<_GENERATE_GMAKE_PLATFORM_ID;
# Platform
${PP}ifndef FAMILY
  FAMILY ${EQ} unix
${PP}endif
${PP}ifndef OS
  OS ${EQ} \$(strip \$(shell uname))
${PP}  ifeq (\$(OS),HP-UX)
    OS ${EQ} HP_UX
${PP}  else
${PP}    ifeq (\$(OS),CYGWIN_NT-5.0)
    OS ${EQ} Cygwin
${PP}    endif
${PP}  endif
${PP}endif
${PP}ifndef ARCHITECTURE
${PP}  ifeq (\$(OS),Linux)
    ARCHITECTURE ${EQ} \$(strip \$(shell uname -m))
${PP}  else
${PP}    ifeq (\$(OS),HP_UX)
    ARCHITECTURE ${EQ} \$(strip \$(shell uname -m))
${PP}    else
${PP}      ifeq (\$(OS),dgux)
    ARCHITECTURE ${EQ} x86
${PP}        else
${PP}          ifeq (\$(OS),Linux)
    ARCHITECTURE ${EQ} \$(strip \$(shell uname -m))
${PP}          else
    ARCHITECTURE ${EQ} \$(strip \$(shell uname -p))
${PP}        endif
${PP}      endif
${PP}    endif
${PP}  endif
${PP}endif
${PP}ifndef OSVERSION
${PP}  ifeq (\$(OS),AIX)
    OSVERSION ${EQ} \$(strip \$(shell uname -v)).\$(strip \$(shell uname -r))
${PP}  else
    OSVERSION ${EQ} \$(strip \$(shell uname -r))
${PP}  endif
${PP}endif
${PP}ifndef COMPILER
${PP}  ifeq (\$(OS),AIX)
    COMPILER = xlc
    COMPILERVERSION = $DEFAULT_COMPILER_VERSIONS{AIX}
${PP}  else
${PP}    ifeq (\$(OS),HP_UX)
    COMPILER = acc
    COMPILERVERSION = $DEFAULT_COMPILER_VERSIONS{HP_UX}
${PP}    else
${PP}      ifeq (\$(OS),SunOS)
    COMPILER = cc
    COMPILERVERSION = $DEFAULT_COMPILER_VERSIONS{SunOS}
${PP}      else
${PP}        ifeq (\$(OS),Cygwin)
    COMPILER = gcc
    COMPILERVERSION = $DEFAULT_COMPILER_VERSIONS{Cygwin}
    OS = Cygwin
${PP}        else
${PP}          ifeq (\$(OS),Linux)
    COMPILER = gcc
    COMPILERVERSION = $DEFAULT_COMPILER_VERSIONS{Linux}
${PP}          else
    COMPILER = NONSUCH
    COMPILERVERSION = X
${PP}          endif
${PP}        endif
${PP}      endif
${PP}    endif
${PP}  endif
${PP}endif
_GENERATE_GMAKE_PLATFORM_ID
    }

$plid.=<<_GENERATE_COMMON_PLATFORM_ID;
${PP}ifndef PLATFORM
  PLATFORM ${EQ} \$(FAMILY)-\$(OS)-\$(ARCHITECTURE)-\$(OSVERSION)-\$(COMPILER)-\$(COMPILERVERSION)
${PP}endif
_GENERATE_COMMON_PLATFORM_ID

    return $plid;
}

sub generateGroupLocations ($) {
    my $group=shift;
    my $prefix=uc getTypeName(getType $group);
    my $maketext="";

    my $isgroupedpackage=0;
    if (isPackage($group) and !isIsolatedPackage($group)) {
        $isgroupedpackage=1;
        $group=getPackageGroup($group);
    }
    my $GROUP=ucmacro($group);

    my $root_locn=$root->getRootLocationFromGoP($group);
    if ($root_locn=~/^\.\./) {
        $root_locn.=$FS.".."; #plus one for the 'group subdirectory
    }

    $maketext.="# Locations for '$group'\n";
    $maketext.="${PP}ifndef ROOT${LOCMACROSUFFIX}\n";
    $maketext.="  ROOT${LOCMACROSUFFIX} = $root_locn\n";
    $maketext.="${PP}endif\n";

    foreach my $type (getAllTypes) {
        my $tprefix=uc(getTypeName $type);
        my $type_locn=$root->getOtherTypeLocationFromType(getType($group) => $type);

        my $type_subdir="";
        if ($type_locn=~m|^$root_locn/(.*)$|) {
            $type_locn="\$(ROOT${LOCMACROSUFFIX})/$1";
            $type_subdir = $1;
        } else {
            $type_subdir = $root->getTypeSubdir($type);
        }

        $maketext.="${PP}ifndef ${tprefix}${SUBDMACROSUFFIX}\n";
        $maketext.="  ${tprefix}${SUBDMACROSUFFIX} = $type_subdir\n";
        $maketext.="${PP}endif\n";
        $maketext.="${PP}ifndef ${tprefix}${LOCMACROSUFFIX}\n";
        $maketext.="${PP}  ifdef ${tprefix}${SUBDMACROSUFFIX}\n";
        $maketext.="    ${tprefix}${LOCMACROSUFFIX} = "
            ."\$(ROOT${LOCMACROSUFFIX})/\$(${tprefix}${SUBDMACROSUFFIX})\n";
        $maketext.="${PP}  else\n";
        $maketext.="    ${tprefix}${LOCMACROSUFFIX} = $type_locn\n";
        $maketext.="${PP}  endif\n";
        $maketext.="${PP}endif\n";
    }

    #>>>compatibility - remove when all GROUPS macros have been replaced by BASE
    $maketext.="${PP}ifndef GROUPS${SUBDMACROSUFFIX}\n";
    $maketext.="  GROUPS${SUBDMACROSUFFIX} = \$(BASE${SUBDMACROSUFFIX})\n";
    $maketext.="${PP}endif\n";
    $maketext.="${PP}ifndef GROUPS${LOCMACROSUFFIX}\n";
    $maketext.="  GROUPS${LOCMACROSUFFIX} = "
              ."\$(ROOT${LOCMACROSUFFIX})/\$(GROUPS${SUBDMACROSUFFIX})\n";
    $maketext.="${PP}endif\n";
    #<<<compatibility

    $maketext.="${PP}ifndef ${GROUP}${LOCMACROSUFFIX}\n";
    $maketext.="  ${GROUP}${LOCMACROSUFFIX} = "
              ."\$(${prefix}${LOCMACROSUFFIX})/${group}\n";
    $maketext.="${PP}endif\n";

    $maketext.="${PP}ifndef ${GROUP}${LIBDIRMACROSUFFIX}\n";
    $maketext.="${PP}  ifdef INSTALL${LIBDIRMACROSUFFIX}\n";
    $maketext.="    ${GROUP}${LIBDIRMACROSUFFIX} = "
              ."\$(INSTALL${LIBDIRMACROSUFFIX})\n";
    $maketext.="${PP}  else\n";
    $maketext.="    ${GROUP}${LIBDIRMACROSUFFIX} = $LIBDIR\n";
    $maketext.="${PP}  endif\n";
    $maketext.="${PP}endif\n";

    $maketext.="${PP}ifndef ${GROUP}${INCDIRMACROSUFFIX}\n";
    $maketext.="${PP}  ifdef INSTALL${INCDIRMACROSUFFIX}\n";
    $maketext.="    ${GROUP}${INCDIRMACROSUFFIX} = "
              ."\$(INSTALL${INCDIRMACROSUFFIX})\n";
    $maketext.="${PP}  else\n";
    $maketext.="    ${GROUP}${INCDIRMACROSUFFIX} = $INCDIR\n";
    $maketext.="${PP}  endif\n";
    $maketext.="${PP}endif\n";

    return $maketext;
}

sub generateGroupPreamble ($) {
    my $group=shift;

    my @group_dependants=$group->getDependants();
    my @group_members=$group->getMembers();
    my @list_dependants = @group_dependants ? @group_dependants : ('*none*');
    my $maketext="";

    $maketext.="# ".(is_make_type(MAKE_NMAKE)?"NMake ":"").
                 "Makefile for '$group'\n".
               "# * This file is machine generated *\n";
               #"# Created: ".localtime(time)."\n";
    unless ($STRIP) {
        $maketext.="# Dependants:\n".
                    join("\n",map { "#    $_" } @list_dependants)."\n".
                    "# Members:\n".
                    join("\n",map { "#    $_" } @group_members)."\n";
    }

    return $maketext;
}

sub generateGroupInstallLocations ($) {
    my $group=shift;
    my $maketext="";

    my $isgroupedpackage=0;
    if (isPackage($group) and !isIsolatedPackage($group)) {
        $isgroupedpackage=1;
        $group=getPackageGroup($group);
    }
    my $GROUP=ucmacro($group);

    # group library install directory is library install directory + platform
    $maketext.="${PP}ifndef ${GROUP}${INSTLIBDIRMACROSUFFIX}\n";
    $maketext.="  ${GROUP}${INSTLIBDIRMACROSUFFIX} ${EQ} "
              ."\$(${GROUP}${LIBDIRMACROSUFFIX})/\$(PLATFORM)\n";
    $maketext.="${PP}endif\n";
    # group header install directory is header install directory + group
    $maketext.="${PP}ifndef ${GROUP}${INSTINCDIRMACROSUFFIX}\n";
    $maketext.="  ${GROUP}${INSTINCDIRMACROSUFFIX} ${EQ} "
              ."\$(${GROUP}${INCDIRMACROSUFFIX})/$group\n";
    $maketext.="${PP}endif\n";

    return $maketext;
}

sub generateDependentGroupTargets (@) {
    my @group_dependants=@_;

    my $extension=(is_make_type(MAKE_NMAKE))?
      $BDE::FileSystem::Make::NMAKEFILE_EXTENSION :
      $BDE::FileSystem::Make::MAKEFILE_EXTENSION;

    my $maketext="";
    if (@group_dependants) {
        $maketext.="# Dependent package groups\n";
        foreach (@group_dependants) {
            my $uor=getCachedGroupOrIsolatedPackage($_);
            if ($uor->isMetadataOnly) {
                $maketext.="# Dependency $_ is metadata-only\n";
            } else {
                my $tprefix=uc getTypeName(getType $_);
                my $metadir=isPackage($_)?$PACKAGE_META_SUBDIR:$GROUP_META_SUBDIR;
                my $GD=ucmacro($_);

                $maketext.="${PP}ifndef BDEMAKE_INCLUDED_".$GD."_GROUP\n";
                $maketext.="  BDEMAKE_INCLUDED_".$GD."_GROUP = 1\n";
                $maketext.="${PP}  include \$(${tprefix}${LOCMACROSUFFIX})/"
                    ."$_/${metadir}/$_.${extension}\n";
                $maketext.="${PP}endif\n";
            }
        }
    }

    return $maketext;
}

#----

sub generateDistributionTargets ($@) {
    my ($is_universal,@groups)=@_;

    # we don't support this under Nmake (for now)
    return "" if is_make_type(MAKE_NMAKE);

    my $maketext="";
    my @GROUPS=map { ucmacro($_) } @groups;
    my @metadirs=map { isPackage($_)?$PACKAGE_META_SUBDIR:$GROUP_META_SUBDIR } @groups;
    my $tgt=$is_universal?"":"$groups[0].";
    my $msgtgt=$is_universal?"":"$groups[0] ";
    my $TGT=$is_universal?"ALL":$GROUPS[0];

    $maketext.="${PP}ifndef RELDIR\n";
    $maketext.="  CWD         ${EQ} \$(shell (cd \$(ROOT${LOCMACROSUFFIX}) && pwd))\n";
    $maketext.="  RELDIR      ${EQ} \$(shell test -d \$(GROUPS${LOCMACROSUFFIX})/releases && echo '\$(GROUPS${LOCMACROSUFFIX})/releases/BLP_LIB_BDE/')\n";
    $maketext.="${PP}  ifndef RELDIR\n";
    $maketext.="    RELDIR = \$(CWD)/\n";
    $maketext.="${PP}  endif\n";
    $maketext.="  RELFILES    ${EQ} Makefile Makefile.$NMK MANIFEST README README.INSTALL examples/Makefile examples/Makefile.$NMK examples/*.c* README.EXAMPLES README.PLATFORMS VERSION\n";
    $maketext.="  ABSRELFILES ${EQ} \$(RELFILES:%=\$(RELDIR)%)\n";
    $maketext.="  VERSION     ${EQ} \$(shell cat \$(RELDIR)VERSION)\n";
    $maketext.="  VERRELFILES ${EQ} \$(RELFILES:%=\$(VERSION)/%)\n";
    $maketext.="${PP}endif\n";
    $maketext.="\n";

    unless (is_make_type(MAKE_NMAKE)) {
        $maketext.=".PHONY: ${tgt}version ${tgt}dist ${tgt}srcdist ${tgt}bindist\n";
        $maketext.="\n";
    }

    if ($is_universal) {
        $maketext.="version: ".join(' ',map { "${_}.version" } @groups)."\n";
        $maketext.="\t\@echo release \$(VERSION)\n";
    } else {
        my $GROUP=$GROUPS[0];
        my $SGROUP=substr $GROUP,-3,3;
        my $group=$groups[0];
        my $metadir=$metadirs[0];

        # compute the version number
        $maketext.="${PP}ifndef ${GROUP}_MAJOR\n";
        $maketext.="  ${GROUP}_MAJOR ${EQ} \$(shell perl -ne '/BLP_[A-Z]{3}_BDE_${SGROUP}_(\\d+)\\.(\\d+)\.(\\d+)/ and print \$\$1' \$(RELDIR)MANIFEST)\n";
        $maketext.="  ${GROUP}_MINOR ${EQ} \$(shell perl -ne '/BLP_[A-Z]{3}_BDE_${SGROUP}_(\\d+)\\.(\\d+)\.(\\d+)/ and print \$\$2' \$(RELDIR)MANIFEST)\n";
        $maketext.="  ${GROUP}_PATCH ${EQ} \$(shell perl -ne '/BLP_[A-Z]{3}_BDE_${SGROUP}_(\\d+)\\.(\\d+)\.(\\d+)/ and print \$\$3' \$(RELDIR)MANIFEST)\n";
        $maketext.="\n";
        $maketext.="${group}.version:\n";
        $maketext.="\t\@echo ${group} version \$(${GROUP}_MAJOR).\$(${GROUP}_MINOR).\$(${GROUP}_PATCH)\n";
        $maketext.="${PP}endif\n";

        # primary file macro - makefiles
        $maketext.="${GROUP}_MKDISTFILES ${EQ} ".
            "${metadir}/${group}.$MK ${metadir}/${group}.$NMK ${metadir}/${group}.*.$VARS\n";
        # primary file macro - checksummed sources. Although all sources get
        # snagged, the makefile only builds the ones named by the member files
        $maketext.="${GROUP}_SRCDISTFILES_NOSUM ${EQ} ".
            "${group}*/${group}*[a-z0-9][a-z0-9].c* ".
            "${group}*/${group}*.[hs] ".
            (($group eq "bde") ?
             " bde+pcre/*.c* bde+pcre/*.h ":"" #prce shouldn't need a hack, revisit
            ).
            (($group eq "bsl") ?  # bsl+stlport/stlport hack 2/5
             " bsl+stlport/*.c* bsl+stlport/*.h bsl+stlport/c_locale*/*.* " : ""
            ).
            (isIsolatedPackage($group)?"":"${group}scm/${group}scm_properties.rc ").
            "\$(${GROUP}_MKDISTFILES)\n";
        # secondary file macro - checksummed sources plus those we don't sum
        $maketext.="${GROUP}_SRCDISTFILES    ${EQ} ".
            "\$(${GROUP}_SRCDISTFILES_NOSUM) ".
            "${metadir}/${group}.$SUM ".
            (($group eq "bsl")?"bsl+stlport/stlport ":""). # bsl+stlport/stlport hack 3/5
            "\n";

        #derived file macros
        $maketext.="${GROUP}_ABSMKDISTFILES  ${EQ} \$(${GROUP}_MKDISTFILES:%=\$(${GROUP}${LOCMACROSUFFIX})/%)\n";
        $maketext.="${GROUP}_ABSSRCDISTFILES_NOSUM ${EQ} \$(${GROUP}_SRCDISTFILES_NOSUM:%=\$(${GROUP}${LOCMACROSUFFIX})/%)\n";
        $maketext.="${GROUP}_ABSSRCDISTFILES ${EQ} \$(${GROUP}_SRCDISTFILES:%=\$(${GROUP}${LOCMACROSUFFIX})/%)\n";
        $maketext.="${GROUP}_VERMKDISTFILES  ${EQ} \$(${GROUP}_MKDISTFILES:%=\$(VERSION)/".$root->getTypeSubdir(getType $group)."/${group}/%)\n";
        $maketext.="${GROUP}_VERSRCDISTFILES ${EQ} \$(${GROUP}_SRCDISTFILES:%=\$(VERSION)/".$root->getTypeSubdir(getType $group)."/${group}/%)\n";
        $maketext.="\n";
        $maketext.="${GROUP}_BINDISTFILES = \$(${GROUP}${INSTLIBMACROSUFFIX}) \$(${GROUP}${INSTHDRMACROSUFFIX}) \n";
    }
    $maketext.="\n";

    # binary distribution
    $maketext.="${tgt}bindist: \$(ROOT${LOCMACROSUFFIX})/${tgt}\$(VERSION).\$(PLATFORM).tar.gz\n";
    $maketext.="\n";
    $maketext.="\$(ROOT${LOCMACROSUFFIX})/".
                 "${tgt}\$(VERSION).\$(PLATFORM).tar.gz: \$(ABSRELFILES) ".
                 join(' ', map { "\$(${_}_BINDISTFILES)" } @GROUPS)." ".
                 join(' ', map { "\$(${_}_ABSMKDISTFILES)" } @GROUPS)."\n";
    $maketext.="\t${ECHO}(cd \$(RELDIR) ".
               "&& rm -f \$(VERSION) ".
               "&& ln -s . \$(VERSION) ".
               "&& tar cvf \$(CWD)/${tgt}\$(VERSION).\$(PLATFORM).tar ".
               "\$(VERRELFILES) ".
               "&& rm -f \$(VERSION))\n";
    foreach my $GROUP (@GROUPS) {
        my $group=lc($GROUP);
        $maketext.="\t${ECHO}(cd \$(${GROUP}${LIBDIRMACROSUFFIX})/.. ".
            "&& rm -f \$(VERSION) ".
            "&& ln -s . \$(VERSION) ".
            "&& tar rvf \$(CWD)/${tgt}\$(VERSION).\$(PLATFORM).tar ".
            "\$(VERSION)/lib/\$(PLATFORM)/lib${group}.* ".
            "&& rm -f \$(VERSION))\n";
        $maketext.="\t${ECHO}(cd \$(${GROUP}${INCDIRMACROSUFFIX})/.. ".
            "&& rm -f \$(VERSION) ".
            "&& ln -s . \$(VERSION) ".
            "&& tar rvf \$(CWD)/${tgt}\$(VERSION).\$(PLATFORM).tar ".
            "\$(VERSION)/include/${group}/*.h ". #not ${group}*.h due to stlp
            "&& rm -f \$(VERSION))\n";
        $maketext.="\t${ECHO}(cd \$(ROOT${LOCMACROSUFFIX}) ".
            "&& rm -f \$(VERSION) ".
            "&& ln -s . \$(VERSION) ".
            "&& tar rvf \$(CWD)/${tgt}\$(VERSION).\$(PLATFORM).tar ".
            "\$(${GROUP}_VERMKDISTFILES) ".
            "&& rm -f \$(VERSION))\n";
        if ($group eq "bsl") {
            # bsl+stlport/stlport hack 4/5
            $maketext.="\t${ECHO}(cd \$(ROOT${LOCMACROSUFFIX}) ".
                "&& rm -f \$(VERSION) ".
                "&& ln -s . \$(VERSION) ".
                "&& tar rvf \$(CWD)/${tgt}\$(VERSION).\$(PLATFORM).tar ".
                "\$(VERSION)/include/${group}/stlport ".
                "&& rm -f \$(VERSION))\n";
        }
    }
    $maketext.="\t${ECHO}gzip ".
                 "\$(ROOT${LOCMACROSUFFIX})/${tgt}\$(VERSION).\$(PLATFORM).tar\n";
    $maketext.="\t\@echo '** created ${msgtgt}\$(PLATFORM) binary distribution'\n";
    $maketext.="\n";

    # source distribution
    $maketext.="${tgt}srcdist: ".
               "\$(ROOT${LOCMACROSUFFIX})/${tgt}\$(VERSION).src.tar.gz ".
               "\$(ROOT${LOCMACROSUFFIX})/${tgt}\$(VERSION).src.zip\n";
    $maketext.="\n";

    # source distribution - tar.gz
    $maketext.="\$(ROOT${LOCMACROSUFFIX})/${tgt}\$(VERSION).src.tar.gz: ".
      "\$(ABSRELFILES) ".join(' ', map {
              "\$(${_}_ABSSRCDISTFILES)"
      } @GROUPS)."\n";
    $maketext.="\t${ECHO}(cd \$(RELDIR) ".
               "&& rm -f \$(VERSION) ".
               "&& ln -s . \$(VERSION) ".
               "&& tar cvf \$(CWD)/${tgt}\$(VERSION).src.tar \$(VERRELFILES) ".
               "&& rm -f \$(VERSION))\n";
    foreach my $GROUP (@GROUPS) {
        $maketext.="\t${ECHO}(cd \$(ROOT${LOCMACROSUFFIX}) ".
            "&& rm -f \$(VERSION) ".
            "&& ln -s . \$(VERSION) ".
            "&& tar rvf \$(CWD)/${tgt}\$(VERSION).src.tar ".
            "\$(${GROUP}_VERSRCDISTFILES) ".
            "&& rm -f \$(VERSION))\n";
    }
    $maketext.="\t${ECHO}gzip ".
                 "\$(ROOT${LOCMACROSUFFIX})/${tgt}\$(VERSION).src.tar\n";
    $maketext.="\t\@echo '** created ${msgtgt}source distribution (tar.gz)'\n";
    $maketext.="\n";

    # source distribution - zip
    $maketext.="\$(ROOT${LOCMACROSUFFIX})/${tgt}\$(VERSION).src.zip: ".
      "\$(ABSRELFILES) ".join(' ', map {
              "\$(${_}_ABSSRCDISTFILES)"
      } @GROUPS)."\n";
    $maketext.="\t${ECHO}(cd \$(RELDIR) ".
               "&& rm -f \$(VERSION) ".
               "&& ln -s . \$(VERSION) ".
               "&& zip \$(CWD)/${tgt}\$(VERSION).src.zip \$(VERRELFILES) ".
               "&& rm -f \$(VERSION))\n";
    foreach my $GROUP (@GROUPS) {
        $maketext.="\t${ECHO}(cd \$(ROOT${LOCMACROSUFFIX}) ".
            "&& rm -f \$(VERSION) ".
            "&& ln -s . \$(VERSION) ".
            "&& zip -u \$(CWD)/${tgt}\$(VERSION).src.zip ".
            "\$(${GROUP}_VERSRCDISTFILES) ".
            "&& rm -f \$(VERSION))\n";
        if (lc($GROUP) eq "bsl") {
            # bsl+stlport/stlport hack 5/5
            $maketext.="\t${ECHO}(cd \$(ROOT${LOCMACROSUFFIX}) ".
                "&& rm -f \$(VERSION) ".
                "&& ln -s . \$(VERSION) ".
                "&& zip -r -u \$(CWD)/${tgt}\$(VERSION).src.zip ".
                "\$(VERSION)/\$(BASE${SUBDMACROSUFFIX})/bsl/bsl+stlport/stlport ".
                "&& rm -f \$(VERSION))\n";
        }
    }

    $maketext.="\t\@echo '** created ${msgtgt}source distribution (zip)'\n";
    $maketext.="\n";

    # convenience target: source + binary distribution (single platform)
    $maketext.="${tgt}dist: ${tgt}srcdist ${tgt}bindist\n";

    return $maketext;
}

#---

sub generateUniversalMakefile ($@) {
    my $build_targets=shift;
    my @groups=@_;

    my $maketext="# BDE Universal "
                .(is_make_type(MAKE_NMAKE)?"NMake ":"")."Makefile\n"
                ."# * This file is machine generated *\n";
    $maketext.="\n";

    $maketext.="# Locations\n";
    $maketext.="${PP}ifndef ROOT${LOCMACROSUFFIX}\n";
    $maketext.="  ROOT${LOCMACROSUFFIX} = $root\n";
    $maketext.="${PP}endif\n";

    foreach my $type (getAllTypes) {
        my $tprefix=uc(getTypeName $type);

        my $type_locn=$root->getTypeLocation($type);
        my $type_subdir="";
        if ($type_locn=~m|^$root/(.*)$|) {
            $type_locn="\$(ROOT${LOCMACROSUFFIX})/$1";
            $type_subdir = $1;
        } else {
            $type_subdir = $root->getTypeSubdir($type);
        }

        $maketext.="${PP}ifndef ${tprefix}${SUBDMACROSUFFIX}\n";
        $maketext.="  ${tprefix}${SUBDMACROSUFFIX} = $type_subdir\n";
        $maketext.="${PP}endif\n";
        $maketext.="${PP}ifndef ${tprefix}${LOCMACROSUFFIX}\n";
        $maketext.="${PP}  ifdef ${tprefix}${SUBDMACROSUFFIX}\n";
        $maketext.="    ${tprefix}${LOCMACROSUFFIX} = "
            ."\$(ROOT${LOCMACROSUFFIX})/\$(${tprefix}${SUBDMACROSUFFIX})\n";
        $maketext.="${PP}  else\n";
        $maketext.="    ${tprefix}${LOCMACROSUFFIX} = $type_locn\n";
        $maketext.="${PP}  endif\n";
        $maketext.="${PP}endif\n";
    }

    $maketext.="${PP}ifndef INSTALL${LIBDIRMACROSUFFIX}\n";
    $maketext.="  INSTALL${LIBDIRMACROSUFFIX} = $LIBDIR\n";
    $maketext.="${PP}endif\n";
    $maketext.="${PP}ifndef INSTALL${INCDIRMACROSUFFIX}\n";
    $maketext.="  INSTALL${INCDIRMACROSUFFIX} = $INCDIR\n";
    $maketext.="${PP}endif\n";
    $maketext.="\n";

    $maketext.=generateBuildTypes()."\n";
    $maketext.=generateGenericTargets(@groups)."\n";
    $maketext.=generateDependentGroupTargets(@groups)."\n";
    $maketext.=generateDistributionTargets(1,@groups)."\n";

    return $maketext;
}

sub generateGroupMakefile ($;@) {
    my $group=shift;

    my @build_targets=@_;
    @build_targets = @{$build_targets[0]} if ref $build_targets[0];
    @build_targets=('') unless @build_targets;

    @build_targets = grep {
        valid_target_for_group($_,$group)
    } @build_targets;

    return { prerules => "# No valid NMake builds", postrules => "" }
      unless @build_targets; #no builds available - skip

    my %build_target_flags = map { $_ => join (' ', (
        map { $BDE_BUILD_TARGET_FLAGS{$_} } split(/_/,$_))
    ) } @build_targets;

    my $GROUP=ucmacro($group);
    my $TARGET=ucmacro($build_targets[0]); #for targetless variables

    my @group_dependants=$group->getDependants();
    my @group_members=$group->getMembers();

    my $makevars="";

    $makevars.=generateGroupLocations($group)."\n";
    $makevars.=generateGroupPreamble($group)."\n";
    $makevars.=generatePlatformID()."\n";
    $makevars.=generateGroupInstallLocations($group)."\n";
    $makevars.=generateBuildTypes()."\n";
    $makevars.=generateGenericTargets($group)."\n";
    $makevars.=generateDependentGroupTargets(@group_dependants)."\n";

    $makevars.="${PP}ifndef BDEMAKE_INCLUDED_${GROUP}_VARS\n".
               "${PP}  include \$(${GROUP}${LOCMACROSUFFIX})/group/${group}.\$(PLATFORM).$VARS\n".
           "BDEMAKE_INCLUDED_${GROUP}_VARS = 1\n".
           "${PP}endif\n";
    $makevars.="\n";

    my $headers  = join(' ', map { "\$(".ucmacro($_).$HDRMACROSUFFIX.")" } @group_members);
    my $includes = join(' ',(map { "${INCDIRFLAG}\$(".ucmacro($_).$LOCMACROSUFFIX.")" } @group_members));
    $includes .= ' '.join(' ',(map { "\$(".ucmacro(${_}).$INCMACROSUFFIX.")" } @group_dependants));
    my $objects  = join(' ', map { "\$(".ucmacro($_).$OBJMACROSUFFIX.")" } @group_members);
    my $absobjects  = join(' ', map { "\$(".ucmacro($_).$ABSOBJMACROSUFFIX.")" } @group_members);
    my $insthdrs = join(' ', map { "\$(".ucmacro($_).$INSTHDRMACROSUFFIX.")" } @group_members);
    my $instlibs = join(' ', map { "\$(${GROUP}_".ucmacro($_).$INSTLIBMACROSUFFIX.")" } @build_targets);

    my $makerules = "# Makefile for '$group' - Rules Section\n";
    $makerules.="\n";
    $makerules.="${GROUP}${HDRMACROSUFFIX} = $headers\n";
    $makerules.="${GROUP}${OBJMACROSUFFIX} = $objects\n";
    $makerules.="${GROUP}${ABSOBJMACROSUFFIX} = $absobjects\n";
    $makerules.="${GROUP}${INCMACROSUFFIX} = $includes\n";
    $makerules.="${GROUP}${INSTHDRMACROSUFFIX} = $insthdrs\n";
    $makerules.="${GROUP}${INSTLIBMACROSUFFIX} = $instlibs\n";
    $makerules.="\n";
    $makerules.=".SUFFIXES:\n";
    $makerules.="\n";
    if (is_make_type(MAKE_NMAKE)) {
        $makerules.=".SUFFIXES: .h .cpp .xpp .c .s .rc ".join(' ',map { ".${_}${OB}" } @build_targets)."\n";
        $makerules.="\n";
    }

    unless (isIsolatedPackage($group)) {
        # only applicable if this is a real group, and not an isolated package
        $makerules.="# group targets\n";
        $makerules.="\n";
        unless (is_make_type(MAKE_NMAKE)) {
            $makerules.=".PHONY: $group ${group}.build ${group}.install ${group}.installlib ${group}.installlibs ${group}.installhdr ${group}.clean ${group}.cleanobjs ${group}.cleanlib ${group}.cleanlibs ${group}.realclean";
            if ($opts{tests}) {
                $makerules.=" ${group}.buildtests";
            }
            $makerules.="\n\n";
        }
        $makerules.="$group: ${group}.all\n";
        $makerules.="\n";
        $makerules.="${group}.all: ${group}.build\n";
        $makerules.="\n";
        # build group
        $makerules.="${group}.build: ".join(' ',map { "${group}.${_}.build" } @build_targets)."\n";
        $makerules.="\n";

        # test group
        if ($opts{tests}) {
            $makerules.="${group}.buildtests: ".join(' ',map { "${group}.${_}.buildtests" } @build_targets)."\n";
            $makerules.="\n";
        }

        # install group
        $makerules.="${group}.install: ${group}.installlib ${group}.installhdr\n";
        $makerules.="\n";
        $makerules.="${group}.installlib: ".(join ' ',(map { "${group}.${_}.installlib" } @build_targets))."\n";
        $makerules.="\n";
        # we don't install the package libraries by default so they get a separate lib*s* rule
        $makerules.="${group}.installlibs: ".join(' ',map { "${_}.installlib" } @group_members)."\n";
        $makerules.="\n";
        $makerules.="${group}.installhdr: ".join(' ',map { "${_}.installhdr" } @group_members)."\n";
        $makerules.="\n";
        if (is_make_type(MAKE_NMAKE)) {
            # for windows, but usable on Unix (with the right PLATFORM set)
            $makerules.="${group}.mhdr: ".join(' ',map { "${_}.mhdr" } @group_members)."\n";
            $makerules.="\n";
        }
    }

    $makerules.=generateDistributionTargets(0,$group)."\n";

    foreach my $target (@build_targets) {
    my $TARGET=ucmacro($target);
        my $lib_target=getNormalisedTarget($target,1);
        my $linklib_target=(is_make_type(MAKE_NMAKE)?$target:$lib_target); # .lib has different name to .dll because of static .lib

    # build group variables
    $makerules.="### Begin $GROUP $TARGET ###\n";
    $makerules.="\n";
    $makerules.="${GROUP}_${TARGET}${LIBMACROSUFFIX} = \$(${GROUP}_${TARGET}_LIB_PREFIX)${group}.${lib_target}\$(${GROUP}_${TARGET}_LIB_EXT)\n";
    $makerules.="${GROUP}_${TARGET}${WLDMACROSUFFIX} = \$(${GROUP}_${TARGET}_LIB_PREFIX)${group}.${lib_target}\$(${GROUP}_${TARGET}_LIB_WLDEXT)\n";
    $makerules.="${GROUP}_${TARGET}_DSHR${WLDMACROSUFFIX} = \$(${GROUP}_${TARGET}_LIB_PREFIX)${group}.${lib_target}_shr\$(${GROUP}_${TARGET}_LIB_WLDEXT)\n";
    $makerules.="${GROUP}_${TARGET}${INSTLIBMACROSUFFIX} = \$(${GROUP}${INSTLIBDIRMACROSUFFIX})/\$(${GROUP}_${TARGET}${LIBMACROSUFFIX})\n";
    if ($target=~/shr/ and not is_make_type(MAKE_NMAKE)) {
        $makerules.="${GROUP}_${TARGET}_M${LIBMACROSUFFIX} = \$(${GROUP}_${TARGET}_LIB_PREFIX)${group}.${lib_target}.\$(${GROUP}_MAJOR)\$(${GROUP}_${TARGET}_LIB_EXT)\n";
        $makerules.="${GROUP}_${TARGET}_MM${LIBMACROSUFFIX} = \$(${GROUP}_${TARGET}_LIB_PREFIX)${group}.${lib_target}.\$(${GROUP}_MAJOR).\$(${GROUP}_MINOR)\$(${GROUP}_${TARGET}_LIB_EXT)\n";
    }
    $makerules.="${GROUP}_${TARGET}${LINKLIBMACROSUFFIX} = \$(${GROUP}_${TARGET}_LINK_LIB_PREFIX)${group}.${linklib_target}\$(${GROUP}_${TARGET}_LINK_LIB_EXT)\n";
    $makerules.="${GROUP}_${TARGET}${OBJMACROSUFFIX} = \$(${GROUP}${OBJMACROSUFFIX}:${SM}${OB}=${SM}.${target}${OB})\n";
    $makerules.="${GROUP}_${TARGET}${ABSOBJMACROSUFFIX} = ".
      join(' ',map { "\$(".ucmacro(${_})."_${TARGET}${ABSOBJMACROSUFFIX})" } @group_members)
        ."\n";
    $makerules.="${GROUP}${BLOCMACROSUFFIX} = \$(${GROUP}${LOCMACROSUFFIX})/\$(PLATFORM)\n";
    $makerules.="${GROUP}${BLIBMACROSUFFIX} = \$(${GROUP}${LOCMACROSUFFIX})/${LIB_SUBDIR}/\$(PLATFORM)\n";
        $makerules.="${GROUP}${BINCMACROSUFFIX} = \$(${GROUP}${LOCMACROSUFFIX})/${INCLUDE_SUBDIR}/\$(PLATFORM)\n";
        if (is_make_type(MAKE_NMAKE)) {
        $makerules.="${GROUP}${ALLMHDRMACROSUFFIX} = ".(join " ",map {
            "\$(".ucmacro($_).$MHDRMACROSUFFIX.")"
        } @group_members)."\n"; #<<<AMH(G)
    }
    if ($opts{tests}) {
        $makerules.="${GROUP}_${TARGET}${TSTOBJMACROSUFFIX} = \$(${GROUP}${OBJMACROSUFFIX}:${SM}${OB}=${SM}.t.${target}${OB})\n";
    }
    $makerules.="\n";

    # build group build-type
    unless (is_make_type(MAKE_NMAKE)) {
        $makerules.=".PHONY: ${group}.${target} ${group}.${target}.build ${group}.${target}.install ${group}.${target}.installlib ${group}.${target}.uninstall ${group}.${target}.uninstalllib ${group}.${target}.clean ${group}.${target}.cleanobjs ${group}.${target}.cleanlib ${group}.${target}.cleanlibs ${group}.${target}.distclean ${group}.${target}.realclean";
        if ($opts{tests}) {
            $makerules.=" ${group}.${target}.buildtests";
        }
        $makerules.="\n\n";
    }

    if ($opts{tests}) {
        $makerules.="${group}.${target}.buildtests: ".join(' ',map { "${_}.${target}.buildtests" } @group_members)."\n";
    }

    $makerules.="${group}.${target}: ${group}.${target}.build\n";
    $makerules.="\n";
    $makerules.="${group}.${target}.build: \$(${GROUP}${BLIBMACROSUFFIX})/\$(${GROUP}_${TARGET}${LIBMACROSUFFIX})\n";
    $makerules.="\n";
        if (is_make_type(MAKE_NMAKE) and $target=~/shr/) {
            $makerules.="\$(${GROUP}${BLIBMACROSUFFIX})/\$(${GROUP}_${TARGET}${LIBMACROSUFFIX}): ".
          (join ' ',map { "\$(".ucmacro($_)."${BLIBMACROSUFFIX})/\$(".ucmacro($_)."_${TARGET}${LIBMACROSUFFIX})" } @group_dependants)
          ." \$(${GROUP}${ALLMHDRMACROSUFFIX}) \$(${GROUP}_${TARGET}${ABSOBJMACROSUFFIX})\n";
        } else {
            $makerules.="\$(${GROUP}${BLIBMACROSUFFIX})/\$(${GROUP}_${TARGET}${LIBMACROSUFFIX}): \$(${GROUP}${ALLMHDRMACROSUFFIX}) \$(${GROUP}_${TARGET}${ABSOBJMACROSUFFIX})\n";
        }
    $makerules.="\t\@\$(${GROUP}_${TARGET}_MKDIR) \$(${GROUP}${BLIBMACROSUFFIX})\n";
    unless (is_make_type(MAKE_NMAKE)) {
        $makerules.="\t\@\$(${GROUP}_${TARGET}_RM) \$@\n"; #clearmake
    }
    if (is_make_type(MAKE_NMAKE) and $target=~/shr/) {
        $makerules.="\t${ECHO}\$(${GROUP}_${TARGET}_MAKE_DEFS) \$(${GROUP}${LOCMACROSUFFIX})/*/\$(PLATFORM)/*.${target}${OB} > \$(${GROUP}${BLIBMACROSUFFIX})/${group}.${target}.def\n";
        $makerules.="\t${ECHO}\$(${GROUP}_${TARGET}_AR_INSTALL) -def:\"\$(${GROUP}${BLIBMACROSUFFIX})/${group}.${target}.def\" \$(${GROUP}_${TARGET}${ABSOBJMACROSUFFIX}) ".
          (join ' ',map { "\$(".ucmacro($_)."${BLIBMACROSUFFIX})/\$(".ucmacro($_)."_${TARGET}${LINKLIBMACROSUFFIX})" } @group_dependants)
           ."\n";
    } else {
        $makerules.="\t${ECHO}\$(${GROUP}_${TARGET}_AR_INSTALL) \$(${GROUP}_${TARGET}${ABSOBJMACROSUFFIX})\n";
    }
    $makerules.="\t\@echo '** built \$(${GROUP}_${TARGET}${LIBMACROSUFFIX})'\n";
    $makerules.="\n";

    # install group build-type
    $makerules.="${group}.${target}.install: ${group}.${target}.installlib ${group}.installhdr\n";
    $makerules.="\n";
    $makerules.="${group}.${target}.installlib: \$(${GROUP}_${TARGET}${INSTLIBMACROSUFFIX})\n";
    $makerules.="\n";

    if ($target=~/shr/ and not is_make_type(MAKE_NMAKE)) {
        $makerules.="\$(${GROUP}_${TARGET}${INSTLIBMACROSUFFIX}): \$(${GROUP}${INSTLIBDIRMACROSUFFIX})/\$(${GROUP}_${TARGET}_M${LIBMACROSUFFIX})\n";
        $makerules.="\t\@\$(${GROUP}_${TARGET}_RM) \$@\n";
        $makerules.="\t${ECHO}(cd \$(${GROUP}${INSTLIBDIRMACROSUFFIX}) && ln -s \$(${GROUP}_${TARGET}_M${LIBMACROSUFFIX}) \$(${GROUP}_${TARGET}${LIBMACROSUFFIX}))\n";
        $makerules.="\n";
        $makerules.="\$(${GROUP}${INSTLIBDIRMACROSUFFIX})/\$(${GROUP}_${TARGET}_M${LIBMACROSUFFIX}): \$(${GROUP}${INSTLIBDIRMACROSUFFIX})/\$(${GROUP}_${TARGET}_MM${LIBMACROSUFFIX})\n";
        $makerules.="\t\@\$(${GROUP}_${TARGET}_RM) \$@\n";
        $makerules.="\t${ECHO}(cd \$(${GROUP}${INSTLIBDIRMACROSUFFIX}) && ln -s \$(${GROUP}_${TARGET}_MM${LIBMACROSUFFIX}) \$(${GROUP}_${TARGET}_M${LIBMACROSUFFIX}))\n";
        $makerules.="\n";
        $makerules.="\$(${GROUP}${INSTLIBDIRMACROSUFFIX})/\$(${GROUP}_${TARGET}_MM${LIBMACROSUFFIX}): \$(${GROUP}${BLIBMACROSUFFIX})/\$(${GROUP}_${TARGET}${LIBMACROSUFFIX})\n";
    } else {
        $makerules.="\$(${GROUP}_${TARGET}${INSTLIBMACROSUFFIX}): \$(${GROUP}${BLIBMACROSUFFIX})/\$(${GROUP}_${TARGET}${LIBMACROSUFFIX})\n";
    }

    $makerules.="\t\@\$(${GROUP}_${TARGET}_MKDIR) \$(${GROUP}${INSTLIBDIRMACROSUFFIX})\n";
    if (is_make_type(MAKE_NMAKE)) {
        # something of an ugly hack; this will go away when common macros become available between bde_build.pl and producemake (i.e. $TARGET)
        # NB the path here correlates with the CXX definition in default.opts
        $makerules.="\t${ECHO}\$(${GROUP}_${TARGET}_F2FCP) \$(${GROUP}${LOCMACROSUFFIX})/${group}.${target}.pdb \$(${GROUP}${BLIBMACROSUFFIX})/\$(${GROUP}_${TARGET}_LIB_PREFIX)${group}.${target}.pdb\n";
           #$makerules.="\t${ECHO}\$(${GROUP}_${TARGET}_F2FCP) \$(${GROUP}${LOCMACROSUFFIX})/${group}.${target}.idb \$(${GROUP}${BLIBMACROSUFFIX})/\$(${GROUP}_${TARGET}_LIB_PREFIX)${group}.${target}.idb\n";
        #$makerules.="\t${ECHO}\$(${GROUP}_${TARGET}_RM) \$(${GROUP}${LOCMACROSUFFIX})/${group}.${target}.pdb \$(${GROUP}${LOCMACROSUFFIX})/${group}.${target}.idb\n";
            $makerules.="\t${ECHO}\$(${GROUP}_${TARGET}_CP) \$(${GROUP}${BLIBMACROSUFFIX})/\$(${GROUP}_${TARGET}${WLDMACROSUFFIX}) \$(${GROUP}${BLIBMACROSUFFIX})/\$(${GROUP}_${TARGET}_DSHR${WLDMACROSUFFIX}) \"\$(\@D)\"\n";
    } else {
        $makerules.="\t\@\$(${GROUP}_${TARGET}_RM) \$@\n"; #clearmake
        $makerules.="\t${ECHO}\$(${GROUP}_${TARGET}_CP) \$< \$@\n";
    }
    $makerules.="\t\@echo '** installed \$(${GROUP}_${TARGET}${LIBMACROSUFFIX})'\n";
        $makerules.="\n";

        # uninstall group build-type
        $makerules.="${group}.${target}.uninstall: ${group}.${target}.uninstalllib ${group}.uninstallhdr\n";
        $makerules.="\n";
        $makerules.="${group}.${target}.uninstalllib:\n";
    $makerules.="\t${ECHO}\$(${GROUP}_${TARGET}_RM) \$(${GROUP}_${TARGET}${INSTLIBMACROSUFFIX})\n";
        $makerules.="\n";

        # clean group build-type
        $makerules.="${group}.${target}.clean: ${group}.${target}.cleanlib ".join(' ',map { "${_}.${target}.clean" } @group_members)."\n";
        $makerules.="\n";
        $makerules.="${group}.${target}.cleanobjs: ".join(' ',map { "${_}.${target}.cleanobjs" } @group_members)."\n";
        $makerules.="\n";
    $makerules.="${group}.${target}.cleanlib:\n";
        $makerules.="\t${ECHO}\$(${GROUP}_${TARGET}_RM) \$(${GROUP}${BLIBMACROSUFFIX})/\$(${GROUP}_${TARGET}${LIBMACROSUFFIX})\n";
        $makerules.="\n";
        $makerules.="${group}.${target}.cleanlibs: ".join(' ',map { "${_}.${target}.cleanlib" } @group_members)."\n";
        $makerules.="\n";
        $makerules.="${group}.${target}.distclean: ".join(' ',map { "${_}.${target}.distclean" } @group_members)."\n";
        $makerules.="\n";
        $makerules.="${group}.${target}.realclean: ".join(' ',map { "${_}.${target}.realclean" } @group_members)."\n";
        $makerules.="\n";
    $makerules.="### End $GROUP $TARGET ###\n";
        $makerules.="\n";
    }

    # uninstall group
    $makerules.="${group}.uninstall: ${group}.uninstalllib ${group}.uninstallhdr\n";
    $makerules.="\n";
    $makerules.="${group}.uninstalllib: ".(join ' ',(map { "${group}.${_}.uninstalllib" } @build_targets))."\n";
    $makerules.="\n";
    # we don't uninstall the package libraries by default so they get a separate lib*s* rule
    $makerules.="${group}.uninstalllibs: ".join(' ',map { "${_}.uninstalllib" } @group_members)."\n";
    $makerules.="\n";
    $makerules.="${group}.uninstallhdr: ".join(' ',map { "${_}.uninstallhdr" } @group_members)."\n";
    $makerules.="\t\@echo '** uninstalled ${group} headers'\n";
    $makerules.="\n";

    # clean group
    $makerules.="${group}.clean: ${group}.cleanobjs ${group}.cleanlib ${group}.cleanlibs\n";
    $makerules.="\n";
    $makerules.="${group}.cleanobjs: ".join(' ',map { "${group}.${_}.cleanobjs" } @build_targets)."\n";
    $makerules.="\n";
    $makerules.="${group}.cleanlib: ".join(' ',map { "${group}.${_}.cleanlib" } @build_targets)."\n";
    $makerules.="\t${ECHO}\$(${GROUP}_${TARGET}_RMRECURSE) \$(${GROUP}${BLIBMACROSUFFIX})/SunWS_cache \$(${GROUP}${BLIBMACROSUFFIX})/tempinc\n";
    $makerules.="\t${ECHO}\$(${GROUP}_${TARGET}_RM) \$(${GROUP}${BLIBMACROSUFFIX})/*\n";
    $makerules.="\n";
    $makerules.="${group}.cleanlibs: ".join(' ',map { "${group}.${_}.cleanlibs" } @build_targets)."\n";
    $makerules.="\n";
    $makerules.="${group}.distclean: ".join(' ',map { "${group}.${_}.distclean" } @build_targets)."\n";
    $makerules.="\n";
    if (is_make_type(MAKE_NMAKE)) {
        $makerules.="${group}.cleanmhdr: ".join(' ',map { "${_}.cleanmhdr" } @group_members)."\n";
        $makerules.="\n";
    }
    $makerules.="${group}.realclean: ".join(' ',map { "${group}.${_}.realclean" } @build_targets)."\n";
    $makerules.="\t${ECHO}\$(${GROUP}_${TARGET}_RM) \$(${GROUP}${LOCMACROSUFFIX})/group/$group.$MK\n";
    $makerules.="\n";

    # checksum and verify group
    $makerules.="${group}.checksum: \$(${GROUP}${LOCMACROSUFFIX})/group/${group}.$SUM\n";
    $makerules.="\n";
    $makerules.="\$(${GROUP}${LOCMACROSUFFIX})/group/${group}.$SUM: \$(${GROUP}_ABSSRCDISTFILES_NOSUM)\n";
    $makerules.="\t${ECHO}md5sum ${DM} > \$@\n";
    $makerules.="\t\@md5sum \$@\n";
    $makerules.="\n";
    $makerules.="${group}.verify:\n";
    $makerules.="\t${ECHO}md5sum -c \$(${GROUP}${LOCMACROSUFFIX})/group/${group}.$SUM\n";
    $makerules.="\t\@md5sum \$?\n";
    $makerules.="\n";

    debug("Group '$group' dependants: @group_dependants");
    debug("Group '$group' members: @group_members");

    return { prerules => $makevars, postrules => $makerules};
}

# copy+paste from bde_build.pl
sub scanPackageDirectory ($$;$) {
    my ($package,$subdir,$regex)=@_;
    ($regex=$subdir,$subdir=undef) unless defined $regex;

    my $dir=$root->getPackageLocation($package);
    $dir.=$FS.$subdir if $subdir;
    opendir(DIR,$dir) || fatal "Can't open $dir: $!";
    my @files = sort grep { /$regex/ && -f "$dir/$_" } readdir(DIR);
    closedir DIR;

    return @files;
}

sub generatePackageMakefile ($$) {
    my ($package,$bt)=@_;
    my $noncompliant=isNonCompliant($package);
    my @build_targets=@$bt;

    my $group=isIsolatedPackage($package)
      ? getCachedPackage($package)
      : getCachedGroup($package->getGroup());

    @build_targets = grep {
        valid_target_for_group($_,$group)
    } @build_targets;

    return { rules => "" } unless @build_targets; #no builds available - skip

    my %build_target_flags = map { $_ => join (' ', (
        map { $BDE_BUILD_TARGET_FLAGS{$_} } split(/_/,$_))
    ) } @build_targets;

    my $PACKAGE=ucmacro($package);
    my $GROUP=ucmacro($group);

    my $TARGET=ucmacro($build_targets[0]); #use 1st target for targetless vars

    my @package_dependants=$package->getDependants();
    my @package_members;
    if ($noncompliant) {
        @package_members = scanPackageDirectory($package,'\.c(pp)?$');
        s/\.c(pp)?$// foreach @package_members;
    } else {
        @package_members=$package->getMembers();
    }

    my @list_dependants=@package_dependants?@package_dependants:('*none*');

    my ($makefile,$makevars)=("","");


    unless ($STRIP) {
        $makefile .= "# ".(is_make_type(MAKE_NMAKE)?"NMake ":"").
                       "Makefile for '$package'\n".
                     "# * This file is machine generated *\n".
                     "# \n".
                     "# Dependants:\n".
                     join("\n",map { "#    $_" } @list_dependants)."\n".
                     "# ".($noncompliant?"Sources":"Members").":\n".
                     join("\n",map { "#    $_" } @package_members)."\n\n";
    }

    $makefile.=generateGroupLocations($package)."\n";
    $makefile.=generatePlatformID()."\n";
    $makefile.=generateGroupInstallLocations($package)."\n";
    $makefile.=generateBuildTypes()."\n";
    $makefile.=generateGenericTargets($package)."\n";
    if (isIsolatedPackage($package)) {
        $makefile.=generateDependentGroupTargets(grep {
                isIsolatedPackage($_) or isGroup($_)
                }@package_dependants)."\n";
        $makefile.=generateDistributionTargets(0,$package)."\n";
    }

    my $headers;
    my @package_headers;
    if ($noncompliant) {
        @package_headers = scanPackageDirectory($package,'\.h$');
    } else {
        @package_headers = map { "${_}.h" } @package_members;
    }
    $headers = join(' ',@package_headers);

    # include paths for this package, including dependent groups
    my @dependants=getAllPackageDependencies($package);
    my @DEPENDANTS=map { ucmacro($_) } @dependants;
    my $includes = join(' ',(map {
                "${INCDIRFLAG}\$(".$_.
                (is_make_type(MAKE_NMAKE)?$BINCMACROSUFFIX:$LOCMACROSUFFIX).")"
                } @DEPENDANTS));
    if (my @group_dependants=getAllGroupDependencies($group)) {
        $includes .= " ".join(' ',(map {
            "\$(".ucmacro($_).$INCMACROSUFFIX.")"
        } @group_dependants));
    }

    # NMake depends on mangled headers of the package itself
    $includes.=" ${INCDIRFLAG}\$(".$PACKAGE.
        ((is_make_type(MAKE_NMAKE) and not $noncompliant)?$BINCMACROSUFFIX:$LOCMACROSUFFIX).")";

    # objects for this package; XXXscm is a special case
    my @package_objects=@package_members;
    if (is_make_type(MAKE_NMAKE) and $package =~ /scm$/) {
        push @package_objects, "${package}_properties"; # an .rc file
    }
    my $objects  = join(' ',(map { "${_}${OB}" } @package_objects));
    my @package_targets = map { "$package.$_" } @build_targets;

    # macro definitions for locations and nomenclature
    unless (isIsolatedPackage($package)) {
        $makefile.="${PACKAGE}${LOCMACROSUFFIX} = \$(${GROUP}${LOCMACROSUFFIX})/${package}\n";
        $makefile.="${PACKAGE}${INSTLIBDIRMACROSUFFIX} = \$(${GROUP}${INSTLIBDIRMACROSUFFIX})\n";
        $makefile.="${PACKAGE}${INSTINCDIRMACROSUFFIX} = \$(${GROUP}${INSTINCDIRMACROSUFFIX})\n";
    }
    $makefile.="${PACKAGE}${HDRMACROSUFFIX} = $headers \$(${EXTRAMACROPREFIX}${PACKAGE}${HDRMACROSUFFIX})\n";
    if (is_make_type(MAKE_NMAKE)) {
        # NMake requires mangled headers in a different location.
        $makefile.="${PACKAGE}${INSTHDRMACROSUFFIX} = ".(join " ",map {
                "\$(${PACKAGE}${INSTINCDIRMACROSUFFIX})/${_}"
                } @package_headers)."\n"; #<<<IH

        $makefile.="${PACKAGE}${MHDRMACROSUFFIX} = ".(join " ",map {
                "\$(${PACKAGE}${BINCMACROSUFFIX})/${_}"
                } @package_headers)."\n"; #<<<MH

        $makefile.="${PACKAGE}${ALLMHDRMACROSUFFIX} = ".(join " ",map {
                "\$(".ucmacro($_).$MHDRMACROSUFFIX.")"
                } getAllPackageDependencies($package))."\n"; #<<<AMH(P)
    } else {
        # Sensible builds don't need all this messing about
        $makefile.="${PACKAGE}${INSTHDRMACROSUFFIX} = \$(${PACKAGE}${HDRMACROSUFFIX}:%=\$(${PACKAGE}${INSTINCDIRMACROSUFFIX})/%)\n";
    }

    $makefile.="${PACKAGE}${OBJMACROSUFFIX} = $objects\n";
    unless (is_make_type(MAKE_NMAKE)) {
        # Although appends can be done under NMAKE, prefix substitutions can't, so we don't bother
        $makefile.="${PACKAGE}${OBJMACROSUFFIX} += \$(${EXTRAMACROPREFIX}${PACKAGE}${OBJMACROSUFFIX})\n";
    }
    $makefile.="${PP}ifndef BDEMAKE_INCLUDED_${PACKAGE}_VARS\n".
               "${PP}  include \$(${PACKAGE}${LOCMACROSUFFIX})/package/${package}.\$(PLATFORM).$VARS\n".
               "BDEMAKE_INCLUDED_${PACKAGE}_VARS = 1\n".
               "${PP}endif\n";
    $makefile.="${PACKAGE}${BLOCMACROSUFFIX} = \$(${PACKAGE}${LOCMACROSUFFIX})/\$(PLATFORM)\n";
    $makefile.="${PACKAGE}${BLIBMACROSUFFIX} = \$(${PACKAGE}${LOCMACROSUFFIX})/${LIB_SUBDIR}/\$(PLATFORM)\n";
    if ($noncompliant) {
        $makefile.="${PACKAGE}${BINCMACROSUFFIX} = \$(${PACKAGE}${LOCMACROSUFFIX})\n";
    } else {
        $makefile.="${PACKAGE}${BINCMACROSUFFIX} = \$(${PACKAGE}${LOCMACROSUFFIX})/${INCLUDE_SUBDIR}/\$(PLATFORM)\n";
    }
    $makefile.="${PACKAGE}${INCMACROSUFFIX} = $includes \$(${EXTRAMACROPREFIX}${PACKAGE}${INCMACROSUFFIX})\n";
    $makefile.="${PACKAGE}${ABSHDRMACROSUFFIX} = ".(join " ",map {
        "\$(${PACKAGE}${LOCMACROSUFFIX})/${_}"
    } @package_headers)."\n";
    if ($opts{tests}) {
        $makefile.="${PACKAGE}${TSTOBJMACROSUFFIX} = \$(${PACKAGE}${OBJMACROSUFFIX}:${SM}${OB}=${SM}.t${OB})\n";
    }
    $makefile.="\n";

    # phony targets, where supported
    unless (is_make_type(MAKE_NMAKE)) {
        $makefile.=".PHONY: $package ${package}.build ${package}.install ${package}.installlib ${package}.installhdr ${package}.uninstall ${package}.uninstalllib ${package}.uninstallhdr ${package}.clean ${package}.cleanobjs ${package}.cleanlibs ${package}.distclean ${package}.mhdr ${package}.cleanmhdr ${package}.realclean";
        if ($opts{tests}) {
            $makefile.=" ${package}.buildtests";
        }
        $makefile.="\n\n";
    }

    # convenience and default targets
    $makefile.="$package: ${package}.all\n";
    $makefile.="\n";
    $makefile.="${package}.all: ${package}.build\n";
    $makefile.="\n";

    # build package
    $makefile.="${package}.build: ".(join ' ',(map { "${package}.${_}.build" } @build_targets))."\n";
    $makefile.="\n";

    # buildtest package
    $makefile.="${package}.buildtests: ".(join ' ',(map { "${package}.${_}.buildtests" } @build_targets))."\n";
    $makefile.="\n";

    # install package
    $makefile.="${package}.install: ${package}.installlib ${package}.installhdr\n";
    $makefile.="\n";
    $makefile.="${package}.installlib: ".(join ' ',(map { "${package}.${_}.installlib" } @build_targets))."\n";
    $makefile.="\n";
    $makefile.="${package}.installhdr: \$(${PACKAGE}${INSTHDRMACROSUFFIX})\n";
    if (my $extradir=getExtraPackageDir($package)) {
        $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_CPRECURSE) \$(${PACKAGE}${LOCMACROSUFFIX})/$extradir \$(${PACKAGE}${INSTINCDIRMACROSUFFIX})\n";
    }
    $makefile.="\n";
    if (is_make_type(MAKE_NMAKE)) {
        # NMake batch rule; copies mangled headers from BLOC, not from LOC
        $makefile.="{\$(${PACKAGE}${BINCMACROSUFFIX})}.h{\$(${PACKAGE}${INSTINCDIRMACROSUFFIX})}.h::\n";
    } else {
        $makefile.="\$(${PACKAGE}${INSTINCDIRMACROSUFFIX})/%.h: \$(${PACKAGE}${LOCMACROSUFFIX})/%.h\n";
    }
    $makefile.="\t\@\$(${PACKAGE}_${TARGET}_MKDIR) \$(${PACKAGE}${INSTINCDIRMACROSUFFIX})\n";
    unless (is_make_type(MAKE_NMAKE)) {
        $makefile.="\t\@\$(${PACKAGE}_${TARGET}_RM) \$@\n"; #clearmake
    }
    $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_CP) \$< \$(${PACKAGE}${INSTINCDIRMACROSUFFIX})\n";
    $makefile.="\n";
    $makefile.="${package}.mhdr:\n";
    if (is_make_type(MAKE_NMAKE) and not $noncompliant) {
        $makefile.="\t\@\$(${PACKAGE}_${TARGET}_MKDIR) \$(${PACKAGE}${BINCMACROSUFFIX})\n";
        $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_PROCESS_INC) \$(${PACKAGE}${ABSHDRMACROSUFFIX}) \$(${PACKAGE}${BINCMACROSUFFIX})\n";
    }
    $makefile.="\n";

    # uninstall package
    $makefile.="${package}.uninstall: ${package}.uninstalllib ${package}.uninstallhdr\n";
    $makefile.="\n";
    $makefile.="${package}.uninstalllib: ".
      (join ' ',(map { "${package}.${_}.uninstalllib" } @build_targets))."\n";
    $makefile.="\n";
    $makefile.="${package}.uninstallhdr:\n";
    if (is_make_type(MAKE_NMAKE)) {
        $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_RM) ".(join " ",map {
                "\$(${PACKAGE}${INSTINCDIRMACROSUFFIX})/${_}"
                } @package_headers)."\n"; #<<<UH
    } else {
        $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_RM) ".
            "\$(${PACKAGE}${HDRMACROSUFFIX}:%=\$(${PACKAGE}${INSTINCDIRMACROSUFFIX})/%)\n";
    }
    $makefile.="\n";

    # clean package
    $makefile.="${package}.clean: ${package}.cleanobjs ${package}.cleanlibs\n";
    $makefile.="\n";
    $makefile.="${package}.cleanobjs: ".
      (join ' ',(map { "${package}.${_}.cleanobjs" } @build_targets))."\n";
    $makefile.="\n";
    $makefile.="${package}.cleanlibs: ".
      (join ' ',(map { "${package}.${_}.cleanlib" } @build_targets))."\n";
    $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_RM) \$(${PACKAGE}${BLIBMACROSUFFIX})/*\n";
    $makefile.="\n";
    $makefile.="${package}.distclean: ${package}.clean ".
      (is_make_type(MAKE_NMAKE)?"${package}.cleanmhdr":"")."\n";
    $makefile.="\n";
    if (is_make_type(MAKE_NMAKE)) {
        $makefile.="${package}.cleanmhdr:\n";
        $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_RM) \$(${PACKAGE}${MHDRMACROSUFFIX})\n";
        $makefile.="\n";
    }
    $makefile.="${package}.realclean: ${package}.distclean\n";
    $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_RM) ${PACKAGE}${LOCMACROSUFFIX}/package/${package}.$MK\n";
    $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_RM) ${PACKAGE}${LOCMACROSUFFIX}/package/${package}.*.$VARS\n";
    $makefile.="\n";

    foreach my $target (@build_targets) {
        my $TARGET=ucmacro($target);
        my $lib_target=getNormalisedTarget($target,1);
        my $linklib_target=(is_make_type(MAKE_NMAKE)?$target:$lib_target); # .lib has different name to .dll because of static .lib

            $makefile.="### $PACKAGE $TARGET ###\n";
        $makefile.="\n";

        #unless (is_make_type(MAKE_NMAKE)) {
        #    # this can work under NMAKE but macro-prefix substitution can't, so we don't bother
        #    $makefile.="\$(${GROUP}_BLIB)/\$(${GROUP}_${TARGET}_LIBRARY): ${PACKAGE}${OBJMACROSUFFIX} += \$(${PACKAGE}_${TARGET}_${EXTRAMACROPREFIX}${PACKAGE}${OBJMACROSUFFIX})\n";
        #}
        $makefile.="${PACKAGE}_${TARGET}${LIBMACROSUFFIX} = \$(${PACKAGE}_${TARGET}_LIB_PREFIX)${package}.${lib_target}\$(${PACKAGE}_${TARGET}_LIB_EXT)\n";
        $makefile.="${PACKAGE}_${TARGET}${WLDMACROSUFFIX} = \$(${PACKAGE}_${TARGET}_LIB_PREFIX)${package}.${lib_target}\$(${PACKAGE}_${TARGET}_LIB_WLDEXT)\n";
        $makefile.="${PACKAGE}_${TARGET}${LINKLIBMACROSUFFIX} = \$(${PACKAGE}_${TARGET}_LINK_LIB_PREFIX)${package}.${linklib_target}\$(${PACKAGE}_${TARGET}_LINK_LIB_EXT)\n";
        $makefile.="${PACKAGE}_${TARGET}${OBJMACROSUFFIX} = \$(${PACKAGE}${OBJMACROSUFFIX}:${SM}${OB}=${SM}.${target}${OB}) \$(${PACKAGE}_${TARGET}_${EXTRAMACROPREFIX}${PACKAGE}${OBJMACROSUFFIX}:${SM}${OB}=${SM}.${target}${OB})\n";
        if ($opts{tests}) {
            $makefile.="${PACKAGE}_${TARGET}${TSTOBJMACROSUFFIX} = \$(${PACKAGE}${TSTOBJMACROSUFFIX}:${SM}${OB}=\$(${PACKAGE}${BLOCMACROSUFFIX})/${SM}.${target}${OB}\)\n";
            $makefile.="${PACKAGE}_${TARGET}${TSTBINMACROSUFFIX} = \$(${PACKAGE}${TSTOBJMACROSUFFIX}:${SM}${OB}=\$(${PACKAGE}${BLOCMACROSUFFIX})/${SM}.${target}\)\n" unless $package =~ /\+.*hdrs/;  # exclude bsl+bslhdrs, bsl+stdhdrs
        }
        if (is_make_type(MAKE_NMAKE)) {
            $makefile.="${PACKAGE}${ABSOBJMACROSUFFIX} = ".(join " ",map {
                    "\$(${PACKAGE}${BLOCMACROSUFFIX})/${_}${OB}"
                    } @package_objects)."\n";
            $makefile.="${PP}if defined(${PACKAGE}_${TARGET}_${EXTRAMACROPREFIX}${PACKAGE}${OBJMACROSUFFIX})\n";
            $makefile.="${PACKAGE}${ABSOBJMACROSUFFIX} = \$(${PACKAGE}${ABSOBJMACROSUFFIX}) \$(${PACKAGE}${BLOCMACROSUFFIX})/\$(${PACKAGE}_${TARGET}_${EXTRAMACROPREFIX}${PACKAGE}${OBJMACROSUFFIX})\n";
            # the above allows one extra object only
            $makefile.="${PP}endif\n";
            $makefile.="${PACKAGE}_${TARGET}${ABSOBJMACROSUFFIX} = \$(${PACKAGE}${ABSOBJMACROSUFFIX}:${SM}${OB}=${SM}.${target}${OB})\n";
        } else {
            $makefile.="${PACKAGE}_${TARGET}${ABSOBJMACROSUFFIX} = \$(${PACKAGE}_${TARGET}${OBJMACROSUFFIX}:%=\$(${PACKAGE}${BLOCMACROSUFFIX})/%)\n";
            $makefile.="${PACKAGE}_${TARGET}${ABSHDRMACROSUFFIX} = \$(${PACKAGE}_${TARGET}${HDRMACROSUFFIX}:%=\$(${PACKAGE}${BLOCMACROSUFFIX})/%)\n";
        }
        $makefile.="\n";

        unless (is_make_type(MAKE_NMAKE)) {
            $makefile.=".PHONY: ${package}.${target} ${package}.${target}.build ${package}.${target}.install ${package}.${target}.installlib ${package}.${target}.clean ${package}.${target}.cleanobjs ${package}.${target}.cleanlib ${package}.${target}.distclean ${package}.${target}.realclean\n";
            $makefile.="\n";
        }

        $makefile.="${package}.${target}: ${package}.${target}.build\n";
        $makefile.="\n";

        # build package build-type
        $makefile.="${package}.${target}.build: \$(${PACKAGE}${BLIBMACROSUFFIX})/\$(${PACKAGE}_${TARGET}${LIBMACROSUFFIX})\n";
        $makefile.="\n";
        if ($opts{tests}) {
            $makefile.="${package}.${target}.buildtests: \$(${PACKAGE}_${TARGET}${TSTBINMACROSUFFIX})\n";
            $makefile.="\n";
        }

        # clear plink debug flags (enabled by default) for non-debug targets
        # (might clear var for more general target; works here for now)
        if ($target !~ /(?:^|_)dbg(?:_|$)/) {
            $makefile.="\$(${PACKAGE}${BLOCMACROSUFFIX})/%.${target}${OB}: CPPDFLAGS=\n";
            $makefile.="\$(${PACKAGE}${BLOCMACROSUFFIX})/%.${target}${OB}: CPPDFLAGS_ALLOW_INLINE=\n";
            $makefile.="\$(${PACKAGE}${BLOCMACROSUFFIX})/%.${target}${OB}: CDFLAGS=\n";
            $makefile.="\$(${PACKAGE}${BLOCMACROSUFFIX})/%.${target}${OB}: FDFLAGS=\n";
        }
        if ($target =~ /(?:^|_)64(?:_|$)/) {
            $makefile.="\$(${PACKAGE}${BLOCMACROSUFFIX})/%.${target}${OB}: ARCHTUNE=\$(ARCHTUNE_64)\n";
        }

        # build - implicit targets

        ### H (mangle)
        if (is_make_type(MAKE_NMAKE) and not $noncompliant) {
            $makefile.="{\$(${PACKAGE}${LOCMACROSUFFIX})}.h\{\$(${PACKAGE}${BINCMACROSUFFIX})}.h:\n";
            $makefile.="\t\@\$(${PACKAGE}_${TARGET}_MKDIR) \$(${PACKAGE}${BINCMACROSUFFIX})\n";
            $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_PROCESS_INC) \"\$<\" \"\$(${PACKAGE}${BINCMACROSUFFIX})\"\n";
            $makefile.="\n";
        }

        ### CPP
        # unspeakable frobbing for Windows compiler; inserts dllimport/dllexport in shr targets
        my $export_defs; #="-D${GROUP}_API=\$(${PACKAGE}_${TARGET}_BDE_API_EXPORT)";
        #foreach my $depgroup ($group->getDependants()) {
        #    $export_defs.=" -D".ucmacro($depgroup)."_API=\$(${PACKAGE}_${TARGET}_BDE_API_IMPORT)";
        #}
        # some things must be explicitly imported even though they're already exported
        $export_defs.=" -D${GROUP}_DCL=\$(${PACKAGE}_${TARGET}_BDE_DCL_EXPORT)";
        foreach my $depgroup ($group->getDependants()) {
            $export_defs.=" -D".ucmacro($depgroup)."_DCL=\$(${PACKAGE}_${TARGET}_BDE_DCL_IMPORT)";
        }

        if (is_make_type(MAKE_NMAKE)) {
            # necessary to prevent compiler from finding the original unmangled header
            $makefile.="{\$(${PACKAGE}${LOCMACROSUFFIX})}.cpp\{\$(${PACKAGE}${BLOCMACROSUFFIX})}.${target}${OB}:\n";
            $makefile.="\t\@\$(${PACKAGE}_${TARGET}_MKDIR) \$(${PACKAGE}${BLOCMACROSUFFIX})\n";
            $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_F2FCP) \"\$<\" \"\$(\@D)\"\n";
            $makefile.="\t${ECHO}\$(COMMAND_PRE) \$(${PACKAGE}_${TARGET}_CXX) $build_target_flags{$target} \$(${PACKAGE}${INCMACROSUFFIX}) \$(${PACKAGE}_${TARGET}_BDE_CXXINCLUDE) \$(CPPFLAGS) \$(${PACKAGE}_${TARGET}_BDE_CXXFLAGS) $export_defs \$(CPPOPTFLAGS) \$(${PACKAGE}_${TARGET}_OUT_OPT) -Fd\"\$(${GROUP}${LOCMACROSUFFIX})/${group}.${target}.pdb\" -c \"\$(\@D)${FS}\$(<F)\"\n";
        } else {
            # rule to build test driver objs
            $makefile.="\$(${PACKAGE}${BLOCMACROSUFFIX})/%.${target}${OB}: \$(${PACKAGE}${LOCMACROSUFFIX})/%.cpp\n";
            $makefile.="\t\@\$(${PACKAGE}_${TARGET}_MKDIR) \$(${PACKAGE}${BLOCMACROSUFFIX})\n";
            $makefile.="\t\@\$(${PACKAGE}_${TARGET}_RM) \$@\n"; #clearmake
            $makefile.="\t${ECHO}\$(COMMAND_PRE) \$(${PACKAGE}_${TARGET}_CXX) $build_target_flags{$target} \$(${PACKAGE}${INCMACROSUFFIX}) \$(${PACKAGE}_${TARGET}_BDE_CXXINCLUDE) \$(CPPFLAGS) \$(${PACKAGE}_${TARGET}_BDE_CXXFLAGS) $export_defs \$(CPPOPTFLAGS) \$(${PACKAGE}_${TARGET}_OUT_OPT) \$(CC_COMMAND_POST)\n";

            # rule to build and run test driver binaries
            my $libs = join(' ', map { "\$(${GROUP}_${TARGET}_LIB_FLAG)$_.${target}" }
                                     ($group, $group->getDependants()));

            $makefile .= <<"EOF";

\$(${PACKAGE}${BLOCMACROSUFFIX})/%.${target}: \$(${PACKAGE}${BLOCMACROSUFFIX})/%.${target}${OB}
\t\@\$(${PACKAGE}_${TARGET}_RM) \$@
\t${ECHO}\$(COMMAND_PRE) \$(${PACKAGE}_${TARGET}_CXX) \$(${PACKAGE}_${TARGET}_OUT_OPT) \$(${GROUP}_${TARGET}_LIBPATH_FLAG)\$(${GROUP}${INSTLIBDIRMACROSUFFIX}) \$(NC_COMMAND_POST) $libs
\t${ECHO}\$(${PACKAGE}_${TARGET}_ALLTEST) \$@

EOF
        }

        $makefile.="\n";

        ### CC
        if (is_make_type(MAKE_NMAKE)) {
            $makefile.="{\$(${PACKAGE}${LOCMACROSUFFIX})}.c\{\$(${PACKAGE}${BLOCMACROSUFFIX})}.${target}${OB}:\n";
            $makefile.="\t\@\$(${PACKAGE}_${TARGET}_MKDIR) \$(${PACKAGE}${BLOCMACROSUFFIX})\n";
            $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_F2FCP) \"\$<\" \"\$(\@D)\"\n";
            $makefile.="\t${ECHO}\$(COMMAND_PRE) \$(${PACKAGE}_${TARGET}_CC) $build_target_flags{$target} \$(${PACKAGE}${INCMACROSUFFIX}) \$(${PACKAGE}_${TARGET}_BDE_CINCLUDE) \$(CFLAGS) \$(${PACKAGE}_${TARGET}_BDE_CFLAGS) $export_defs \$(COPTFLAGS) \$(${PACKAGE}_${TARGET}_OUT_OPT) -c \"\$(\@D)${FS}\$(<F)\"\n";
        } else {
            $makefile.="\$(${PACKAGE}${BLOCMACROSUFFIX})/%.${target}${OB}: \$(${PACKAGE}${LOCMACROSUFFIX})/%.c\n";
            $makefile.="\t\@\$(${PACKAGE}_${TARGET}_MKDIR) \$(${PACKAGE}${BLOCMACROSUFFIX})\n";
            $makefile.="\t\@\$(${PACKAGE}_${TARGET}_RM) \$@\n"; #clearmake
                $makefile.="\t${ECHO}\$(COMMAND_PRE) \$(${PACKAGE}_${TARGET}_CC) $build_target_flags{$target} \$(${PACKAGE}${INCMACROSUFFIX}) \$(${PACKAGE}_${TARGET}_BDE_CINCLUDE) \$(CFLAGS) \$(${PACKAGE}_${TARGET}_BDE_CFLAGS) $export_defs \$(COPTFLAGS) \$(${PACKAGE}_${TARGET}_OUT_OPT) \$(CC_COMMAND_POST)\n";
        }
        $makefile.="\n";

        ### AS
        if (is_make_type(MAKE_NMAKE)) {
            $makefile.="{\$(${PACKAGE}${LOCMACROSUFFIX})}.s\{\$(${PACKAGE}${BLOCMACROSUFFIX})}.${target}${OB}:\n";
        } else {
            $makefile.="\$(${PACKAGE}${BLOCMACROSUFFIX})/%.${target}${OB}: \$(${PACKAGE}${LOCMACROSUFFIX})/%.s\n";
        }
        $makefile.="\t\@\$(${PACKAGE}_${TARGET}_MKDIR) \$(${PACKAGE}${BLOCMACROSUFFIX})\n";
        unless (is_make_type(MAKE_NMAKE)) {
            $makefile.="\t\@\$(${PACKAGE}_${TARGET}_RM) \$@\n"; #clearmake
        }
        $makefile.="\t${ECHO}\$(COMMAND_PRE) \$(AS) \$(SFLAGS) \$(ASFLAGS) \$(${PACKAGE}_${TARGET}_ASFLAGS) \$(ASOPTFLAGS) \$(${PACKAGE}_${TARGET}_OUT_OPT) \$(NC_COMMAND_POST)\n";
        $makefile.="\n";

        ### RC
        if (is_make_type(MAKE_NMAKE) and $package =~ /scm$/) {
            $makefile.="{\$(${PACKAGE}${LOCMACROSUFFIX})}.rc\{\$(${PACKAGE}${BLOCMACROSUFFIX})}.${target}${OB}:\n";
            $makefile.="\t\@\$(${PACKAGE}_${TARGET}_MKDIR) \$(${PACKAGE}${BLOCMACROSUFFIX})\n";
            $makefile.="\t${ECHO}\$(COMMAND_PRE) \$(RC) \$(RCFLAGS) $build_target_flags{$target} \$(${PACKAGE}_${TARGET}_RCFLAGS) \$(RCOPTFLAGS) \$(${PACKAGE}_${TARGET}_OUT_OPT) \$(NC_COMMAND_POST)\n";
            $makefile.="\n";
        }

        # build -- make library
        if ($target =~ /(?:^|_)64(?:_|$)/) {
            $makefile.="\$(${PACKAGE}${BLIBMACROSUFFIX})/\$(${PACKAGE}_${TARGET}${LIBMACROSUFFIX}): ARCHTUNE=\$(ARCHTUNE_64)\n";
        }
        if (is_make_type(MAKE_NMAKE) and $TARGET=~/SHR/) {
            # For NMake DLL builds, we need to ensure that all possible headers that might be included have been mangled already.
            # Without calculating each object's deps explicitly, and because implict/suffix rules can't have dependency lists, the
            # only way to do this is to have the lib depend on the mangled headers FIRST and the objects SECOND. This in turn only
            # works because NMake can't parallelise and so must evaluate the deps in order.
            $makefile.="\$(${PACKAGE}${BLIBMACROSUFFIX})/\$(${PACKAGE}_${TARGET}${LIBMACROSUFFIX}): \$(${PACKAGE}${ALLMHDRMACROSUFFIX}) \$(${PACKAGE}_${TARGET}${ABSOBJMACROSUFFIX})\n";
        } else {
            $makefile.="\$(${PACKAGE}${BLIBMACROSUFFIX})/\$(${PACKAGE}_${TARGET}${LIBMACROSUFFIX}): \$(${PACKAGE}_${TARGET}${ABSOBJMACROSUFFIX})\n";
        }
        $makefile.="\t\@\$(${PACKAGE}_${TARGET}_MKDIR) \$(${PACKAGE}${BLIBMACROSUFFIX})\n";
        unless (is_make_type(MAKE_NMAKE)) {
            $makefile.="\t\@\$(${PACKAGE}_${TARGET}_RM) \$@\n"; #clearmake
        }
        $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_AR_PACKAGE) \$(${PACKAGE}_${TARGET}${ABSOBJMACROSUFFIX})\n";
        $makefile.="\n";

        if ($opts{tests}) {
            # test objects
            #$makefile.="\$(${PACKAGE}${BLOCMACROSUFFIX})/%.t.${target}${OB}: USER_CPPFLAGS = \$(${PACKAGE}${INCMACROSUFFIX}) $build_target_flags{$target}\n";
            #$makefile.="\n";
            #$makefile.="\$(${PACKAGE}${BLOCMACROSUFFIX})/%.t.${target}.t: \$(${PACKAGE}${BLOCMACROSUFFIX})/%.${target}${OB} \$(${PACKAGE}${BLOCMACROSUFFIX})/%.t.${target}${PACKAGE}${OB}\n";
            #$makefile.="\t${ECHO}\$(CXX) \$(LDFLAGS) \$(USER_LDFLAGS) \$(LDOPTFLAGS) ${OO}\$@ ${DM}\n";
            #$makefile.="\n";
        }

        # install package build-type
        $makefile.="${package}.${target}.install: ${package}.${target}.install ${package}.${target}.installlib ${package}.installhdr\n";
        $makefile.="\n";
        $makefile.="${package}.${target}.installlib: \$(${PACKAGE}${INSTLIBDIRMACROSUFFIX})/\$(${PACKAGE}_${TARGET}${LIBMACROSUFFIX})\n";
        $makefile.="\n";
        $makefile.="\$(${PACKAGE}${INSTLIBDIRMACROSUFFIX})/\$(${PACKAGE}_${TARGET}${LIBMACROSUFFIX}): \$(${PACKAGE}${BLIBMACROSUFFIX})/\$(${PACKAGE}_${TARGET}${LIBMACROSUFFIX})\n";
        $makefile.="\t\@\$(${PACKAGE}_${TARGET}_MKDIR) \$(${PACKAGE}${INSTLIBDIRMACROSUFFIX})\n";
        unless (is_make_type(MAKE_NMAKE)) {
            $makefile.="\t\@\$(${PACKAGE}_${TARGET}_RM) \$@\n"; #clearmake
        }
        $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_CP) \$(${PACKAGE}${BLIBMACROSUFFIX})/\$(${PACKAGE}_${TARGET}${WLDMACROSUFFIX}) \$(\@D)\n";
        $makefile.="\t\@echo '** installed \$(${PACKAGE}_${TARGET}${LIBMACROSUFFIX})'\n";
        $makefile.="\n";

        # uninstall package build-type
        $makefile.="${package}.${target}.uninstall: ${package}.${target}.uninstall ${package}.${target}.uninstalllib ${package}.uninstallhdr\n";
        $makefile.="\n";
        $makefile.="${package}.${target}.uninstalllib:\n";
        $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_RM) \$(${PACKAGE}${INSTLIBDIRMACROSUFFIX})/\$(${PACKAGE}_${TARGET}${WLDMACROSUFFIX})\n";
        $makefile.="\n";

        # clean package build-type
        $makefile.="${package}.${target}.clean: ${package}.${target}.cleanobjs ${package}.${target}.cleanlib\n";
        $makefile.="\n";
        $makefile.="${package}.${target}.cleanobjs:\n";
        $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_RM) \$(${PACKAGE}_${TARGET}${ABSOBJMACROSUFFIX})\n";
        $makefile.="\n";
        $makefile.="${package}.${target}.cleanlib:\n";
        $makefile.="\t${ECHO}\$(${PACKAGE}_${TARGET}_RM) \$(${PACKAGE}${BLIBMACROSUFFIX})/\$(${PACKAGE}_${TARGET}${LIBMACROSUFFIX})\n";
        $makefile.="\n";
        $makefile.="${package}.${target}.distclean: ${package}.${target}.clean ${package}.distclean\n";
        $makefile.="\n";
        $makefile.="${package}.${target}.realclean: ${package}.${target}.distclean ${package}.realclean\n";
        $makefile.="\n";
    }

    # checksum and verify package
    $makefile.="${package}.checksum: \$(${PACKAGE}${LOCMACROSUFFIX})/package/${package}.$SUM\n";
    $makefile.="\n";
    $makefile.="\$(${PACKAGE}${LOCMACROSUFFIX})/package/${package}.$SUM: \$(${PACKAGE}_ABSSRCDISTFILES_NOSUM)\n";
    $makefile.="\t${ECHO}md5sum ${DM} > \$@\n";
    $makefile.="\t\@md5sum \$@\n";
    $makefile.="\n";
    $makefile.="${package}.verify:\n";
    $makefile.="\t${ECHO}md5sum -c \$(${PACKAGE}${LOCMACROSUFFIX})/package/${package}.$SUM\n";
    $makefile.="\t\@md5sum \$?\n";
    $makefile.="\n";

    debug("Package '$package' dependants: @package_dependants");
    debug("Package '$package' members: @package_members");

    return { rules => $makefile };
}

#------------------------------------------------------------------------------
# Outputs

sub writeGroupMakefile ($;@) {
    my ($group,@makefile_parts)=@_;

    my $group_mk=isIsolatedPackage($group)
      ? $root->getPackageMakefileName($group)
      : $root->getGroupMakefileName($group);
    debug ("Writing $group_mk...");

    open GRP_MAKEFILE,">$group_mk" or
      fatal "Failed to open $group_mk for writing: $!";

    my $makefile_parts=join "",@makefile_parts;
    dedupeLines(\$makefile_parts);

    print GRP_MAKEFILE $makefile_parts;
    close GRP_MAKEFILE or fatal "Failed to close $group_mk: $!";
    message "Wrote $group_mk";
}

sub writePackageMakefile ($;@) {
    my ($package,@makefile_parts)=@_;

    my $package_mk=$root->getPackageMakefileName($package);
    debug ("Writing $package_mk...");

    open PKG_MAKEFILE,">$package_mk" or
      fatal "Failed to open $package_mk for writing: $!";

    my $makefile_parts=join "",@makefile_parts;
    dedupeLines(\$makefile_parts);

    print PKG_MAKEFILE $makefile_parts;
    close PKG_MAKEFILE or fatal "Failed to close $package_mk: $!";
    message "Wrote $package_mk";
}

sub writeGroupVarsfile ($;@) {
    my ($group,$uplid,@makefile_parts)=@_;

    my $group_vars=isIsolatedPackage($group)
      ? $root->getPackageVarsfileName($group,$uplid)
      : $root->getGroupVarsfileName($group,$uplid);
    debug ("Writing $group_vars...");

    open GRP_VARSFILE,">$group_vars" or
      fatal "Failed to open $group_vars for writing $!";

    my $makefile_parts=join "",@makefile_parts;
    dedupeLines(\$makefile_parts);

    print GRP_VARSFILE $makefile_parts;
    close GRP_VARSFILE or fatal "Failed to close $group_vars: $!";
    message "Wrote $group_vars";
}

sub writePackageVarsfile ($;@) {
    my ($package,$uplid,@makefile_parts)=@_;

    my $package_vars=$root->getPackageVarsfileName($package,$uplid);
    debug ("Writing $package_vars...");

    open PKG_VARSFILE,">$package_vars" or
      fatal "Failed to open $package_vars for writing $!";

    my $makefile_parts=join "",@makefile_parts;
    dedupeLines(\$makefile_parts);

    print PKG_VARSFILE $makefile_parts;
    close PKG_VARSFILE or fatal "Failed to close $package_vars: $!";
    message "Wrote $package_vars";
}

sub writeUniversalMakefile ($;@) {
    my (@makefile_parts)=@_;

    my $universal_mk=$root->getUniversalMakefileName();
    debug ("Writing $universal_mk...");

    open UNI_MAKEFILE,">$universal_mk" or
      fatal "Failed to open $universal_mk for writing $!";

    my $makefile_parts=join "",@makefile_parts;
    dedupeLines(\$makefile_parts);

    print UNI_MAKEFILE $makefile_parts;
    close UNI_MAKEFILE or fatal "Failed to close $universal_mk: $!";
    message "Wrote $universal_mk";
}

#------------------------------------------------------------------------------
# Changed files

sub changedGroupMakefile ($) {
    my $group=shift;

    my $group_dep=$root->getGroupDepFilename($group);
    my $group_mem=$root->getGroupMemFilename($group);
    my $group_mk =$root->getGroupMakefileName($group);

    return is_newer($group_mk,$group_dep,$group_mem);
}

sub changedPackageMakefile ($) {
    my $package=shift;

    my $package_dep=$root->getPackageDepFilename($package);
    my $package_mem=$root->getPackageMemFilename($package);
    my $package_mk =$root->getPackageMakefileName($package);

    return is_newer($package_mk,$package_dep,$package_mem);
}

#------------------------------------------------------------------------------
# Build Target Flags

# Derive a list of flag alternatives from a flag specification, e.g. 'dbg|exc'
# Any number of alternatives may be supplied. A '-' means blank, e.g. 'a|b|c|-'
# No alternatives may be supplied, in which case the passed value is the flag.
sub get_flags {
    my $flagspec=shift;

    if ($flagspec !~ /\|/) {
    return ($flagspec);
    }

    my @flags=split /\|/,$flagspec;
    foreach (@flags) {
    $_ = '' if $_ eq '-';
    }

    return @flags;
}

# Compute the product of two sets of flags; an 'outer join' in DB terms. The
# result of passing lists of N and M values is a new list with N*M values for
# N>=1 and M>=1. If either array is empty, it is promoted to a single empty
# string element. The first argument must be a mutable array, as in 'push'.
sub join_flags (\@@) {
    my $array = shift;
    my @flags1=@{ $array };
    my @flags2=@_;

    @$array = ();
    @flags1 = ('') unless @flags1;
    @flags2 = ('') unless @flags2;

    foreach my $flag2 (@flags2) {
        foreach my $flag1 (@flags1) {
            if (length $flag1) {
                if (length $flag2) {
                    push @$array, $flag1."_".$flag2;
                } else {
                    push @$array, $flag1;
                }
            } else {
                if (length $flag2) {
                    push @$array, $flag2;
                } else {
                    push @$array, '';
                }
            }
        }
    }

    return $array; #note the prototype!
}

sub get_build_targets {
    my ($specs,$required_specs) = @_;

    my @build_targets=();
    foreach my $flag_spec (@$specs) {
        join_flags(@build_targets,get_flags($flag_spec));
    }

    # filter out anything not containing a required flag
    foreach my $reqspec (@$required_specs) {
        @build_targets = grep { /$reqspec/ } @build_targets;
    }
    # changing to 'dbg|-' and 'opt|dbg' causes dups, remove them
    my %build_targets = map { getNormalisedTarget($_,0) => 1 } @build_targets;
    @build_targets = sort keys %build_targets;

    return wantarray ? @build_targets : \@build_targets;
}

# determine whether the given target is valid for the requested group
sub valid_target_for_group ($$) {
# capabilities replace this!
#    my ($target,$group)=@_;
#
#    # Win32 doesn't allow non-exc
#    return undef if $target!~/exc/ and is_make_type(MAKE_NMAKE);
#
#    # Forbid non-mt builds for groups that need threading
#    return undef if $target!~/mt/ and
#      not $BDE_BUILD_TARGET_NONMT_OK{$group};

    return 1;
}

#------------------------------------------------------------------------------
# Task::Action subroutines

sub make_groupandpackage_makefile($$$) {
    my ($root,$build_targets,$group)=@_;

    my (@packages,@package_makefiles,@package_nmakefiles);
    my $a_package_changed=0;

    if (isGroup($group)) {  #not for isolated packages
        @packages=map { getCachedPackage($_) } $group->getMembers();
        fatal("Failed to find package members for $group: $!")
            unless @packages;
    } else {
        @packages=($group);
    }

    foreach my $package (@packages) {
        my $package_changed=changedPackageMakefile($package);

        if ($package_changed >=0) {
            if ($FORCE or $package_changed) {
                $a_package_changed=1;
                set_make_type($root,MAKE_GMAKE);
                my $package_makefile=
                    generatePackageMakefile($package,$build_targets);
                if ($MAKE_PACKAGES or ($MAKE_GROUPS and isIsolatedPackage($package))) {
                    writePackageMakefile($package,$package_makefile->{rules});
                }
                push @package_makefiles,$package_makefile->{rules};

                if ($opts{nmake}) {
                    set_make_type($root,MAKE_NMAKE);
                    my $package_nmakefile=
                        generatePackageMakefile($package,$build_targets);
                    $package_nmakefile->{rules}=~s|/|\\|mg;
                    $package_nmakefile->{rules}=~s|^ +||mg;
                    $package_nmakefile->{rules}=~s|\s-(\S)| /$1|mg;
                    if ($MAKE_PACKAGES or ($MAKE_GROUPS and isIsolatedPackage($package))) {
                        writePackageMakefile($package,
                                $package_nmakefile->{rules});
                    }
                    push @package_nmakefiles,$package_nmakefile->{rules};
                }
            } else {
                message("$package makefile up to date");
            }
        } else {
            fatal("cannot make $package makefile - dependant file missing");
        }
    } #foreach package

    if ($MAKE_GROUPS and not isIsolatedPackage($group)) {
        my $group_changed=changedGroupMakefile($group);

        if ($group_changed >=0) {
            if ($FORCE or $group_changed or $a_package_changed) {
                set_make_type($root,MAKE_GMAKE);
                my $group_makefile=
                    generateGroupMakefile($group,$build_targets);
                writeGroupMakefile($group,
                        $group_makefile->{prerules},
                        $SEPARATOR,
                        @package_makefiles,
                        $SEPARATOR,
                        $group_makefile->{postrules}
                        );

                if ($opts{nmake}) {
                    set_make_type($root,MAKE_NMAKE);
                    my $group_nmakefile=
                        generateGroupMakefile($group,$build_targets);
                    $group_nmakefile->{prerules}=~s|/|\\|mg;
                    $group_nmakefile->{prerules}=~s|^ +||mg;
                    $group_nmakefile->{prerules}=~s|\s-(\S)| /$1|mg;
                    $group_nmakefile->{postrules}=~s|/|\\|mg;
                    $group_nmakefile->{postrules}=~s|^ +||mg;
                    $group_nmakefile->{postrules}=~s|\s-(\S)| /$1|mg;
                    writeGroupMakefile($group,
                            $group_nmakefile->{prerules},
                            $SEPARATOR,
                            @package_nmakefiles,
                            $SEPARATOR,
                            $group_nmakefile->{postrules}
                            );
                }
            } else {
                message("$group makefile up to date");
            }
        } else {
            fatal("cannot make $group makefile - dependant file missing");
        }
    }

    return 0;
}

sub make_groupandpackage_varsfile ($$$) {
    my ($root,$build_targets,$group,$uplid)=@_;

    my @packages;
    if (isGroup($group)) {  #not for isolated packages
        @packages=map { getCachedPackage($_) } $group->getMembers();
        fatal("Failed to find package members for $group: $!")
            unless @packages;
    } else {
        @packages=($group);
    }

    my @packagelevelvars=();

    foreach my $package (@packages) {
        my $makevarshdr.="# Make variables for '$package'\n".
            "# * This file is machine generated *\n";
        my $makevars="";
        foreach my $target (@$build_targets) {
            set_make_type($root,($uplid=~/windows/i)?MAKE_NMAKE:MAKE_GMAKE);
            unless (valid_target_for_group($target,$group)) {
                warning("$group does not support $target build");
                next;
            }
            $makevars.="\n".getBuildVariables($package,$target,$uplid)."\n";
        }

        if ($MAKE_PACKAGES) {
            writePackageVarsfile($package,$uplid,$makevarshdr,$makevars);
        }
        # for Group varsfile
        push @packagelevelvars,
             "# '$package'\n".
                 "BDEMAKE_INCLUDED_".ucmacro($package)."_VARS = 1\n".
                 $makevars;
    }

    if ($MAKE_GROUPS and not isIsolatedPackage($group)) {
        my $makevarshdr.="# Make variables for Group 'group'\n".
            "# * This file is machine generated *\n\n";

        my $grouplevelvars="BDEMAKE_INCLUDED_".ucmacro($group)."_VARS = 1\n\n";
        foreach my $target (@$build_targets) {
            set_make_type($root,($uplid=~/windows/i)?MAKE_NMAKE:MAKE_GMAKE);
            next unless valid_target_for_group($target,$group);
            $grouplevelvars.=getBuildVariables($group,$target,$uplid)."\n";
        }

        writeGroupVarsfile($group,$uplid,
                $makevarshdr, $grouplevelvars,
                @packagelevelvars
                );
    }

    return 0;
}

sub make_universal_makefile ($$@) {
    my ($root,$build_targets,@groups)=@_;

    set_make_type($root,MAKE_GMAKE);
    my $universal_makefile=generateUniversalMakefile($build_targets,@groups);
    writeUniversalMakefile($universal_makefile);
    if ($opts{nmake}) {
        set_make_type($root,MAKE_NMAKE);
        my $universal_nmakefile=generateUniversalMakefile($build_targets,
                @groups);
        $universal_nmakefile=~s|/|\\|mg;
        $universal_nmakefile=~s|^ +||mg;
        writeUniversalMakefile($universal_nmakefile);
    }

    return 0;
}

sub make_group_checksum ($$$) {
    my ($root,$build_targets,$group)=@_;

    my $metadir=$root->getTypeLocation(getType $group)
      .'/'.$group.'/'.(isIsolatedPackage($group)
              ? $PACKAGE_META_SUBDIR
              : $GROUP_META_SUBDIR
              );

    my $cwd=cwd();
    if ($MAKE_UNIVERSAL) {
        debug ("Writing checksum for $group...");
        chdir $root;
        if ($FORCE) {
            #<<BUG for adapters
            unlink $metadir.'/'.$group.".$SUM";
        }
        my $checksum=`gmake -s -f Makefile $group.checksum 2>&1`;
        chomp $checksum;
        message "$group checksum=$checksum";
        chdir $cwd;
    } else {
        debug ("Writing checksums for $group via group makefile...");
        chdir $metadir;
        unlink "$group.$SUM" if $FORCE;
        my $checksum=`gmake -s -f $group.$MK checksum 2>&1`;
        chomp $checksum;
        message "$group checksum=$checksum";
        chdir $cwd;
    }

    message "Wrote $group.$SUM";
    return 0;
}

#------------------------------------------------------------------------------

MAIN: {
    unless (exists $ENV{BDE_ROOT}) {
        warning("");
        warning("BDE_ROOT environment variable is not set.");
        warning("Recommended setting: BDE_ROOT=/bbcm/infrastructure");
        warning("");
    }
    BDE::Util::DependencyCache::setFileSystemRoot($root);

    verbose "using options:";
    verbose sprintf("%7s = '%s'",$_,$opts{$_}) foreach sort keys %opts;

    my %seen_targets;
    # add uniq'ing step, 20070601
    my @explicit_targets=grep !$seen_targets{$_}++,grep /_/,@target_specs;
    my $build_targets;

    if(!@explicit_targets) {
        # targets (UFIDs)
        foreach my $specid (@target_specs) {
            fatal("Invalid target '$specid'")
                unless exists $BDE_BUILD_TARGET_SPECS{$specid}
        }
        my @specs = map { $BDE_BUILD_TARGET_SPECS{$_} } @target_specs;
        $build_targets = [ get_build_targets(\@specs,\@required_specs) ];
    }
    else {
        $build_targets = [ @target_specs ];
    }

    # platforms (UPLIDs)
    @platform_specs = map { BDE::Build::Uplid->unexpanded($_) } @platform_specs;

    # filter out units that aren't buildable UORs
    @groups=map {
        my $group = $_;
        my $uor=getCachedGroupOrIsolatedPackage($group);
        $uor->isMetadataOnly() ? (warning("$group is meta-data only, skipping"),()) : $uor
    } @groups;
    message("generating makefiles for",scalar(@groups),"units of release: @groups");
    message("generating makefile variables for",scalar(@platform_specs),"platforms");
    message("-- $_") foreach @platform_specs;
    message("generating",scalar(@$build_targets),"makefile targets for",
            scalar(@target_specs),"build types: @target_specs");
    message("-- $_") foreach @$build_targets;
    message("extensions:",join(' ',$BDE::FileSystem::Make::MAKEFILE_EXTENSION,
                                   $BDE::FileSystem::Make::MAKEFILE_EXTENSION,
                                   $BDE::FileSystem::Make::MAKEVARS_EXTENSION));
    if ($MAKE_UNIVERSAL) {
        message("universal makefile name:",$BDE::FileSystem::Make::UNIVERSAL_MAKEFILE);
    }

    foreach my $group (@groups) {
        $factory->load($group);
    }

    my $mgr=new Task::Manager("makefile generation");

    if ($MAKE_VARS) {
        foreach my $group (@groups) {
            foreach my $uplid (@platform_specs) {
                $mgr->addAction(new Task::Action({
                            name     => "$group.$uplid.varsfile",
                            action   => \&make_groupandpackage_varsfile,
                            args     => [ $root,$build_targets,$group,$uplid ],
                            }));
            }
        }
    }

    if ($MAKE_GROUPS or $MAKE_PACKAGES) {
        foreach my $group (@groups) {
            my $act=$mgr->addAction(new Task::Action({
                        name     => "$group.makefile",
                        action   => \&make_groupandpackage_makefile,
                        args     => [ $root,$build_targets,$group ],
                        }));
        }
    }

    if ($MAKE_UNIVERSAL) {
        $mgr->addAction(new Task::Action({
                    name     => "universal.makefile",
                    action   => \&make_universal_makefile,
                    args     => [ $root,$build_targets,@groups ],
                    }));
    }

    if ($MAKE_CHECKSUMS) {
        foreach my $group (@groups) {
            my @requires;
            push @requires,"$group.makefile" if $MAKE_GROUPS;
            push @requires, map {"$group.$_.varsfile" } @platform_specs
                if $MAKE_VARS;
            $mgr->addAction(new Task::Action({
                        name     => "$group.checksum",
                        action   => \&make_group_checksum,
                        args     => [ $root,$build_targets,$group ],
                        requires => \@requires
                        }));
        }
    }

    $|=1;
    $mgr->dump() if $opts{debug};
    my $result = $mgr->run(8);

    fatal "Failed ($result)" if $result;

    exit 0;
}

#------------------------------------------------------------------------------
