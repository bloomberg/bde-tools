#!/bbs/opt/bin/perl -w
use strict;

my $usage = "Usage:
    $0 -f listfile
    $0 lib1 lib2 ...\n";

die $usage if @ARGV < 2;

my @list;
if ($ARGV[0] eq '-f') {
    die $usage if @ARGV > 2;
    open my $list, "<", $ARGV[1] or die "open $ARGV[1] failed: ($!)";
    @list = <$list>;
    close $list or die "close $ARGV[1] failed: ($!)";
    chomp @list;
}
else {
    @list = @ARGV;
}

@list = map { split } @list;

die "no libs found. $usage"
    unless @list;

my %list = map { $_ => 1 } @list;

sub parsefail {
    my $line = shift;
    die qq{Parse failed to understand: \"$line\"};
}

my %maparrow = (
    'callers'	=>	'<==',
    'deps'	=>	'==>',
);

my %revarrow = (
    '==>'	=>	'<--',
    '<=='	=>	'-->',
);

my %mapinfo;
my $maxlen = 0;

foreach my $lib (@list) {
    open my $call, "libanal $lib|" or die "open (libanal $lib) failed: ($!)";

    my $cursource;

    my ($source, $arrow, $revarrow);

    foreach my $line ( <$call> ) {
	chomp $line;
	my $lline = $line;
	$lline =~ s/^\s+//;
	my @field = split /\s+/, $lline;
	next if 2 > scalar @field;

	if ($field[0] eq '====') {
	    next if 2 == scalar @field;
	    if (3 == scalar @field && exists $maparrow{$field[2]}) {
		die "bad lib name" unless exists $list{$field[1]};
		$source = $field[1];
		$maxlen = length $source
		    if $maxlen < length $source;
		$arrow  = $maparrow{$field[2]};
		$revarrow  = $revarrow{$arrow};
	    }
	    else {
		parsefail $line;
	    }
	}
	else {
	    if (2 == scalar @field) {
		if (exists $list{$field[1]}) {
		    my ($dest, $count) = @field[1,0];
		    if ($dest ne $source) {
			$mapinfo{$source}{$dest}{$arrow} = $count;
			$mapinfo{$dest}{$source}{$revarrow} = $count;
		    }
		    else {        # $dest eq $source only happens once per $dest
			die "self reference struck twice ($line)"
			    if exists $mapinfo{$dest}{$dest};
			$mapinfo{$dest}{$dest} = $count;
		    }
		}
		# else skip the line
	    }
	    else {
		parsefail $line;
	    }
	}
    }
}

sub ordercheck {
    my ($subsubmi, $llib, $rlib) = @_;
    my $rcnt = (exists $subsubmi->{'-->'} and $subsubmi->{'-->'});
    my $lcnt = (exists $subsubmi->{'<=='} and $subsubmi->{'<=='});
    my $bigger = ($lcnt > $rcnt)
		|| ($lcnt == $rcnt && $llib gt $rlib);
    my $r;
    my $howmuch =
	$rcnt == 0                ? '<**'
	: $rcnt < $lcnt           ? '<**'
	: $lcnt == 0              ? '>>>'
	: ($r=$rcnt/$lcnt) >= 100 ? '>>>'
	: $r >= 10                ? '>>-'
	: $r > 2                  ? '>--'
	: $r > 1                  ? '>=='
	:                           '===';
    return ($bigger, $howmuch);
}

my %disparrow = (
    '-->' => '  to',
    '<==' => 'from',
);

foreach my $lib1 (sort keys %mapinfo) {
    my $submapinfo = $mapinfo{$lib1};
    foreach my $lib2 (sort keys %$submapinfo) {
	next if $lib2 eq $lib1;
	my $subsubmi = $submapinfo->{$lib2};
	my ($bigger, $howmuch) = ordercheck( $subsubmi, $lib1, $lib2 );
	next if $bigger;

	printf '%*3$s %4$s %*3$s:    ', $lib1, $lib2, $maxlen, $howmuch;
	# foreach my $arrow (values %maparrow, values %revarrow) {
	foreach my $arrow ('-->', '<==') {
	    if (exists $subsubmi->{$arrow}) {
		my $disparrow = $disparrow{$arrow};
		my $revarrow = $arrow;
		$revarrow =~ tr/-=/=-/;
		print   " $disparrow(",
			(sprintf    "%5d,%5d",
				    $subsubmi->{$arrow},
				    $subsubmi->{$revarrow}
			    ),
			")",
	    }
	    else {
		print   "                 ";
	    }
	}
	print "\n";
    }
}
