#!/bbs/opt/bin/perl -w

use strict;

use FindBin ();
use lib '/bbsrc/bin/prod/lib/perl';
use lib "$FindBin::Bin/../../lib/perl";
use lib "$FindBin::Bin";

# use lib "/home/jmacd/bin";

use uorscan qw(libmap libgrepkey init_metadir);

use IO::File;

# init_metadir(1);

sub print_one {
    my( $sym, $info ) = @_;
    print "$sym:\n";
    print "\t$_\t$info->{$_}\n" for sort keys %$info;
}

my @alluors;

my $nowarn_default;
my $nowarn;

sub getalluors {
    @alluors = sort (libgrepkey('.'));
}

sub count {
    my ($command,$pattern) = @_;
    my %total;
    my $list;
    if ($pattern) {
	$list = [ sort (libgrepkey($pattern)) ];
    }
    else {
	getalluors unless @alluors;
	$list = \@alluors;
	$pattern = 'ALL Uors';
    }
    for my $uor (@$list) {
	my $info = libmap( $uor );
	if (exists $info->{group}) {
	    ++$total{sub};
	}
	else {
	    ++$total{ $info->{type} };
	}
	++$total{total};
    }
    printf "Scanning for: %s\n"
          ."    Groups: %d, Packages (under groups): %d\n"
          ."    Packages (standalone): %d\n"
	  ."    Total: %d\n",
	  $pattern, @total{ qw( group sub package total ) };
}

sub grepc {
    my ($command,$argstr) = @_;
    my ($pattern, @list) = split /\s+/, $argstr;
    $pattern =~ s/'/'"'"'/g;
    for my $source (@list) {
	my $list;
	my ($uorpat,$ext) = $source =~ m/ ^ ( [^.]* ) ( (?: \. .* )? ) $ /x;
	if (defined $uorpat) {
	    $list = [ sort (libgrepkey($uorpat)) ];
	}
	else {
	    getalluors unless @alluors;
	    $list = \@alluors;
	}
	$ext ||= '.*';

	for my $uor (@$list) {
	    my $info = libmap( $uor );
	    system( "grep '$pattern' /dev/null $info->{metadir}/$uor$ext 2>/dev/null" );
	}
    }
}

my @hard;

sub hard {
    my ($command,$pattern) = @_;
    unless (@hard) {
	getalluors unless @alluors;
	UORSCAN:
	for my $uor (@alluors) {
	    my $uorbase = $uor;
	    $uorbase =~ s{ .* / } {}x;
	    my $metadir = (libmap( $uor ))->{metadir};
	    my $memfile = "$metadir/$uorbase.mem";
	    if (-f $memfile) {
		open my $fd, '<', $memfile
		    or warn "open failed for $memfile ($!)\n", next UORSCAN;
		while (<$fd>) {
		    if ( /^# *\[HARD VALIDATION\] *$/ ) {
			push @hard, $uor;
			next UORSCAN;
		    }
		}
	    }
	}
    }
    print "Hard validation is turned on for:\n";
    my $count = 1;
    for my $uor ( $pattern ? (grep { /$pattern/ } @hard) : (@hard) ) {
	my $width = length($uor);
	my $tabwidth = int($width/8) + 1;
	if ($count > 1 && ($count+$tabwidth) > 10) {
	    print "\n";
	    $count = 1;
	}
	print "\t$uor";
	$count += $tabwidth;
    }
    print "\n" unless $count == 1;
}

sub quit {
    exit(0);
}

sub scan_dir {
    my $dir = shift;
    my @files;
    my @dirs;

    opendir my $dh,$dir
	or die "Failed opendir $dir ($!)";

    while (my $base = readdir $dh) {
	next if $base =~ /^\.\.?$/;
	my $path = "$dir/$base";
	if (-d $path) {
	    push @dirs, $base;
	}
	else {
	    push @files, $base;
	}
    }
    return \@dirs, \@files;
}

my $ONE_DAY = 60*60*24;
my $HALF_DAY = $ONE_DAY/2;

$| = 1; # make sure that system() output if interleaved cleanly to STDOUT

sub file_info {
    my ($file,$trim) = @_;
    $trim ||= '';
    my $lsinfo = `ls -ld $file`;
    $lsinfo =~ s{ /.*/ (?=$trim) }{}x;
    return "\t$lsinfo";
}

# To prevent deletions until testing is complete
# my $echo = "echo '	    -- delete turned off during development, would have run:
	    # '";
my $echo = "";

sub blow_away {
    my ( $fullpath, $msg, $days, $rcspath ) = @_;

    print "$msg\n";

    my $prefix        = '**';
    my $rcs_to_delete = '';
    my $rcs_info      = '';
    if ($rcspath && -f $rcspath) {
	$prefix = '** both';
	$rcs_to_delete = "\t-- and its little dog, RCS, too.\n";
	$rcs_info = file_info( $rcspath, 'RCS/' );
    }

    my @stat_info = stat $fullpath;
    my $file_info = file_info( $fullpath );
    my $delete_time = $^T - ($days*$ONE_DAY+$HALF_DAY);

    if ($delete_time >= $stat_info[9]) {
	# Time to say goodbye
	print $rcs_to_delete,
	    "\t$prefix being DELETED\n";
	system( "${echo}arm -rf $fullpath" );
	system( "${echo}arm -rf $rcspath" )
	    if $rcs_to_delete;
	print $file_info, $rcs_info, "\n";
    }
    else {
	my $expiry_days = int( ($stat_info[9] - $delete_time) / $ONE_DAY );
	print $rcs_to_delete,
	    "\t$prefix to be DELETED in $expiry_days days\n";
	print $file_info, $rcs_info;
	if (-d _) {
	    print "	ls -Al of directory contents\n";
	    system( "ls -Al $fullpath|sed -e 's/^/	/'" );
	}
	print "\n";
    }
}

my %skip_uor = ( big => 1, twoline => 1 );

sub check_one {
    my ($uor, $info, $explicit) = @_;
    my $dir     = $info->{dir};
    my $metadir = $info->{metadir};
    my $type    = $info->{type};
    my $imsg = "$uor ($metadir):\n";

    my $initmsg = sub {
	my $msg = $imsg
	    and $imsg = '';
	return $msg;
    };

    if (exists $skip_uor{$uor}) {

	return unless $explicit;

	print $initmsg->(),
	    "\t-- Examining uor '$uor' by explicit request.\n\n";
    }
    my $gid = (stat $metadir)[5];
    my $either = 0;
    unless (getgrgid($gid) eq 'sibuild') {
	++$either;
	print $initmsg->(),
	    "\t** Library not owned by group sibuild\n",
	    ;
    }
    unless ( -g _ ) {
	++$either;
	print $initmsg->(),
	    "\t** Library does not have setgid permission turned on\n",
	    ;
    }
    print file_info($metadir), "\n" if $either;

    my $uorpat = $uor;
    $uorpat =~ s{.*/}{};
    $uorpat = quotemeta $uorpat;

    my $rcsdir = "$metadir/RCS";
    my $rcsexists = -d $rcsdir;
    my %rcsfiles;
    my %metafiles;

    if (! $rcsexists) {
	print $initmsg->(),"\t** Contains no RCS directory!\n\t** Probably needs rcsthismeta\n\n";
    }
    else {
	$gid = (stat _)[5];
	$either = 0;
	unless (getgrgid($gid) eq 'sibuild') {
	    ++$either;
	    print $initmsg->(),
		"\t** RCS sub-dir not owned by group sibuild\n",
		;
	}
	unless ( -g _ ) {
	    ++$either;
	    print $initmsg->(),
		"\t** RCS sub-dir does not have setgid permission turned on\n",
		;
	}
	print file_info($rcsdir), "\n" if $either;
	my ($rcs_dirs_ref, $rcs_files_ref) = scan_dir( $rcsdir );
	blow_away( "rcsdir/$_",
		($initmsg->()."\t** Directory in RCS ($_)"),
		2 )
	    for @$rcs_dirs_ref;
	for my $file (@$rcs_files_ref) {
	    if ($file =~ m/ ^ ( .* ) ,v $ /x) {
		++$rcsfiles{$1};
	    }
	    else {
		blow_away( "$rcsdir/$file",
			($initmsg->()."\t** Non-RCS file in RCS ($file)"),
			2 );
	    }
	}
    }

    my ($dirs_ref, $files_ref) = scan_dir( $metadir );
    for my $dir (@$dirs_ref) {
	next if $dir eq 'RCS';
	next if $dir eq 'cache';
	blow_away( "$metadir/$dir",
		($initmsg->()."\t** Unexpected directory ($dir)"),
		7 );
    }
    METAITEM:
    for my $base (@$files_ref) {
	++$metafiles{$base};
	my $path = "$metadir/$base";
	if ($base =~ m/ ^ $uorpat \. [\w]+ $ /x) {
	    if ( $base eq "$uor.lck" ) {
		print $initmsg->(),
		    "\t** Library is LOCKED ($base)\n",
		    file_info($path),
		    "\n",
		    ;
		next METAITEM;
	    }
	    elsif ( ! exists $rcsfiles{$base} ) {
		print $initmsg->(),
		    "\t** No RCS copy for file ($base)\n",
		    "\t** Probably needs: rcsthismeta\n",
		    file_info($path),
		    "\n",
		    ;
		next METAITEM;
	    }
	    my $mode = (stat $path)[2];
	    if ($mode & 0222) {
		print $initmsg->(),
		    "\t** Writeable copy of file ($base)\n",
		    "\t** Probably needs: aci -u (to check in the change)\n",
		    "\t**             or: aco -u (to revert to the previous version)\n",
		    file_info($path),
		    "\n",
		    ;
	    }
	    if ($base eq "$uor.dep") {
		my $save = $nowarn_default;
		$nowarn_default = 1;
		dep_1_check( $path );
		$nowarn_default = $save;
	    }
	    next METAITEM;
	}
	else {
	    # Not a legit metadata file, decide how long to let it live:
	    # Live short and die for common known junk patterns:
	    for my $m_ref (
			[   qr/ ^ $uorpat \. [\w]+ ,v $ /x,
			    30,
			    "RCS file not in RCS subdir" ],
			[   qr/ ^ nohup\.out $ /x,
			    1,
			    "robocop scratch file" ],
			[   qr/ ^ \# .* \# \,? v? $ /x,
			    1,
			    "Emacs scratch file" ],
			[   qr/ \~ \,? v? $ /x,
			    1,
			    "Emacs scratch file" ],
			[   qr/ _foo\.c $ /x,
			    0,
			    "testLib scratch file" ],
		    ) {
		my ($pat, $duration, $msg) = @$m_ref;
		if ($base =~ m/$pat/) {
		    blow_away(
			    $path,
			    ($initmsg->()
				. "\t** $msg ($base)"),
			    $duration,
			    "$metadir/RCS/$base,v",
			);
		    next METAITEM;
		}
	    }
	    # Live longer, but still eventually die, for other junk
	    # (It lives longer in case it isn't junk but a new form
	    # of official real file that needs to be kept.  That gives
	    # time to update this program before the hammer falls.
	    blow_away(
		    $path,
		    ($initmsg->()
			. "\t** Unexpected file ($base)"),
		    10,
		    "$metadir/RCS/$base,v",
		);
	    next METAITEM;
	}
    }
    for my $file (keys %rcsfiles) {
	next if exists $metafiles{$file};
	my $relpath = "RCS/$file,v";
	my $fullpath = "$metadir/$relpath";
	if ($file =~ m{ ^ $uorpat \. [\w]+ $ }) {
	    print $initmsg->(),
		"\t** RCS file is not checked out ($file)\n",
		file_info($fullpath),
		"\n",
		;
	}
	else {
	    blow_away( $fullpath,
		    ($initmsg->()."\t** Non-metadata RCS file ($relpath)"),
		    7,
		);
	}
    }
    print "\n" unless $imsg;
}

sub check {
    my ($command, $arg) = @_;
    if ($arg) {
	for my $uor (split ' ', $arg) {
	    if (my $info = libmap($uor)) {
		check_one($uor,$info,1);
	    }
	    else {
		print "No uor found for ($uor)";
		my @list = sort(libgrepkey($uor));
		if (@list) {
		    print ".  Perhaps you want:\n";
		    print "\t$_\n" for @list;
		}
		else {
		    print ", and no uor matches it either.\n";
		}
	    }
	}
    }
    else {
	for my $uor (sort(libgrepkey('.'))) {
	    my $info = libmap($uor);
	    check_one($uor,$info,0);
	}
    }
}

sub list {
    my ($command, $arg) = @_;
    my $result;
    if ($result = libmap($arg)) {
	print_one( $arg, $result );
    }
    else {
	print "No info for: $arg\n";
    }
}

sub runlist {
    my ($command, $arg) = @_;
    foreach my $uor (getalluors) {
	my $uorinfo = libmap( $uor );
	my $list =
	    join( ' ',
		"uor='$uor'",
		map {
		    exists $uorinfo->{$_} ? " $_='$uorinfo->{$_}'"
		    :                       " $_="
		} qw[ dir metadir symname type type group ]
	    );
	print $list, "\n";
    }
}

sub match {
    my ($command, $arg) = @_;
    foreach my $uor (sort (libgrepkey($arg))) {
	print_one( $uor, libmap( $uor ) );
    }
}

sub refresh {
    my ($command, $arg) = @_;
    $ENV{UOR_RELOAD}++;
    init_metadir(1);
}

sub warn_func {
    my ($command, $arg) = @_;
    $nowarn = ($command =~ m/^n/) ? 1 : 0;
}

my %valid_prefix = (
	weak	=> 1,
	codep	=> 1,
    );

sub dep_1_check {
    my $file = shift;
    open my $fd, '<', $file
	or warn "Unable to open file $file ($!)\n", return;

    my $prev_prefix = '';
    my $prev_uor    = '';
    my $prev_line   = '';

    my %seen;
    my %dups;

    my $nowarn_use =
	defined( $nowarn )              ? $nowarn
	: defined( $nowarn_default)     ? $nowarn_default
	:                                 0;

    while (my $line = <$fd>) {
	# skip blank and comment lines
	next if $line =~ /^\s*$/;
	next if $line =~ /^\s*#/;
	chomp $line;

	my $warn_trailer = "\n   at file: $file, line: $., text: '$line'\n";

	my ($leadbl,$prefix,$uor,$trailbl)
	    = $line =~ /^ (\s*) (?: (\w+) : )? (\S* (?: .*\S)? ) (\s*) $/x;

	$prefix ||= '';
	$uor    ||= '';
	if ($prefix lt $prev_prefix
		or ($prefix eq $prev_prefix and $uor lt $prev_uor)) {
	    warn "Entries out of order. ($prev_line) should not come before$warn_trailer"
		unless $nowarn_use;
	}
	($prev_prefix,$prev_uor,$prev_line) = ($prefix,$uor,$line);

	++$dups{$uor} if exists $seen{$uor};
	{   my $use = $prefix || "strong";
	    push @{$seen{$uor}}, "line $. (as $use)";
	}

	if ($leadbl) {
	    warn "Leading whitespace (not an error)$warn_trailer"
		unless $nowarn_use;
	}

	if ($trailbl) {
	    warn "Trailing whitespace (not an error)$warn_trailer"
		unless $nowarn_use;
	}

	if ($prefix && ! $valid_prefix{$prefix}) {
	    warn "Unknown prefix ($prefix)$warn_trailer";
	}

	my $libinfo;
	if ($libinfo = libmap($uor)) {
	    if (exists $libinfo->{group}) {
		my $group = $libinfo->{group};
		warn "Depending upon sub-package ($uor) instead of group ($group)$warn_trailer";
	    }
	}
	else {
	    my $extra =
		($uor =~ m{[^\w/~]})
		    ? ' - contains invalid characters'
		    : '';
	    warn "Unknown library ($uor)$warn_trailer";
	}
    }
    for my $adup (sort keys %dups) {
	warn( "Repeated references to library ($adup):\n   "
		. join( ", ", @{$seen{$adup}})
		. "\n   in file: $file\n\n" );
    }
}

sub depcheck {
    my ($command, $arg) = @_;
    dep_1_check($_) for split ' ', $arg;
}

sub dupfunc {
    my ($command, $arg) = @_;
    print "Command ($command) is ambiguous.  Provide more letters of the command name\n";
}

my @cmdinfo = (
    [ 'check',		\&check,  'scan UOR metadata for irregularities (specified UOR or ALL)' ],
    [ 'count',		\&count,  'number of UORs (ALL or matching pattern arg)' ],
    [ 'depcheck',	\&depcheck,  'scan a dep-format file, ensure all uors are valid' ],
    [ 'grep',		\&grepc,  'PATTERN WHICH - grep metadata files' ],
    [ 'hard',		\&hard,   'list UORs with HARD VALIDATION enabled (ALL or matching pattern arg)' ],
    [ 'help',		\&help,   'show this descriptive info' ],
    [ 'list',		\&list,   'info about specified UOR arg' ],
    [ 'match',		\&match,  'info about UORs that match pattern arg' ],
    [ 'refresh',	\&refresh,  'force a reload of the uor data cache' ],
    [ 'runlist',	\&runlist,  'list info about all uors as shell vars, ready to pass to a command' ],
    [ 'nowarnings',	\&warn_func,  'suppress warning messages' ],
    [ 'warnings',	\&warn_func,  'issue warning messages' ],
    [ 'quit',		\&quit,   'terminate program' ],
);

my %cmdfunc;

{
    my %shortfunc;
    my %dupfunc;
    for my $cmdinfo (@cmdinfo) {
	my ($name, $func, $desc) = @$cmdinfo;
	$cmdfunc{$name} = $func;
	while (length $name) {
	    $dupfunc{$name} = \&dupfunc
		if exists $shortfunc{$name};
	    $shortfunc{$name} = $func;
	}
	continue {
	    chop $name;
	}
	for my $dup (keys %dupfunc) {
	    delete $shortfunc{$dup};
	}
    }
    # order is critical here (last definition wins)
    # priority  1: keep the entry that is the full name
    # priority  2: warn if this string starts multiple commands
    # priority  3: use the command that starts with this string
    %cmdfunc = ( %shortfunc, %dupfunc, %cmdfunc );
}

sub help {
    for my $cmdinfo (@cmdinfo) {
	my ($name, $func, $desc) = @$cmdinfo;
	printf "  %11s - %s\n", $name, $desc;
    }
    print "A truncated command name can be used as long as it is unambiguous\n";
}

my $pipe_format;

sub do_command {
    my $fullcommand = shift;

    for my $cmd (split ';', $fullcommand) {
	chomp $cmd;
	$cmd =~ s/\s*$//;
	$cmd =~ s/^\s*//;

	# ignore blank and comment lines
	next unless $cmd =~ /\S/;

	print "# START: $cmd\n"
	    if $pipe_format;
	unless ($cmd =~ /^ \#/x) {
	    my ($command, $cmdarg) = split ' ', $cmd, 2;

	    if (my $cfunc = $cmdfunc{$command}) {
		$cfunc->( $command, $cmdarg );
	    }
	    else {
		warn "Unknown command ($command) ignored.\n";
	    }
	}
	print "#   END: $cmd\n"
	    if $pipe_format;
    }
}

if (@ARGV && $ARGV[0] eq '--pipe') {
    ++$pipe_format;
    shift;

    autoflush STDERR 1;
    autoflush STDOUT 1;
}

if (@ARGV) {
    do_command( join ' ',@ARGV );
}
else {
    autoflush STDOUT 1;
    print "command? (help to get list) "
	unless $pipe_format;
    INPUTLOOP:
    while( <> ) {
	do_command( $_ );
    }
    continue {
	print "command? "
	    unless $pipe_format;
    }
    print "\n"
	unless $pipe_format;
}

__END__

=head1 NAME

uorinfo - find information about uor's

=head1 SYNOPSIS

    $ uorinfo
    <command> ...

    $uorinfo command [arg]... [';' command ...]

=head1 DESCRIPTION

Provides a number of commands related to UOR's.

=over 4

=item * check [uor]...

Do an integrity check of the selected uor's, or if none are specified,
checks all uor's (used in nightly check).

=item * depcheck file [file]...

Does an integrity check on one of more .dep files.

=item * list uor

Displays information about a uor.

=item * match PATTERN

Display information about every uor that matches PATTERN.

=item * runlist

Display info about all uors, one per line, as shell variable assignments.
The output can then be used to create a script that uses the info to
control what is done (or not done) for every uor.

=item * grep PATTERM uor.ext|uor|.ext| ...

Runs the system grep program with the specified PATTERM on one or
more files.  The files can be  specified in a number of ways:

=over 4

=item - uor.ext

the name file is grepped.

=item - uor

all of the metadata files for uor are grepped

=item - .ext

the speciifed metadata file is examined from every uor

=item - <no argument>

all metadata files in all uors are examined.

=back

=item * hard

UORs that have HARD VALIDATION turned on are listed

=item * refresh

the cache of uor data will be reloaded.  This command is used
in a cron job to keep the cache up to date, but it can be done
manually if a new uor has been created and you need to have
uorinfo be aware of the change.  You can also use this command
if the cache gets corrupted (you'll get some sort of error
message from the Storable module, either about a version
mismatch, or about wrong byte-order.

=item * count [PATTERN]

retuns a count of all UORs (if no PATTERN is specified), or the
numnber of UORs that match PATTERN if one is specified.

=item * [no]warnings

turns on [or off] whether warnings are issued when checking .dep
files for sort order and trailing blanks.  If neither command
has been specified, the default is warnings when specific files
are being checked, but nowarnings when all files are being check
during the "check" processing.

=item * help

display a list of known commands

=item * quit

exit the program

=back
