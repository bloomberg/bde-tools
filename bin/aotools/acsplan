#!/bbs/opt/bin/perl -w

use strict;

use FindBin ();
use lib '/bbsrc/bin/prod/lib/perl';
use lib "$FindBin::Bin/../../lib/perl";
use lib "$FindBin::Bin";

use Getopt::Long;
use Storable;
use lib "/home/jmacd/bin";
use uorscan;

sub ask_overwrite {
    my $file = shift;
    warn "$file already exists\n";
    $| = 1;
    print "OK to overwrite it? ";
    open my $tty, '<', '/dev/tty'
	or die 'Cannot open /dev/tty to verify proceeding';
    my $answer = <$tty>;
    unless ($answer =~ /^[yY]/) {
	die "OK, then, aborting\n";
    }
}

sub getoptsfile {
    my $srcfile = shift;

    if (! -f $srcfile) {
	my @rcsinfo = `rlog -h $srcfile 2>&1`;
	my @notfound = grep { /No such file or directory/ } @rcsinfo;
	if (@notfound) {
	    warn "$srcfile does not exists, creating a new one\n";
	    $srcfile = "/home/tmarshal/newlib/package/newlib.opts.acsplan";
	}
	else {
	    die "$srcfile does not exist, but an RCS copy does - you figure out why and fix it!";
	}
    }

    open my $src, '<', $srcfile
	or die "cannot open input $srcfile ($!)";

    # Canonical format (on input):
    #   prefix:
    #     bunch of lines, match anything except badstart
    #   badstart:
    #     /^ \s* \* \s+ _ \s+ _BAD_SYMBOLS \s* = \s* \\ \s* $/
    #   badelement (repeats zero or more times):
    #     /^ \s* lib (.+) \.a\[ (.+) \]\: (\S+) \s* \\ \s* $/
    #   badterminator (one of):
    #      traditionalbadterminator is badelement without trailing backslash:
    #         /^ \s* lib (.+) \.a\[ (.+) \]\: (\S+) \s* $/
    #      blankbadterminator (blank line):
    #         /^ \s* $/
    my $badstart = qr{^ \s* \* \s+ _ \s+ _BAD_SYMBOLS \s* = \s* \\ \s* $}x;
    my $badelement_detail = qr{^ ( lib .+ \.a\[ .+ \]\: \S+ ) }x;
    my $badelement_cont = qr{^ \s* $badelement_detail \s* \\ \s* $}x;
    my $badelement_final = qr{^ \s* $badelement_detail? \s* $}x;
    my $badelement_trailer = "# END of _BAD_SYMBOLS\n";

    my @prefix;		# lines that preceed the BAD_SYMBOLS chunk
    my @suffix;		# lines that follow the BAD_SYMBOLS chunk
    my @details;	# the detail elements of BAD_SYMBOLS

    my $stage = 1;

    while( defined( my $line = <$src>) ) {
	if( $stage == 1 ) {
	    unless( $line =~ $badstart ) {
		push @prefix, $line;
		next;
	    }
	    $stage = 2;
	    next;
	}
	if( $stage == 2 ) {
	    if( $line =~ $badelement_cont ) {
		push @details, $1;
		next;
	    }
	    if( $line =~ $badelement_final ) {
		push @details, $1
		    if defined $1;
		$stage = 3;
		next;
	    }
	    chomp $line;
	    die "unrecognized line in file $srcfile\n    middle of _BAD_SYMBOLS section: ($line)";
	}
	if( $stage == 3 ) {
	    next if $line =~ /^\s*$/;
	    $stage = 4;
	}
	if( $stage == 4 ) {
	    next if $line =~ /^\s*#\s*END\s+of\s+_BAD_SYMBOLS\s*$/;
	    $stage = 5;
	}
	# stage 5
	push @suffix, $line;
    }

    return \@prefix, \@details, \@suffix;
}

sub putoptsfile {
    my( $dstfile, $prefix, $detail, $suffix ) = @_;

    open my $dst, '>', $dstfile
	or die "cannot open output $dstfile ($!)";

    # Canonical format (on output):
    #   prefix:
    #     bunch of lines, match anything except badstart
    #   badstart:
    #     /^ \* \t _ \t _BADSYMBOLS \t = \t \\ $/
    #   badelement (repeats zero or more times):
    #     /^ lib (.+) \.a\[ (.+) \]\: (\S+) \t \\ $/
    #   blankbadterminator (blank line):
    #     /^$/

    print $dst
	@$prefix,
	"*\t_\t_BAD_SYMBOLS\t=\t\\\n",
	(map { "$_\t\\\n" } @$detail),
	"\n",
	"# END of _BAD_SYMBOLS\n",
	@$suffix;
}

sub expand_details {
    my $list = shift;
    my %hash;

    # each entry in list is:
    # adddetail|deldetail lib obj1 [obj2 ...] sym
    foreach my $entry ( @$list ) {
	my $entries = [ @$entry ];
	my $lib     = shift @$entries;
	my $sym     = pop   @$entries;
	foreach my $obj (@$entries) {
	    ++$hash{ "lib$lib.a[$obj]:$sym" };
	}
    }
    return \%hash;
}

sub editopts {
    my( $srcfile, $dstfile, $libinfo ) = @_;
    my $adds        = (exists $libinfo->{adddetail})  && $libinfo->{adddetail};
    my $deletes     = (exists $libinfo->{deldetail})  && $libinfo->{deldetail};

    -f $dstfile
	and ask_overwrite( $dstfile );

    my( $prefix, $detail, $suffix ) = getoptsfile( $srcfile );


    my $adddetails = { };
    $adddetails = expand_details( $adds    ) if $adds;
    my $deldetails = { };
    $deldetails = expand_details( $deletes ) if $deletes;

    # filter out adds and deletes, add will be replaced later
    my @keepdetails =
	grep { ! ($deldetails->{$_} || $adddetails->{$_}) } @$detail;

    my @finaldetails = sort @keepdetails, keys(%$adddetails);

    putoptsfile( $dstfile, $prefix, \@finaldetails, $suffix );
}

sub getdepfile {
    my $srcfile = shift;

    die "$srcfile does not exist - you figure out why and fix it!"
	unless -f $srcfile;

    open my $src, '<', $srcfile
	or die "cannot open input $srcfile ($!)";

    # Canonical format (on input):
    #   prefix:
    #     # $Id .* $ line (optional)
    #   element:
    #     blank or comment *
    #     detail:
    #       lib
    #       weak:lib

    my @prefix;		# optional $Id $ line
    my $cur_comment = [];
    my %comments;
    my %stronglibs;
    my %weaklibs;

    my $firstline = 1;

    while( defined( my $line = <$src>) ) {
	if( $firstline ) {
	    $firstline = 0;
	    if( $line =~ /^\s* # \s* \$Id /x ) {
		# only one optional prefix line can be present
		push @prefix, $line;
		next;
	    }
	}
	# collect comment and blank lines, attach them to the next
	# "real" line
	if( $line =~ /^ \s* (\#.*)? $/x ) {
	    push @$cur_comment, $line;
	} elsif( $line =~ /^ \s* (weak:)? (\S+) \s* $/x ) {
	    $comments{$2} = $cur_comment;
	    $cur_comment = [];
	    defined $1 ? ++$weaklibs{$2} : ++$stronglibs{$2};
	} else {
	    chomp $line;
	    die "unrecognized line in middle of _BAD_SYMBOLS section: ($line)";
	}
	next;
    }

    return \@prefix, \%comments, \%stronglibs, \%weaklibs, $cur_comment;
}

sub expand_deps {
    my $list = shift;
    my %hash;

    # each entry in list was:
    # adddep|deldep|addweak|delweak srclib dstlib [dstlib ...]
    # but the initial key has been removed, leaving:
    # srclib dstlib [dstlib ...]
    foreach my $entry ( @$list ) {
	my @entry = @$entry;
	my $slib    = shift @entry;
	@hash{ @entry } = (1) x @entry;
    }
    return \%hash;
}

sub putdepfile {
  my( $file, $prefix, $strong, $weak, $suffix ) = @_;

  open my $dst, '>', $file
      or die "cannot open output $file ($!)";

  print $dst
      @$prefix,
      @$strong,
      @$weak,
      @$suffix;
}


sub editdep {
    my( $srcfile, $dstfile, $libinfo ) = @_;
    my $adds        = (exists $libinfo->{adddep})  && $libinfo->{adddep};
    my $weakadds    = (exists $libinfo->{addweak}) && $libinfo->{addweak};
    my $deletes     = (exists $libinfo->{deldep})  && $libinfo->{deldep};
    my $weakdeletes = (exists $libinfo->{delweak}) && $libinfo->{delweak};

    -f $dstfile
	and ask_overwrite( $dstfile );

    my( $prefix, $comments, $strong, $weak, $suffix ) = getdepfile( $srcfile );

    my $addstrong = expand_deps( $adds )
	if $adds;
    my $delstrong = expand_deps( $deletes )
	if $deletes;

    my $addweak =   expand_deps( $weakadds )
	if $weakadds;
    my $delweak =   expand_deps( $weakdeletes )
	if $weakdeletes;

    # While we initially filter out adds and deletes,
    # the add are inserted back in later (this avoids
    # getting duplicates if we're given an add for an
    # already existing item).

    my @finalstrong =
	map { (
		(defined $comments->{$_} ? (@{ $comments->{$_} }) : ( )),
		"$_\n",
	    ) }
	sort
	    keys(%$addstrong),
	    grep { ! ($delstrong->{$_} || $addstrong->{$_}) } keys%$strong;

    my @finalweak =
	map { (
		(defined $comments->{$_} ? (@{ $comments->{$_} }) : ( )),
		"weak:$_\n",
	    ) }
	sort
	    keys(%$addweak),
	    grep { ! ($delweak->{$_} || $addweak->{$_}) } keys%$weak;

    putdepfile( $dstfile, $prefix, \@finalstrong, \@finalweak, $suffix );
}

# TODO - add more command types
my @libdepcommands = qw( adddep deldep addweak delweak );
my %libdepcommands;
@libdepcommands{@libdepcommands} = ( );

my @libdetailcommands = qw( adddetail deldetail );
my %libdetailcommands;
@libdetailcommands{@libdetailcommands} = ( );

my %command2ext;
@command2ext{@libdepcommands}    = ( 'dep' )  x scalar(@libdepcommands);
@command2ext{@libdetailcommands} = ( 'opts' ) x scalar(@libdetailcommands);
my %ext2editfunc = (
    dep		=> \&editdep,
    opts	=> \&editopts,
);

my $depitems;

my $usage =
"Usage: $0 <action> <changesetfile> [<checkin message>]
  where:
    <action> is one of: prepare apply undo status
	prepare - examines the information in the changeset,
		  checks that all the target files can be editted
		  applies the changes to each (they will be discarded
		    if the target file is changed)
	apply   - (<checkin message> is required for apply)
		  confirms that the changesetfile has not been altered
		  that none of the target files have been altered
		  all of the target files can be locked
		  commits the changes
		  (if any failure occurs in the early stages, any files
		  that have been locked will be unlocked again, and
		  another prepare run will be required)
	undo    - all of the files are reverted back to their original form
		  (beware of doing this if subsequent changes have been
		  made - they will also be undone)
		  (Warning: this function is not well tested.)
	status  - display the current state of applying the changesetfile
    <changesetfile> is a file that has been approved by validate_setofchanges
";

my $infofile;

sub storeinfo {
  store $depitems, $infofile
    or die "cannot write info file $infofile ($!)";
}

sub initinfo {
  my $file = shift;

  $infofile = "$file.info";

  if( -f $infofile ) {
    $depitems = retrieve $infofile;
  }
}

sub loadinfo {
  my $file = shift;

  die "setofchanges file ($file) doesn't exist\n"
    unless -f $file;

  my $csstamp = (stat _)[9];

  unless( exists $depitems->{csfilestamp}
      && $depitems->{csfilestamp} == $csstamp ) {
    unless( exists $depitems->{status} ) {
      $depitems->{status} = 'initializing';
      storeinfo;
    }
    @ARGV = ( $file );
    $depitems->{csfilestamp} = $csstamp;
    while( <> ) {
      # ignore blank/comment lines
      next if /^\s*#/;
      next if /^\s*$/;
      chomp;
      my( $command, @argrest ) = split;
      if( exists $libdepcommands{$command} 
	  or exists $libdetailcommands{$command}  ) {
	my $lib = $argrest[0];
	push @{ $depitems->{lib}{$lib}{$command} }, \@argrest;
	$depitems->{lib}{$lib}{libmap} ||= libmap( $lib )->{metadir}
	    || die "cannot map lib info for $lib";
	$depitems->{lib}{$lib}{extensions}{ $command2ext{$command} } ||= { };
      } else {
	# insert handlers for other types of commands before this else
	# if we get here, no handler understood the command
	die "unknown command ($command)";
      }
    }
  $depitems->{status} = 'preparing';
  storeinfo;
  }
}

sub rcschanged {
    my $file = shift;
    return "$file has been changed"
      if `aco -p $file 2>/dev/null | cmp $file - 2>/dev/null`;
    return undef;
}

sub getrcsstatus {
    my $file = shift;
    my( $version, $locked );
    my @rcsinfo = `rlog -h $file 2>&1`;
    my $inlock = 0;
    while( my $item = shift @rcsinfo ) {
	if( $inlock ) {
	    if( $item =~ /\s+(\S+:\s*\S+)/ ) {
		$locked .= "($1) ";
	    } else {
		$inlock = 0;
	    }
	}
	if( $item =~ /^head:\s*(\S+)/ ) {
	    $version = $1;
	}
	if( $item =~ /^locks:/ ) {
	    $inlock = 1;
	}
    }
    return(
	$version,
	$locked,
	(-w $file and "$file is writeable"),
	rcschanged($file)
    );
}

sub rcslock {
  my $file = shift;
  my $output = `aco -l $file 2>&1`;
  my $status = $?;
  my $version;
  $output =~ m/revision (\S+) \(locked\)/
    and $version = $1;
  return $version;
}

sub rcsunlock {
  my $file = shift;
  my $output = `aco -u -f $file 2>&1`;
}

my $checkinmessage;

sub rcsci {
  my $file = shift;
  my $output = `aci -u -m'$checkinmessage' $file 2>&1 </dev/null`;
  die "checkin of $file failed (status $?), output:\n$output"
    if $?;
  my( $newversion, $oldversion );
  ( $newversion, $oldversion ) =
      ($output =~
	m/new revision: (\S+); previous revision: (\S+)/)
    or
  ( $newversion, $oldversion ) =
      ($output =~
	m/initial revision: (\S+)/)
    or
  ( $newversion, $oldversion ) =
      ($output =~
	m/file is unchanged(\s*); reverting to previous revision (\S+)/);
  $newversion = $oldversion unless $newversion;
  return ($newversion, $oldversion);
}

sub warn_if_unedittable {
  my( $srcfile, $locked, $changed, $changeable ) = @_;
  warn "$srcfile is already locked ($locked)\n"
    if $locked;
  warn "$changed\n"
    if $changed;
  warn "$changeable, but not locked???\n"
    if $changeable and ! $locked and ! $changed;
  return $locked || $changed || $changeable;
}

# doprepare returns nonzero for complaints, 0 is clean
sub doprepare {
  my( $file, $ext, $libinfo ) = @_;
  my $srcfile = "$file.$ext";
  my $dstfile = "$srcfile.update";
  my( $version, $locked, $changeable, $changed ) = getrcsstatus( $srcfile );
  my $editor = $ext2editfunc{$ext};
  my $filestamp = (stat $srcfile)[9];
  my $extinfo = $libinfo->{extensions}{$ext};
  my $anycomplaints;

  # unlock if we're aborting after we got the lock
  if( exists $extinfo->{mylock}
      and $extinfo->{mylock} ) {
    rcsunlock( $srcfile )
      unless $extinfo->{mylock} eq 'new';
    $extinfo->{mylock} = 0;
    delete $extinfo->{newversion};
    return 0;
  }

  $anycomplaints ||=
    warn_if_unedittable( $srcfile, $locked, $changed, $changeable );

  # no previous version, or everything matches
  my $version_ok
      = exists $extinfo->{oldversion}
	&& (
	      (!defined($extinfo->{oldversion}) && !defined($version))
	      ||  ( $extinfo->{oldversion} eq $version
		  and exists $extinfo->{filestamp}
		  and $extinfo->{filestamp} == $filestamp ) );

  if ($version_ok
      and -f $dstfile
      and exists $extinfo->{efilestamp}
      and $extinfo->{efilestamp} == ((stat $dstfile)[9]) ) {
    print "Still ready to use $dstfile for installation\n";
  }
  else {
    $editor->( $srcfile, $dstfile, $libinfo );
    system( "cp", $dstfile, $dstfile.".orig" );
    print "Prepared $dstfile for installation\n";
  }
  $extinfo->{oldversion} = $version;
  $extinfo->{locked}     = $locked;
  $extinfo->{changeable} = $changeable;
  $extinfo->{mylock}     = 0;
  $extinfo->{filestamp}  = $filestamp;
  $extinfo->{efilestamp} = ((stat $dstfile)[9]);

  return $anycomplaints;
}

# doaplock returns 0 if it successfully gets the lock, nonzero if abort required
sub doaplock {
  my( $file, $ext, $libinfo ) = @_;
  my $srcfile = "$file.$ext";
  my $dstfile = "$srcfile.update";
  my( $version, $locked, $changeable, $changed ) = getrcsstatus( $srcfile );
  my $filestamp = (stat $srcfile)[9];
  my $extinfo = $libinfo->{extensions}{$ext};

  my $aborting = 0;

  # continue if it's already locked (but this shouldn'y happen)
  $aborting ||=
    warn_if_unedittable( $srcfile, $locked, $changed, $changeable );

  my $UV = 'X*XundefX*X*';
  my $ov = $extinfo->{oldversion} || $UV;
  my $nv = $version               || $UV;
  if( $ov ne $nv ) {
    warn "version of $file has changed from $ov to $nv\n";
    $aborting++;
  }
  if( $ov ne $UV && $extinfo->{filestamp} != $filestamp ) { warn "$file has been changed since edits applied\n";
    $aborting++;
  }
  if( ! -f $dstfile ) {
    warn "$dstfile has been removed since edits applied\n";
    $aborting++;
  }
  if( $extinfo->{efilestamp} != ((stat $dstfile)[9]) ) {
    warn "$dstfile has been changed since edits applied (continuing anyhow)\n";
  }

  return 1 if $aborting;

  if ($ov ne $UV) {
    my $newversion = rcslock( $srcfile );
    return 1 unless $newversion;
    if( $newversion ne $version ) {
      rcsunlock( $srcfile );
      warn "locked version ($newversion) was different from base version ($version)\n";
      return 1;
    }
    $extinfo->{newversion} = $newversion;
    $extinfo->{mylock} = 1;
  }
  else {
    $extinfo->{newversion} = '1.1';
    $extinfo->{mylock} = 'new';
  }
  return 0;
}

sub doapply {
  my( $file, $ext, $libinfo ) = @_;
  my $srcfile = "$file.$ext";
  my $updfile = "$srcfile.update";
  my $savfile = "$srcfile.save";
  my $extinfo = $libinfo->{extensions}{$ext};

  if ( -f $srcfile ) {
    system "mv", $srcfile, $savfile
      and die "Failed 'mv $srcfile $savfile', about to check in";
  }
  system "mv", $updfile, $srcfile
    and die "Failed 'mv $updfile $srcfile', about to check in";
  my( $newversion, $oldversion ) = rcsci( $srcfile );
  warn "There was no change made to file: $file, so rcs reverted to the original\n"
    if defined $oldversion && $newversion eq $oldversion;
  $extinfo->{newversion} = $newversion;
  my $savefile = "$srcfile.save";
  -f $savefile or $savefile = '';
  system( "rm $srcfile.update* $savefile" );
}

sub doundo {
  my( $file, $ext, $libinfo ) = @_;
  my $srcfile = "$file.$ext";
  my $extinfo = $libinfo->{extensions}{$ext};
  unless( exists $extinfo->{oldversion} ) {
      warn "Can't find old version for $srcfile, skipping\n";
      return 1;
    }
  my $oldversion = $extinfo->{oldversion};

  warn "Checking out $srcfile for edit\n";
  system( "aco -l $srcfile" );
  warn "Checking out version $oldversion of $srcfile\n";
  system( "aco -p$oldversion $srcfile >$srcfile" );
  warn "Checking back in version $oldversion of $srcfile as latest version\n";
  system( "aci -u -m'reverting to version $oldversion' $srcfile" );
}


my %action2sub = (
    status	=>	\&dostatus,
    prepare	=>	\&doprepare,
    aplock	=>	\&doaplock,
    apply	=>	\&doapply,
    undo	=>	\&doundo,
);

# 'aplock' is an internal action and cannot be requested on the command line
my %commandaction = (
    status	=>	1,
    prepare	=>	1,
    apply	=>	1,
    undo	=>	1,
);

MAIN:
{

  (print $usage), exit(0)
    if $ARGV[0] =~ /^-+h/;

  die $usage
      if scalar(@ARGV) < 2;

  my $action = shift;
  my $csfile = shift;

  die $usage
      unless exists $commandaction{$action};

  if ($action eq 'apply') {
    die "No checkin message provided\n$usage"
	unless @ARGV;
    $checkinmessage = join( ' ', @ARGV );
  }
  initinfo( $csfile );

  if( $action eq 'status' ) {
    unless( defined $depitems ) {
      warn "No attemp has been made to prepare $csfile for application\n";
      exit(0);
    }
  }

  loadinfo( $csfile );

  my $had_errors = 0;

  if( $action eq 'apply' ) {
    if( $depitems->{status} ne 'prepare' ) {
      warn "***NOT in prepare state - running apply command is not allowed.\nRunning as status command only instead.\n";
      $action = 'status';
      ++$had_errors;
    } else {
      $action = 'aplock';
    }
  }
  if( $action eq 'status' ) {
    warn "Current status is: $depitems->{status}\n";
    exit $had_errors;
  }

  RUNACTION: {
    my( $actionfunc ) = $action2sub{$action};
    foreach my $lib ( keys %{$depitems->{lib} } ) {
      my $libinfo = $depitems->{lib}{$lib};
      my $basedir = $libinfo->{libmap};
      my $basefile = "$basedir/$lib";

      if( $action eq 'aplock' ) {
	for my $ext (keys %{ $libinfo->{extensions} } ) {
	  if( $actionfunc->( $basefile, $ext, $libinfo ) ) {
	    warn "ABORTING: fix errors and rerun prepare before retrying\n";
	    $action = 'prepare';
	    ++$had_errors;
	    redo RUNACTION;
	  }
	}
      } else {
	for my $ext (keys %{ $libinfo->{extensions} } ) {
	  if( $actionfunc->( $basefile, $ext, $libinfo ) ) {
	    ++$had_errors;
	  }
	}
      }
    }
    if( $action eq 'aplock' ) {
      $action = 'apply';
      redo RUNACTION;
    }
    my $suffix = $had_errors ? 'failed' : '';
    $depitems->{status} = "$action$suffix";
    storeinfo;
  }
}
