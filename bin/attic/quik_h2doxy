#!/usr/bin/env perl

use strict;
use warnings;

use File::Basename;
use Getopt::Long;

use BDE::Util::Nomenclature qw(getComponentGroup getComponentPackage);

$|=1;
#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----
#------------------------------------------------------------------------------

# major states
use constant NOSTATE        => 0;
use constant INTRO          => 1;
use constant CLASS          => 2;

# minor states
use constant CLASSES        => 3;
use constant DESC           => 4;
use constant CLASSHEAD      => 5;
use constant PROTOTYPE      => 6;
use constant COMMENT        => 7;
use constant PREFORM        => 8;
use constant TITLE          => 9;
use constant CLASSES_BULLET => 10;

my ${BR}="\\n\\n";             # whitespace around code blocks

my %opts;                      # command line options


#-----------------------------------------------------------------------------

{ # closure for filelists
    my @grouplist;
    my @packagelist;
    my $hfile = "BDEQuickLinks.header";

    #-------------------------------------------------------------------------

    sub get_component_filelist($$$$) {
        my ($root,$group,$package,$component) = @_;

        my $r = "$root/$group/$package/$component.h";
        $r = "$root/$group/include/$component.h"        unless -f $r;
        die "File $r not found"                         unless -f $r;
        # print "-- *           Component: $r\n";
        return $r;
    }

    #-------------------------------------------------------------------------
    # get list of files for a package

    sub get_package_filelist($$$) {
        my ($root,$group,$package) = @_;

        push @packagelist, $package;

        my @files;
        my $pdir = "$root/$group/$package";
        die "Directory $pdir not found"                 unless -d $pdir;
        my $pmem = "$pdir/package/$package.mem";
        die "mem File $pmem not found"                  unless -r $pmem;

        # package docs
        my $pdoc = "$pdir/doc/$package.txt";
        if (-r $pdoc) {
        # print "-- *         Package: $pdoc\n";
            push @files, $pdoc;
        }
        else {
            print("?? No package doc for $package\n");
        }
        open(PMEM, "< $pmem") || die "cannot open $pmem: $!";
        while (<PMEM>) {
            chomp;
            my $c = $_;
            $c =~ s/#.*$//;     # ignore comments
            for my $cc (split("[ \t,]+",$c)) {
                if ($cc ne "")    {
                    push @files, 
                        get_component_filelist($root,$group,$package,$cc);
                }
            }
        }
        close PMEM || die("cannot close $pmem: $!");
        return @files;
    }

    #-------------------------------------------------------------------------
    # get list of files for a package group

    sub get_group_filelist($$) {
        my ($root,$group) = @_;
        push @grouplist, $group;

        my @files;
        my $gdir = "$root/$group";
        die "Directory $gdir not found"                 unless -d $gdir;
        my $gmem = "$gdir/group/$group.mem";
        die "mem File $gmem not found"                  unless -r $gmem;

        # package group docs
        my $gdoc = "$gdir/doc/$group.txt";
        if (-r $gdoc) {
            # print "-- *     Group: $gdoc\n";
            push @files, $gdoc;
        }
        else {
            print "?? No package group doc for $group\n";
        }
        open(GMEM, "< $gmem") || die "cannot open $gmem: $!";
        while (<GMEM>) {
            chomp;
            my $p = $_;
            $p =~ s/#.*$//;    # ignore comments
            for my $pp (split("[ \t,]+",$p)) {
                if ($pp ne "")    {
                    push @files, get_package_filelist($root,$group,$pp);
                }
            }
        }
        close GMEM || die("cannot close $gmem: $!");
        return @files;
    }

    #-------------------------------------------------------------------------
    # get list of source files, based upon *.mem
    # each argument can be group, package, or component

    sub get_filelist ($@) {
        my ($root, @args) = @_;
        my @files;

        # generate list of filenames
        print "-- * Finding source files in " . join(", ", @args) . "\n";
        foreach my $arg (@args)    {
            $arg =~ s/\.[a-zA-Z]+//;
            my $package = $arg;
            $package =~ s/_.*$//;
            my $group = substr($package,0,3);
            if ($group eq $package)    {
                print "-- * Finding source files in package group $group.\n";
                push @files, get_group_filelist($root, $group);
            }
            elsif ($package eq $arg) {
                print "-- * Finding source files in package $package.\n";
                push @files, get_package_filelist($root, $group, $package);
            }
            else    {
                print "-- * Finding source file(s) for component $arg.\n";
                push @files, get_component_filelist($root, $group, $package,
                    $arg);
            }
        }
        return @files;
    }

    #-------------------------------------------------------------------------

    sub create_BDE_quick_links($) {
        my $outdir = shift;

        open(HEADER, "> $outdir/$hfile") || die "cannot create $hfile: $!";
        print HEADER<<_HEADER_1_END;
<html>
 <head>
   <title>Bloomberg Development Environment</title>
   <link href="doxygen.css" rel="stylesheet" type="text/css">
 </head>
<body bgcolor="#FFFFFF">

 <div class="qindex">
_HEADER_1_END
        my @list;

        if (defined(@grouplist) and scalar(@grouplist) > 1)  {
            @list = @grouplist;
        } elsif (defined(@packagelist) and scalar(@packagelist) > 1)  {
            @list = @packagelist;
        }
        if (defined(@list)) {
            print HEADER "<table border=2 cellspacing=0 cellpadding=0 " .
                "align=center>\n" .
                " <tr>\n" .
                "  <td valign=top align=center>\n" .
                "   <p align=center><b><i>Quick Links:</i></b></p>\n" .
                "  </td>\n" .
                "  <td valign=top align=center>\n" .
                "   <p align=center>\n"; 
            print HEADER
                join ' | ',map {
                    qq[<a class="qindex" href="group__${_}.html">$_</a>]
                } @list;
            print HEADER
                "\n" .
                " </td>\n" .
                " </tr>\n" .
                " </table>\n";
        }
        print HEADER "\n  </div>\n";
        close HEADER;
    }
}

#------------------------------------------------------------------------------

sub readFile ($) {
    my $fname = shift;
    my @original_lines;

    die "$fname not regular file" if ! -f $fname;
    open(FH, "< $fname") or die "!! cannot open $fname";
    while (<FH>) {
        chomp;
        push @original_lines, $_;
    }
    close(FH);
    return \@original_lines;
}

#------------------------------------------------------------------------------

sub writeFile ($$) {
    my $fname = shift;
    my $lines = shift;

    open(FH, "> $fname") or die "!! cannot open $fname";
    for (@$lines) {
        print FH "$_\n";
    }
    close(FH);
}

#------------------------------------------------------------------------------

{ # state closure
    my (@majorstate,@minorstate); # major/minor state

    sub pushstate  ($$) { push @majorstate, $_[0]; push @minorstate, $_[1]; }
    sub popstate   ()   { return pop(@majorstate),pop(@minorstate); }
    sub majorstate ()   { return $majorstate[-1]; }
    sub minorstate ()   { return $minorstate[-1]; }
    sub statedepth ()   { return scalar(@majorstate)-2; }
    sub resetstate ()   { @majorstate=(-1,NOSTATE); @minorstate=(-1,NOSTATE); }
    # the initial states have an extra '-1' in it to help track state errors
    # in debug mode
}

{ # line store closure

    my @lines;                # this is the output

    #----------

    # reset line store
    sub resetlines () {
        @lines=();
    }

    #--------------------------------------------------------------------------

    sub pushline ($) {
        my $string = shift;

        if ($opts{debug}) {
            push @lines, statedepth().' '.majorstate()."/".minorstate().
                 ": ".$string;
        } else {
            push @lines, $string;
        }
    }

    #--------------------------------------------------------------------------

    sub appendline ($) {
        my $string = shift;

        if ($opts{debug}) {
            push @lines, statedepth().' '.majorstate()."/".minorstate().
                 "[Append]: ".$string;
        } else {
            push @lines, pop(@lines) . $string;
        }
    }

    #--------------------------------------------------------------------------
    # retrieve processed output

    sub getlines () {
        return \@lines;
    }

    #--------------------------------------------------------------------------
    # retrieve current line count

    sub getlinecount () {
        return $#lines;
    }
}

#------------------------------------------------------------------------------
# Group levels and names
# Supporting three levels of nesting

use constant PACKAGE_GROUP => 0;
use constant PACKAGE       => 1;
use constant COMPONENT     => 2;
use constant MAX_GROUPS    => 3;
my @level_name = (
   "Package Group",
   "Package",
   "Component"
   );

{ # Groups closure
    # TODO: Need to provide a function to yield groupname without +
    #       And then use it to provide the "\defgroup" header
    #
    my @beginGroups;
    my @endGroups;
    my $inGroup = 0;

    #--------------------------------------------------------------------------

    sub setGroups($@) {
        my ($group,@names) = @_;
        my $g = 0;

        #print STDERR "setGroups($group @names)\n";
        @beginGroups = ( );
        @endGroups = ( );
        while($g <= $group) {
            my $g_noplus = $names[$g];
            $g_noplus =~ s/\+/_P_/g;
            push @beginGroups, "/** \\addtogroup $g_noplus";
            push @beginGroups, " * \@{ ";
            push @beginGroups, " */"   if ($g < $group);
            ++$g;
        }
        while ($g > 0) {
            push @endGroups, "/* \@} */";
            --$g;
        }
    }

    #--------------------------------------------------------------------------

    sub openGroups($) {
        my $inComment = shift;
        unless ($inGroup) {
            $inGroup = 1;
            #pushline("/*") unless ($inComment);
            for my $b (@beginGroups) {
                pushline($b);
            }
            pushline(" */") unless ($inComment);
        }
    }

    #--------------------------------------------------------------------------

    sub closeGroups() {
        if ($inGroup) {
            for my $e (@endGroups) {
                pushline($e);
            }
            $inGroup = 0;
        }
    }
}

#------------------------------------------------------------------------------

{ # header closure
    use constant MAXHEADERLEVELS => 6;
    my @headers;
    my @levels;
    my $nheaders = 0;
    my $prevlevel = 0;

    #--------------------------------------------------------------------------
    # increment level count and return tag for this level

    sub getTag($) {
        my $hlev = shift;
        $hlev --;  # caller is 1-indexed
        $levels[$hlev] ++;
        my $tag = join('.',@levels[0..$hlev]);
        $hlev ++;
        while ($hlev < MAXHEADERLEVELS) {
            $levels[$hlev] = 0;
            $hlev++;
        }
        return $tag;
    }

    #--------------------------------------------------------------------------
    # main working routine

    sub pushheader($$) {
        my ($level, $txt) = @_;
        my $dashes="------";   # need MAXHEADERLEVELS dashes

        ++ $nheaders;
        my $tag = getTag($level);
        pushline(" * \\par");
        pushline(" * <A NAME=\"$tag\"> \\par $txt </A>");
        pushline(" * \\par");
        #my $tag = "$nheaders.$level";
        #pushline(" * \\htmlonly");
        #if ($level <= 3)    {
        #    my $hlvl=$level+2;  # Levels 1 and 2 are in use already
        #    pushline("\t<A name=\"$tag\"><H$hlvl>$txt</H$hlvl></A>");
        #} else {
        #    pushline("\t<A name=\"$tag\"><P><B>$txt</B></P></A>");
        #}
        #pushline(" * \\endhtmlonly");
        #
        # TOC entries
        $txt =~ s/:$//o;    # remove trailing colon from TOC entry
        #
        # Adjust nesting for level
        while ($prevlevel < $level) {
            push @headers, " * <UL>";
            $prevlevel ++;
        }
        while ($prevlevel > $level) {
            push @headers, " * </UL>";
            $prevlevel --;
        }
        push @headers, " * <LI><A HREF=\"#$tag\"> $txt </A></LI>";
    }

    #--------------------------------------------------------------------------
    # Insert the Table of Contents in position $pos

    sub insertTOC ($$) {
        my $lines = shift;
        my $pos = shift;

        while ($prevlevel > 0) {
            push @headers, " * </UL>";
            $prevlevel --;
        }
        my $headers = getheaders();

        splice ( @$lines, $pos, 0, ( " * \\par " ) );
        splice ( @$lines, $pos, 0, @$headers );
        splice ( @$lines, $pos, 0, ( " * \\par Outline" ) );
        #for (@$lines) {
        #    print FH "$_\n";
        #}
    }
    
    #--------------------------------------------------------------------------
    # retrieve processed output

    sub getheaders () {
        return \@headers;
    }

    #--------------------------------------------------------------------------
    # reset headers

    sub resetheaders () {
        @headers=();
        @levels = ( 0, 0, 0, 0, 0, 0 ); # should be MAXHEADERLEVELS
        $prevlevel = 0;
    }
}
#------------------------------------------------------------------------------
# escape Doxygen-significant characters - use for comments only, not code.
# also, translate 'code' and *italic* markers in the text
# Note: - Funky multi-line s/// translates '*' to '\f' to avoid interpretation
#         as italics. tr/// undoes this after italics are done.
#       - Italics include (*this* *text*) but not (*)

sub escape ($) {
    my $string = shift;
    $string=~s{([<>&\$#\\])}{\\$1}go if $string;

    my $t;
    $string =~ s{(\s|^)' ([^']+) '}
                 {   $t = "$1<code>$2</code>";
                     $t =~ tr|\*|\f|;
                     $t
                 }gexo;
    $string =~ s{((\s|^)\(?)\*([^)*][^*]*)\*}{$1<I>$3</I>}g;
    $string =~ tr[\f][\*];
    return $string;
}

# substitute BDE constructs with Doxygen ones. This is the main workhorse
# routine of this application. It uses escape() and the two closures above
# to do its work.
sub substitute ($$) {
    my ($linesin,$filename) = @_;

    # add in the double slashes for *.txt files
    my $prepend = (($filename =~ m/\.txt$/) ? "//" : undef);
    my $memberPrefix = $filename;
    $memberPrefix =~ s/(^([a-z][a-z]?_)?[a-z0-9]+).*$/$1/o;

    resetstate(); # the previous file isn't guaranteed to leave the stack clean
    resetlines(); # clear out the line store
    resetheaders(); # start new list of headers for this file
    my $TOClocation = undef;

    # derive component name from filename
    # (verified against first line later)
    (my $component = $filename) =~ s/(?:\.h|\.txt)$//;
    my $package = getComponentPackage($component);
    my $package_group = getComponentGroup($component);
    my @groups = ( $package_group, $package, $component );

    # what group level are we at?
    my $group_level = ($package_group eq $package) ? PACKAGE_GROUP :
                      ($package eq $component) ? PACKAGE : COMPONENT;
    setGroups($group_level,@groups);
    #print STDERR "group_level = $group_level \n";
    
    my ($classname,@class_decl);

    pushline("/** \\file $component.h */");
    my $g_noplus = $groups[$group_level];
    $g_noplus =~ s!\+!_P_!g;
    pushline("/** \\defgroup $g_noplus"
        . " $level_name[$group_level] $groups[$group_level] */");
    pushline("");

    my $lno = 0;            # line number
    my $pending_header;     # there *might* be a /// ------ line coming.
    my $ispending = 0;      # is there a header pending?


    for my $line (@$linesin) {
        $line =~ s/^/$prepend/ if defined($prepend);
        $lno++;

        last if $line =~ m|INLINE|;


        # parse and verify filename on line 1
        if ($lno == 1) {
            if ($line =~ m|^//\s*(\w+)|) {
                my $c_component = $1;
                print "?? $filename: line 1 comment ($c_component) ".
                  "does not match file name\n"
                    if $c_component ne $component;
            } else {
                print "?? $filename: #1 comment not found\n";
            }
            next;
        }


        # never stay in group declaration for #includes
        closeGroups()  if ($line =~ m|^\s*#\s*include|);

        # INTRO - starts with PURPOSE
        if ($line =~ m|^//\@PURPOSE:?|) {
            # don't know why we're not in COMMENT.
            openGroups(1);
            $TOClocation = getlinecount() + 1;
            pushheader(1, "Purpose");
            $line =~ s|^//\@PURPOSE:?\s*||;
            print "?? $filename: PURPOSE: not completed!\n"
                if $line =~ m/^$/;
            pushline(" * ".escape($line));
            pushstate(INTRO,NOSTATE);
            next;
        }

        # INTRO
        if (majorstate() == INTRO) {

            # @CLASSES
            if ($line =~ s|^//\@CLASS(?:ES)?:?||) {
                pushheader(1, "Classes");
                pushline(" * \\par ".escape($line));
                pushstate(INTRO,CLASSES);
                next;
            }
            # @COMPONENTS
            if ($line =~ s|^//\@COMPONENT(?:S)?:?||) {
                pushheader(1, "Components");
                pushline(" * \\par ".escape($line));
                pushstate(INTRO,CLASSES);
                next;
            }
            # @PACKAGES
            if ($line =~ s|^//\@PACKAGE(?:S)?:?||) {
                pushheader(1, "Packages");
                pushline(" * \\par ".escape($line));
                pushstate(INTRO,CLASSES);
                next;
            }
            # inside @CLASSES, @COMPONENTS, or @PACKAGES:
            if (minorstate() == CLASSES) {
                if ($line =~ m|^// *$memberPrefix.*:|) {
                    $line =~ s|^// *($memberPrefix.*:)|\*$1\*|;
                    pushstate(INTRO,CLASSES_BULLET);
                    pushline(" * - ".escape($line)); # first bullet
                    next;
                }
                else {
                    # No bullets.  Handle normally.
                    popstate();
                }
            }
            if (minorstate() == CLASSES_BULLET) {
                $line =~ s|^// *||o;
                if ($line =~ /\w/) {
                    if ($line =~ m/^$memberPrefix.*:/) {
                       $line =~ s/^($memberPrefix.*:)/\*$1\*/;
                       pushline(" * - ".escape($line)); # bullet
                    } else {
                       appendline(" ".escape($line)); # more bullet text
                    }
                } else {
                    pushline(" *");
                    popstate();    # CLASSES_BULLET
                    popstate();    # CLASSES
                }
                next;
            }

            # AUTHOR
            if ($line =~ s|^//\@AUTHOR:?||o) {
                pushline(" * \\author".escape($line));
                pushline(" * \\par");
                next;
            }

            # SEE_ALSO
            if ($line =~ s|^//\@SEE[_ ]*ALSO:?||o) {
                pushline(" * \\sa".escape($line));
                next;
            }

            # CONTACT
            if ($line =~ s|^//\@CONTACT:?||o) {
                pushline(" * \\note Contact:".escape($line));
                next;
            }
            # LAST_MODIFIED
            if ($line =~ s|^//\@LAST[_ ]*MODIFIED:?||o) {
                pushline(" * \\note Last-Modified:".escape($line));
                next;
            }
            # DEPRECATED
            if ($line =~ s|^//\@DEPRECATED:?||o) {
                pushline(" * \\note DEPRECATED:".escape($line));
                next;
            }

            # DESCRIPTION
            if ($line =~ s|^//\@DESCRIPTION:?||o) {
                pushheader(1,"Description");
                pushline(" * ".escape($line));
                popstate();
                pushstate(INTRO,DESC);
                next;
            }

            if (minorstate()==PREFORM) {
                if ($line =~ m|^//\.\.|o) {
                    pushline("\\endcode${BR}");
                    popstate();
                    next;
                }
                if ($line =~ m|^//|o) {
                    $line =~ s|^//||o;
                    pushline($line);
                    next;
                }
                # not a comment; it must be *real* code.
                popstate();
                pushline("\\endcode${BR}");
                print "?? $filename#$lno: code block not terminated\n";
                # fall through
            }
            if (minorstate()==NOSTATE or minorstate()==DESC) {
                my $fallthrough = 0;
                if ($ispending) {
                    $ispending = 0;
                    if ($line =~ m|^///\s*([-=]\s*[-=])|) {
                        # header level is 2 + num spaces btw [-=] chars
                        pushheader(length($1),$pending_header);
                        next;
                    } else {
                        pushheader(2,$pending_header);
                        # fall through; this line didn't match
                    }
                }
                # Header at some level
                if ($line =~ m|^///\s*[\w']|) {
                    $line =~ s|^///\s*||;
                    $ispending = 1;
                    $pending_header = escape($line);
                    # pushline(" * \\par ".escape($line));
                } elsif ($line =~ m|^//\.\.|) {
                    pushstate(INTRO,PREFORM);
                    pushline("${BR}\\code");
                } elsif ($line =~
                         m|^//\s*[\w\\&'"~(*!{}\[\]^\.\$=?:<>\|+-]| ) {
                    # most common lines -- DCL What is the prev RE???
                    $line =~ s|^//\s*||o;
                    pushline(" * ".escape($line));
                } elsif ($line =~ m|^//\s+/|o) {
                    # special case: // /+ is distinct from ///+
                    $line =~ s|^//||o;
                    pushline(" *".escape($line));
                } elsif ($line =~ m|^//\s+\.[^.]|o) {
                    # special case: // . is distinct from //..
                    $line =~ s|^//||o;
                    pushline(" *".escape($line));
                } elsif ($line =~ m|^//\s*$|o) {
                    pushline(" * \\par ");
                } elsif ($line !~ m|^//|o) {
                    # no comment - must be code.
                    popstate();
                    pushline(" */");
                    closeGroups();
                    $fallthrough = 1;
                } elsif ($line =~ s|^//@\s*(.*):?\s*$||) {
                    pushheader(1, $1);
                    pushline(" * \\par");
                    pushline(" * ".escape($line));
                    next;
                } else {
                    print "?? $filename: ".
                      "Don't know what to do with line $lno: $line\n";
                }

                next if not $fallthrough;
            }
        }

        # ----------- code -----------
        #
        if ($line !~ m[^\s*//]) {
            # safety check, just to make sure
            if (minorstate()==COMMENT) {
                pushline(" */");
                popstate();
            }
        }
        # Use namespace BloombergLP as a guard for bde groups
        # But remove the namespace for clarity
        if ($line =~ m[^namespace\s+BloombergLP\s*{]) {
            openGroups(0);
            next;
        }
        if ($line =~ m[^}\s*//\s*[a-z]*\s*namespace\s*BloombergLP]) {
            closeGroups();
            next;
        }

        if ( $line =~ m!^\s*(template|class|struct)\s*!o ) {
            openGroups(0); 
        }

        ### start of class
        if ($line =~ m!^\s*(class|struct)\s*(.*?)\s*{!) {
            # non-comment line: terminate existing comment
            if (minorstate()==COMMENT) {
                pushline(" */");
                popstate();
                pushline("");
            }
            openGroups(0);
            # not currently used because Doxygen doesn't allow a space in
            # specified classnames (like for instance in a specialised
            # template class). Retained until this is a solvable problem.
            $classname = $2;
            # currently only the outer class causes the state depth to
            # increase internally. This may change once internal class/structs
            # can always detect their ends.
            pushstate(CLASS,NOSTATE) if statedepth()==0;

            # enter class head state
            pushstate(CLASS,CLASSHEAD);

            # save the actual code line to place it after the class comment.
            # Doxygen doesn't grok the class docs being *inside* the class as
            # BDE has it. Neither can we use the 'class' special command as
            # it doesn't work for template specialisations including spaces in
            # the classname (as in: 'template<> class foobar<void *>'
            push @class_decl, $line;
            # in fact this cases the comment to end up between the template
            # and the class in cases where they appear on seperate lines.
            # However Doxygen appears not to care. However lines following
            # the class/struct are handled - see 'multi-line class head' below.
            next;
        }

        ### class body
        if (majorstate()==CLASS or majorstate()==NOSTATE) {
            if ($line=~m|^\s*\w| and minorstate()==CLASSHEAD) {
                # multi-line class head
                $class_decl[-1].="\n$line";
            } elsif ( $line =~ m|\s+//\s*=+\s*$|o ) {
                # beginning or end of a centred title (ignore)
                if (minorstate()==TITLE) {
                    popstate();
                } else {
                    pushstate(majorstate,TITLE);
                }
                # ignore
            } elsif (minorstate()==TITLE) {
                # ignore - interior of centred title
            } elsif ($line =~ m|//| and $line =~ m|CREATOR|) {
                # ignore - one line titles 
            } elsif ($line =~ m|//\s*=+\s*$|) {
                # ignore - generic underlines
            } elsif ($line =~ m|^\s*$|) {
                # blank line ends all interior states
                if (minorstate()==PREFORM) {
                    pushline("\\endcode${BR}");
                    popstate();
                    print "?? $filename#$lno: code block not terminated\n";
                }
                if (minorstate()==COMMENT) {
                    pushline(" */");
                    popstate();
                }
                # if we were in a PROTOTYPE/CLASSHEAD we're not now
                while (minorstate()!=NOSTATE) {
                    if (minorstate()==CLASSHEAD) {
                        # push out a held-back class declaration
                        pushline(pop @class_decl);
                    }
                    popstate();
                }
                pushline("");
            } elsif ($line =~ m|^\s*};|) {
                # end of multi-line class body
                # note this does *not* detect one-liner classes.
                if (minorstate()==PREFORM) {
                    pushline("\\endcode${BR}");
                    popstate();
                    print "?? $filename#$lno: code block not terminated\n";
                }
                if (minorstate()==COMMENT) {
                    pushline(" */");
                    popstate();
                }
                if (minorstate()==PROTOTYPE) {
                    #proto before comment
                    popstate(); 
                } elsif (minorstate()==CLASSHEAD) {
                    #class doc
                    popstate();
                    pushline(pop @class_decl);
                }
                pushline($line);
                popstate() if statedepth()==1; #end of outer class
            } elsif ($line =~ m|//| and
                     ($line =~ m[MANIP|ACCES|OPERATOR])) {
                # convert titles we don't want to ignore
                $line =~ s|//||o;
                pushline("/** \\par ".escape($line)." */");
                pushline("");
            } elsif ($line !~ m|//| and $line =~ m|\(|) {
                # function prototype
                if (minorstate()==COMMENT) {
                    pushline(" */");
                    popstate();
                }
                pushstate(majorstate,PROTOTYPE)
                  unless minorstate==PROTOTYPE;
                pushline($line);
            } elsif ($line =~ m|^\s*//| and
                     (minorstate()==PROTOTYPE or minorstate()==CLASSHEAD)) {
                # comment immediately folllowing prototype or class head
                if (minorstate()==CLASSHEAD) {
                    pushline("/*!");
                } else {
                    pushline("/*!<");
                }
                pushstate(majorstate,COMMENT);
                $line =~ s|//||;
                pushline(" *".escape($line));
            } elsif ($line =~ m|^\s*//|) {
                # regular comment or preformatted text
                $line=~s/\bBUG\b/\bug/g;
                if ($line =~ m|//\.\.|) {
                    if (minorstate()==COMMENT) {
                        pushstate(majorstate,PREFORM);
                        pushline("${BR}\\code");
                    } elsif (minorstate()==PREFORM) {
                        pushline("\\endcode${BR}");
                        popstate();
                    }
                } else {
                    unless (minorstate()==COMMENT
                            or minorstate()==PREFORM) {
                        pushstate(majorstate,COMMENT);
                        pushline("/*!");
                    }
                    $line =~ s|//||o;
                    if (minorstate()==PREFORM) {
                        pushline($line); #noesc
                    } else {
                        pushline(" *".escape($line));
                    }
                }
            } elsif ($line !~ m|^\s*//| and minorstate()==PREFORM) {
                # end of comments, in PREFORM block (abnormal termination)
                pushline("\\endcode${BR}");
                pushline(" */");
                pushline($line); #noesc
                popstate();        # PREFORM->COMMENT
                popstate();        # COMMENT->PROTOTYPE|NOSTATE
                if (minorstate()==PROTOTYPE) {
                    #proto before comment
                    popstate();
                } elsif (minorstate()==CLASSHEAD) {
                    #class doc
                    popstate();
                    pushline(pop @class_decl);
                }
                print "?? $filename#$lno: code block not terminated\n";
            } elsif ($line !~ m|^\s*//| and minorstate()==COMMENT) {
                # end of comments
                pushline(" */");
                popstate();
                #popstate() if minorstate==PROTOTYPE; #proto before comment
                if (minorstate()==PROTOTYPE) {
                    #proto before comment
                    popstate(); 
                } elsif (minorstate()==CLASSHEAD) {
                    #class doc
                    popstate();
                    pushline(pop @class_decl);
                }
                pushline($line); #noesc
            } elsif ($line =~ m|^(\s*\w+.*)//(.*)$|) {
                # comment following code
                my ($before,$after)=($1,$2);
                pushline("/*! ".escape($after)." */");
                pushline($before);
            } else {
                pushline($line);
            }
            next;
        }

        pushline($line);
    }                                # for my $line...

    if (minorstate()==PREFORM) {
        pushline("\\endcode${BR}");
        popstate();
        print "?? $filename#$lno: code block not terminated\n";
    }
    if (minorstate()==COMMENT) {
        pushline(" */");
        popstate();
    }
    pushline("");
    closeGroups();
    # If there's a Purpose, we can place a TOC.
    insertTOC(getlines(),$TOClocation) if defined($TOClocation);
    return getlines();
}

#------------------------------------------------------------------------------

sub usage {
    my $prog = basename $0;

    print STDERR<<_USAGE_END;

Usage: $prog -h | [-v] [-d] <in dir> <out dir>\n\n";
  --help     | -h            display usage information (this text)
  --debug    | -d            enable debug output - generates state information
                             prefixed to each output line. Note that the result
                             is not parsable by Doxygen and is for debug only.
  --verbose  | -v            enable verbose output - report each file as it is
                             processed.

_USAGE_END
}

#------------------------------------------------------------------------------

MAIN: {
    unless (GetOptions(\%opts, qw[
        help|?
        debug+
        verbose+
    ])) {
        usage(), exit 1;
    }
    usage(),exit(1) if @ARGV<2;

    my $indir = shift;
    my $outdir = shift;

    if ($opts{debug}) {
        print "\$indir='$indir'\n";
        print "\$outdir='$outdir'\n";
    }

    die "!! input directory $indir not readable" if ! -r $indir;
    die "!! output directory $outdir not writeable" if ! -w $outdir;

    print "** Scanning $indir...\n";

    # Note: get_filelist has the side-effect of collecting
    #       package groups and packages.  It must be called
    #       before create_BDE_quick_links, which uses these lists.
    my @headers = glob("$indir/*.h");
    #my @headers = get_filelist($root,@inlocs);

    die "!! No header files found in $indir" unless @headers;
    create_BDE_quick_links($outdir);

    for my $header (@headers) {
        my $basename=basename($header);

        print "-- Processing $basename...\n" if $opts{verbose};

        my $lines = readFile($header);
        $lines = substitute($lines,$basename);
        if ($lines) {
            $basename =~ s/\.[a-zA-Z]+$//;        # replace non-*.h extensions
            writeFile("$outdir/$basename.h", $lines);
        } else {
            print "?? No component name found in $header, skipped\n";
        }
    }
    print "** Processed ".scalar(@headers)." headers\n";
}

#------------------------------------------------------------------------------
